## ENBF Attempt

This is an attempt at generating a MySQL parser in any language.

tl;dr I went for a custom recursive descent PHP parser that can handle the full MySQL grammar converted from the .g4 notation to PHP code.

[Check it out!](https://github.com/adamziel/parser-generator-explorations/tree/trunk/custom-parser)

----

Explorations I did to get here:

* [MySQL grammar in ANTLR g4 format](https://github.com/mysql/mysql-workbench/blob/8.0/library/parsers/grammars/MySQLParser.g4) (thanks to MySQL workbench)
* [MySQL grammar in EBNF notation](https://github.com/adamziel/parser-generator-explorations/blob/71194eb0b1ac78fe3905b42662f19cdeac4adf42/ebnf/MySQLParser.ebnf#L14) thanks to the [grammar-converter](https://github.com/vorpal-research/grammar-converter/tree/master) tool.
* [A PHP parser](https://github.com/WordPress/sqlite-database-integration/pull/153) generated by AI based on the grammar. It works to an extent, but needs a few weeks of work before it's perfect.
* [An AI-converted PEG.js grammar](https://github.com/adamziel/parser-generator-explorations/blob/71194eb0b1ac78fe3905b42662f19cdeac4adf42/pegjs/join-lexer-and-parser/). Unfortunately, [the PEG.js parser exploration failed](https://github.com/adamziel/parser-generator-explorations/blob/71194eb0b1ac78fe3905b42662f19cdeac4adf42/pegjs/join-lexer-and-parser/README.md#L2).
* ❌ [Jison exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/jison/) – Jison doesn't output an AST, only a flat list.
* ❌ [Canopy explorations](https://github.com/adamziel/parser-generator-explorations/blob/trunk/canopy/) exploration – the final parser is large, slow, and seems to be outputting multiple alternative branches instead of doing a lookahead and choosing the right one.
* ❌ [Ohm exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/ohm-js/README.md#L11) – Ohn seems promising, but there's no clear way of generating a static parser and the grammar conversion is quite laborous. Ohm is focused on being easy to use but [performance isn't that great](https://news.ycombinator.com/item?id=38083683).
* ❌ [Pegen exploration](https://github.com/TheLartians/PEGParser) – Pegen failed to parse the MySQL grammar due to a recursion error.
* ❌ [C PEG exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/peg/) 
* ❌ [PHP PEG exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/php-peg/) – the parser doesn't produce AST and doesn't seem to correctly process the math expressions included as examples.
* ❌ [Python Lark exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/python-lark/) – it seems to have trouble with ambiguity of the MySQL grammar and it also generates a state table that makes manual parser modifications challenging.
* [Rust Peginator exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/rust-peginator/)
* ❌ [Node BNF parser exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/node-bnf-parser/) – it creates a WASM parser, which is interesting, but still it creates a node for each character, which is not what we want.
* ❌ [Javacc exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/javacc/) – it's a similar problem as with these stream-parsers where you must produce AST nodes manually.
* ❌ Racket and [Racketscript](https://github.com/racketscript/racketscript) – Racketscript parsers involve dependencies and are difficult to read. It smells like a large bundle size and a difficult JS -> PHP translation. Let's abandon this for now.
* ❌ https://github.com/TheLartians/PEGParser – it builds its parsers at run time
* ❌ https://github.com/chevrotain/chevrotain – it builds its parsers at run time
* ❌ https://tree-sitter.github.io/tree-sitter/ – Tree-sitter creates parsers that are written in C. We may be able to use it in Playground as WASM and maybe also convert the code to PHP.
   * It has a [general SQL parser](https://raw.githubusercontent.com/dhcmrlchtdj/tree-sitter-sqlite/main/src/parser.c)
   * It [produces an AST](https://tree-sitter.github.io/tree-sitter/playground).
   * The produced aprsers are huge (5.5MB for a general SQL, not even aware of MySQL nuances)
   * It's not dependency-free. It needs libtree-sitter.a.
* ❌ [PHP_ParserGenerator](https://github.com/pear/PHP_ParserGenerator/blob/master/examples/Parser.y) – Stream parser, won't give us AST and will require a ton of extra work to convert to AST.
* ❌ [Lime PHP parser generator](https://github.com/rvanvelzen/lime/tree/master) – Same as above, it's a stream parser generator that won't give us AST and will require a ton of extra work to convert to AST.
* ❌ [Lezer](https://lezer.codemirror.net/)
   * It was **super** promising! I really hoped it would work. Unfortunately, the parser generator is running for two hours now on the MySQL grammar file and there's no sign it will ever finish. Too bad!
   * Needs a library (The @lezer/lr package provides the run-time parsing system. Combined with a parser built by the generator, it gives you a parser object that can take a source file and return a tree.)
   * It generates a state table that seems difficult to translate to PHP:
     `!WQYQPOOOhQPO'#CdOOQO'#Ci'#CiOOQO'#Ce'#CeQYQPOOOOQO,59O,59OOyQPO,59OOOQO-E6c-E6cOOQO1G.j1G.j`
   * It is the most promising and easy to convert parser generator so far, though:
      * ✅ Fast
      * ✅ Small
      * ✅ Produces AST
      Let's see if we can convert MySQL grammar to Lezer format.

Maybe:

* [LALRPOP](https://lalrpop.github.io/lalrpop/) – it generates an AST, but requires a separate ast.rs file that explicitly declares possible AST nodes and maps all the grammar rules to them. We could generate a parser and then translate it to PHP with AI or another automated tool.

Next steps:

* Find a parser generator with great debugging tools.   
   * Maybe https://github.com/EoinDavey/tsPEG
      

