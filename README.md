## ENBF Attempt

This is an attempt at generating a MySQL parser in any language.

Explorations so far:

* [MySQL grammar in ANTLR g4 format](https://github.com/mysql/mysql-workbench/blob/8.0/library/parsers/grammars/MySQLParser.g4) (thanks to MySQL workbench)
* [MySQL grammar in EBNF notation](https://github.com/adamziel/parser-generator-explorations/blob/71194eb0b1ac78fe3905b42662f19cdeac4adf42/ebnf/MySQLParser.ebnf#L14) thanks to the [grammar-converter](https://github.com/vorpal-research/grammar-converter/tree/master) tool.
* [A PHP parser](https://github.com/WordPress/sqlite-database-integration/pull/153) generated by AI based on the grammar. It works to an extent, but needs a few weeks of work before it's perfect.
* [An AI-converted PEG.js grammar](https://github.com/adamziel/parser-generator-explorations/blob/71194eb0b1ac78fe3905b42662f19cdeac4adf42/pegjs/join-lexer-and-parser/). Unfortunately, [the PEG.js parser exploration failed](https://github.com/adamziel/parser-generator-explorations/blob/71194eb0b1ac78fe3905b42662f19cdeac4adf42/pegjs/join-lexer-and-parser/README.md#L2).
* ❌ [Jison exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/jison/) – Jison doesn't output an AST, only a flat list.
* ❌ [Canopy explorations](https://github.com/adamziel/parser-generator-explorations/blob/trunk/canopy/) exploration – the final parser is large, slow, and seems to be outputting multiple alternative branches instead of doing a lookahead and choosing the right one.
* ❌ [Ohm exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/ohm-js/README.md#L11) – Ohn seems promising, but there's no clear way of generating a static parser and the grammar conversion is quite laborous. Ohm is focused on being easy to use but [performance isn't that great](https://news.ycombinator.com/item?id=38083683).
* ❌ [Pegen exploration](https://github.com/TheLartians/PEGParser) – Pegen failed to parse the MySQL grammar due to a recursion error.
* ❌ [C PEG exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/peg/) 
* ❌ [PHP PEG exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/php-peg/) – the parser doesn't produce AST and doesn't seem to correctly process the math expressions included as examples.
* ❌ [Python Lark exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/python-lark/) – it seems to have trouble with ambiguity of the MySQL grammar and it also generates a state table that makes manual parser modifications challenging.
* [Rust Peginator exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/rust-peginator/)
* ❌ [Node BNF parser exploration](https://github.com/adamziel/parser-generator-explorations/blob/trunk/node-bnf-parser/) – it creates a WASM parser, which is interesting, but still it creates a node for each character, which is not what we want.
* ❌ Racket and [Racketscript](https://github.com/racketscript/racketscript) – Racketscript parsers involve dependencies and are difficult to read. It smells like a large bundle size and a difficult JS -> PHP translation. Let's abandon this for now.
* ❌ https://github.com/TheLartians/PEGParser – it builds its parsers at run time
* ❌ https://github.com/chevrotain/chevrotain – it builds its parsers at run time
* ❌ https://tree-sitter.github.io/tree-sitter/ – Tree-sitter creates parsers that are written in C. We may be able to use it in Playground as WASM and maybe also convert the code to PHP.
   * It has a [general SQL parser](https://raw.githubusercontent.com/dhcmrlchtdj/tree-sitter-sqlite/main/src/parser.c)
   * It [produces an AST](https://tree-sitter.github.io/tree-sitter/playground).
   * The produced aprsers are huge (5.5MB for a general SQL, not even aware of MySQL nuances)
   * It's not dependency-free. It needs libtree-sitter.a.

Maybe:

* [LALRPOP](https://lalrpop.github.io/lalrpop/) – it generates an AST, but requires a separate ast.rs file that explicitly declares possible AST nodes and maps all the grammar rules to them. We could generate a parser and then translate it to PHP with AI or another automated tool.

Next steps:

* Find a parser generator with great debugging tools.   
   

