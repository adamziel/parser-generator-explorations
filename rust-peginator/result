// This file was generated by Peginator v0.7.0 built at 1723540542
// CRC-32/ISO-HDLC of the grammar file: f11234ba
// Any changes to it will be lost on regeneration

# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "->") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "fn") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , "FunctionDef") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , "ParamList") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , "Param") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "self") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , "SelfParam") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , "Type") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , "ReferenceMarker") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , "ImmutableReference") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "mut") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , "MutableReference") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }
