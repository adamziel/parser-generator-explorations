// This file was generated by Peginator v0.7.0 built at 1723540542
// CRC-32/ISO-HDLC of the grammar file: 119d8d02
// Any changes to it will be lost on regeneration

# [derive (Debug , Clone ,)] pub struct query ; # [derive (Debug , Clone ,)] pub struct simpleStatement ; # [derive (Debug , Clone ,)] pub struct alterStatement ; # [derive (Debug , Clone ,)] pub struct alterDatabase ; # [derive (Debug , Clone ,)] pub struct alterEvent ; # [derive (Debug , Clone ,)] pub struct alterLogfileGroup ; # [derive (Debug , Clone ,)] pub struct alterLogfileGroupOptions ; # [derive (Debug , Clone ,)] pub struct alterLogfileGroupOption ; # [derive (Debug , Clone ,)] pub struct alterServer ; # [derive (Debug , Clone ,)] pub struct alterTable ; # [derive (Debug , Clone ,)] pub struct alterTableActions ; # [derive (Debug , Clone ,)] pub struct alterCommandList ; # [derive (Debug , Clone ,)] pub struct alterCommandsModifierList ; # [derive (Debug , Clone ,)] pub struct standaloneAlterCommands ; # [derive (Debug , Clone ,)] pub struct alterPartition ; # [derive (Debug , Clone ,)] pub struct alterList ; # [derive (Debug , Clone ,)] pub struct alterCommandsModifier ; # [derive (Debug , Clone ,)] pub struct alterListItem ; # [derive (Debug , Clone ,)] pub struct place ; # [derive (Debug , Clone ,)] pub struct restrict ; # [derive (Debug , Clone ,)] pub struct alterOrderList ; # [derive (Debug , Clone ,)] pub struct alterAlgorithmOption ; # [derive (Debug , Clone ,)] pub struct alterLockOption ; # [derive (Debug , Clone ,)] pub struct indexLockAndAlgorithm ; # [derive (Debug , Clone ,)] pub struct withValidation ; # [derive (Debug , Clone ,)] pub struct removePartitioning ; # [derive (Debug , Clone ,)] pub struct allOrPartitionNameList ; # [derive (Debug , Clone ,)] pub struct alterTablespace ; # [derive (Debug , Clone ,)] pub struct alterUndoTablespace ; # [derive (Debug , Clone ,)] pub struct undoTableSpaceOptions ; # [derive (Debug , Clone ,)] pub struct undoTableSpaceOption ; # [derive (Debug , Clone ,)] pub struct alterTablespaceOptions ; # [derive (Debug , Clone ,)] pub struct alterTablespaceOption ; # [derive (Debug , Clone ,)] pub struct changeTablespaceOption ; # [derive (Debug , Clone ,)] pub struct alterView ; # [derive (Debug , Clone ,)] pub struct viewTail ; # [derive (Debug , Clone ,)] pub struct viewSelect ; # [derive (Debug , Clone ,)] pub struct viewCheckOption ; # [derive (Debug , Clone ,)] pub struct createStatement ; # [derive (Debug , Clone ,)] pub struct createDatabase ; # [derive (Debug , Clone ,)] pub struct createDatabaseOption ; # [derive (Debug , Clone ,)] pub struct createTable ; # [derive (Debug , Clone ,)] pub struct tableElementList ; # [derive (Debug , Clone ,)] pub struct tableElement ; # [derive (Debug , Clone ,)] pub struct duplicateAsQueryExpression ; # [derive (Debug , Clone ,)] pub struct queryExpressionOrParens ; # [derive (Debug , Clone ,)] pub struct createRoutine ; # [derive (Debug , Clone ,)] pub struct createProcedure ; # [derive (Debug , Clone ,)] pub struct createFunction ; # [derive (Debug , Clone ,)] pub struct createUdf ; # [derive (Debug , Clone ,)] pub struct routineCreateOption ; # [derive (Debug , Clone ,)] pub struct routineAlterOptions ; # [derive (Debug , Clone ,)] pub struct routineOption ; # [derive (Debug , Clone ,)] pub struct createIndex ; # [derive (Debug , Clone ,)] pub struct indexNameAndType ; # [derive (Debug , Clone ,)] pub struct createIndexTarget ; # [derive (Debug , Clone ,)] pub struct createLogfileGroup ; # [derive (Debug , Clone ,)] pub struct logfileGroupOptions ; # [derive (Debug , Clone ,)] pub struct logfileGroupOption ; # [derive (Debug , Clone ,)] pub struct createServer ; # [derive (Debug , Clone ,)] pub struct serverOptions ; # [derive (Debug , Clone ,)] pub struct serverOption ; # [derive (Debug , Clone ,)] pub struct createTablespace ; # [derive (Debug , Clone ,)] pub struct createUndoTablespace ; # [derive (Debug , Clone ,)] pub struct tsDataFileName ; # [derive (Debug , Clone ,)] pub struct tsDataFile ; # [derive (Debug , Clone ,)] pub struct tablespaceOptions ; # [derive (Debug , Clone ,)] pub struct tablespaceOption ; # [derive (Debug , Clone ,)] pub struct tsOptionInitialSize ; # [derive (Debug , Clone ,)] pub struct tsOptionUndoRedoBufferSize ; # [derive (Debug , Clone ,)] pub struct tsOptionAutoextendSize ; # [derive (Debug , Clone ,)] pub struct tsOptionMaxSize ; # [derive (Debug , Clone ,)] pub struct tsOptionExtentSize ; # [derive (Debug , Clone ,)] pub struct tsOptionNodegroup ; # [derive (Debug , Clone ,)] pub struct tsOptionEngine ; # [derive (Debug , Clone ,)] pub struct tsOptionWait ; # [derive (Debug , Clone ,)] pub struct tsOptionComment ; # [derive (Debug , Clone ,)] pub struct tsOptionFileblockSize ; # [derive (Debug , Clone ,)] pub struct tsOptionEncryption ; # [derive (Debug , Clone ,)] pub struct createView ; # [derive (Debug , Clone ,)] pub struct viewReplaceOrAlgorithm ; # [derive (Debug , Clone ,)] pub struct viewAlgorithm ; # [derive (Debug , Clone ,)] pub struct viewSuid ; # [derive (Debug , Clone ,)] pub struct createTrigger ; # [derive (Debug , Clone ,)] pub struct triggerFollowsPrecedesClause ; # [derive (Debug , Clone ,)] pub struct createEvent ; # [derive (Debug , Clone ,)] pub struct createRole ; # [derive (Debug , Clone ,)] pub struct createSpatialReference ; # [derive (Debug , Clone ,)] pub struct srsAttribute ; # [derive (Debug , Clone ,)] pub struct dropStatement ; # [derive (Debug , Clone ,)] pub struct dropDatabase ; # [derive (Debug , Clone ,)] pub struct dropEvent ; # [derive (Debug , Clone ,)] pub struct dropFunction ; # [derive (Debug , Clone ,)] pub struct dropProcedure ; # [derive (Debug , Clone ,)] pub struct dropIndex ; # [derive (Debug , Clone ,)] pub struct dropLogfileGroup ; # [derive (Debug , Clone ,)] pub struct dropLogfileGroupOption ; # [derive (Debug , Clone ,)] pub struct dropServer ; # [derive (Debug , Clone ,)] pub struct dropTable ; # [derive (Debug , Clone ,)] pub struct dropTableSpace ; # [derive (Debug , Clone ,)] pub struct dropTrigger ; # [derive (Debug , Clone ,)] pub struct dropView ; # [derive (Debug , Clone ,)] pub struct dropRole ; # [derive (Debug , Clone ,)] pub struct dropSpatialReference ; # [derive (Debug , Clone ,)] pub struct dropUndoTablespace ; # [derive (Debug , Clone ,)] pub struct renameTableStatement ; # [derive (Debug , Clone ,)] pub struct renamePair ; # [derive (Debug , Clone ,)] pub struct truncateTableStatement ; # [derive (Debug , Clone ,)] pub struct importStatement ; # [derive (Debug , Clone ,)] pub struct callStatement ; # [derive (Debug , Clone ,)] pub struct deleteStatement ; # [derive (Debug , Clone ,)] pub struct partitionDelete ; # [derive (Debug , Clone ,)] pub struct deleteStatementOption ; # [derive (Debug , Clone ,)] pub struct doStatement ; # [derive (Debug , Clone ,)] pub struct handlerStatement ; # [derive (Debug , Clone ,)] pub struct handlerReadOrScan ; # [derive (Debug , Clone ,)] pub struct insertStatement ; # [derive (Debug , Clone ,)] pub struct insertLockOption ; # [derive (Debug , Clone ,)] pub struct insertFromConstructor ; # [derive (Debug , Clone ,)] pub struct fields ; # [derive (Debug , Clone ,)] pub struct insertValues ; # [derive (Debug , Clone ,)] pub struct insertQueryExpression ; # [derive (Debug , Clone ,)] pub struct valueList ; # [derive (Debug , Clone ,)] pub struct values ; # [derive (Debug , Clone ,)] pub struct valuesReference ; # [derive (Debug , Clone ,)] pub struct insertUpdateList ; # [derive (Debug , Clone ,)] pub struct loadStatement ; # [derive (Debug , Clone ,)] pub struct dataOrXml ; # [derive (Debug , Clone ,)] pub struct xmlRowsIdentifiedBy ; # [derive (Debug , Clone ,)] pub struct loadDataFileTail ; # [derive (Debug , Clone ,)] pub struct loadDataFileTargetList ; # [derive (Debug , Clone ,)] pub struct fieldOrVariableList ; # [derive (Debug , Clone ,)] pub struct replaceStatement ; # [derive (Debug , Clone ,)] pub struct selectStatement ; # [derive (Debug , Clone ,)] pub struct selectStatementWithInto ; # [derive (Debug , Clone ,)] pub struct queryExpression ; # [derive (Debug , Clone ,)] pub struct queryExpressionBody ; # [derive (Debug , Clone ,)] pub struct queryExpressionParens ; # [derive (Debug , Clone ,)] pub struct queryPrimary ; # [derive (Debug , Clone ,)] pub struct querySpecification { pub opts : Vec < selectOption > , pub selectItemList : selectItemList , pub into : Option < intoClause > , } # [derive (Debug , Clone ,)] pub struct subquery ; # [derive (Debug , Clone ,)] pub struct querySpecOption ; # [derive (Debug , Clone ,)] pub struct limitClause ; # [derive (Debug , Clone ,)] pub struct simpleLimitClause ; # [derive (Debug , Clone ,)] pub struct limitOptions ; # [derive (Debug , Clone ,)] pub struct limitOption ; # [derive (Debug , Clone ,)] pub struct intoClause ; # [derive (Debug , Clone ,)] pub struct procedureAnalyseClause ; # [derive (Debug , Clone ,)] pub struct havingClause ; # [derive (Debug , Clone ,)] pub struct windowClause ; # [derive (Debug , Clone ,)] pub struct windowDefinition ; # [derive (Debug , Clone ,)] pub struct windowSpec ; # [derive (Debug , Clone ,)] pub struct windowSpecDetails ; # [derive (Debug , Clone ,)] pub struct windowFrameClause ; # [derive (Debug , Clone ,)] pub struct windowFrameUnits ; # [derive (Debug , Clone ,)] pub struct windowFrameExtent ; # [derive (Debug , Clone ,)] pub struct windowFrameStart ; # [derive (Debug , Clone ,)] pub struct windowFrameBetween ; # [derive (Debug , Clone ,)] pub struct windowFrameBound ; # [derive (Debug , Clone ,)] pub struct windowFrameExclusion ; # [derive (Debug , Clone ,)] pub struct withClause ; # [derive (Debug , Clone ,)] pub struct commonTableExpression ; # [derive (Debug , Clone ,)] pub struct groupByClause ; # [derive (Debug , Clone ,)] pub struct olapOption ; # [derive (Debug , Clone ,)] pub struct orderClause ; # [derive (Debug , Clone ,)] pub struct direction ; # [derive (Debug , Clone ,)] pub struct fromClause ; # [derive (Debug , Clone ,)] pub struct tableReferenceList ; # [derive (Debug , Clone ,)] pub struct tableValueConstructor ; # [derive (Debug , Clone ,)] pub struct explicitTable ; # [derive (Debug , Clone ,)] pub struct rowValueExplicit ; # [derive (Debug , Clone ,)] pub struct selectOption ; # [derive (Debug , Clone ,)] pub struct lockingClauseList ; # [derive (Debug , Clone ,)] pub struct lockingClause ; # [derive (Debug , Clone ,)] pub struct lockStrengh ; # [derive (Debug , Clone ,)] pub struct lockedRowAction ; # [derive (Debug , Clone ,)] pub struct selectItemList ; # [derive (Debug , Clone ,)] pub struct selectItem ; # [derive (Debug , Clone ,)] pub struct selectAlias ; # [derive (Debug , Clone ,)] pub struct whereClause ; # [derive (Debug , Clone ,)] pub struct tableReference ; # [derive (Debug , Clone ,)] pub struct escapedTableReference ; # [derive (Debug , Clone ,)] pub struct joinedTable ; # [derive (Debug , Clone ,)] pub struct naturalJoinType ; # [derive (Debug , Clone ,)] pub struct innerJoinType ; # [derive (Debug , Clone ,)] pub struct outerJoinType ; # [derive (Debug , Clone ,)] pub struct tableFactor ; # [derive (Debug , Clone ,)] pub struct singleTable ; # [derive (Debug , Clone ,)] pub struct singleTableParens ; # [derive (Debug , Clone ,)] pub struct derivedTable ; # [derive (Debug , Clone ,)] pub struct tableReferenceListParens ; # [derive (Debug , Clone ,)] pub struct tableFunction ; # [derive (Debug , Clone ,)] pub struct columnsClause ; # [derive (Debug , Clone ,)] pub struct jtColumn ; # [derive (Debug , Clone ,)] pub struct onEmptyOrError ; # [derive (Debug , Clone ,)] pub struct onEmpty ; # [derive (Debug , Clone ,)] pub struct onError ; # [derive (Debug , Clone ,)] pub struct jtOnResponse ; # [derive (Debug , Clone ,)] pub struct unionOption ; # [derive (Debug , Clone ,)] pub struct tableAlias ; # [derive (Debug , Clone ,)] pub struct indexHintList ; # [derive (Debug , Clone ,)] pub struct indexHint ; # [derive (Debug , Clone ,)] pub struct indexHintType ; # [derive (Debug , Clone ,)] pub struct keyOrIndex ; # [derive (Debug , Clone ,)] pub struct constraintKeyType ; # [derive (Debug , Clone ,)] pub struct indexHintClause ; # [derive (Debug , Clone ,)] pub struct indexList ; # [derive (Debug , Clone ,)] pub struct indexListElement ; # [derive (Debug , Clone ,)] pub struct updateStatement ; # [derive (Debug , Clone ,)] pub struct transactionOrLockingStatement ; # [derive (Debug , Clone ,)] pub struct transactionStatement ; # [derive (Debug , Clone ,)] pub struct beginWork ; # [derive (Debug , Clone ,)] pub struct transactionCharacteristic ; # [derive (Debug , Clone ,)] pub struct savepointStatement ; # [derive (Debug , Clone ,)] pub struct lockStatement ; # [derive (Debug , Clone ,)] pub struct lockItem ; # [derive (Debug , Clone ,)] pub struct lockOption ; # [derive (Debug , Clone ,)] pub struct xaStatement ; # [derive (Debug , Clone ,)] pub struct xaConvert ; # [derive (Debug , Clone ,)] pub struct xid ; # [derive (Debug , Clone ,)] pub struct replicationStatement ; # [derive (Debug , Clone ,)] pub struct resetOption ; # [derive (Debug , Clone ,)] pub struct masterResetOptions ; # [derive (Debug , Clone ,)] pub struct replicationLoad ; # [derive (Debug , Clone ,)] pub struct changeMaster ; # [derive (Debug , Clone ,)] pub struct changeMasterOptions ; # [derive (Debug , Clone ,)] pub struct masterOption ; # [derive (Debug , Clone ,)] pub struct privilegeCheckDef ; # [derive (Debug , Clone ,)] pub struct tablePrimaryKeyCheckDef ; # [derive (Debug , Clone ,)] pub struct masterTlsCiphersuitesDef ; # [derive (Debug , Clone ,)] pub struct masterFileDef ; # [derive (Debug , Clone ,)] pub struct serverIdList ; # [derive (Debug , Clone ,)] pub struct changeReplication ; # [derive (Debug , Clone ,)] pub struct filterDefinition ; # [derive (Debug , Clone ,)] pub struct filterDbList ; # [derive (Debug , Clone ,)] pub struct filterTableList ; # [derive (Debug , Clone ,)] pub struct filterStringList ; # [derive (Debug , Clone ,)] pub struct filterWildDbTableString ; # [derive (Debug , Clone ,)] pub struct filterDbPairList ; # [derive (Debug , Clone ,)] pub struct slave ; # [derive (Debug , Clone ,)] pub struct slaveUntilOptions ; # [derive (Debug , Clone ,)] pub struct slaveConnectionOptions ; # [derive (Debug , Clone ,)] pub struct slaveThreadOptions ; # [derive (Debug , Clone ,)] pub struct slaveThreadOption ; # [derive (Debug , Clone ,)] pub struct groupReplication ; # [derive (Debug , Clone ,)] pub struct preparedStatement ; # [derive (Debug , Clone ,)] pub struct executeStatement ; # [derive (Debug , Clone ,)] pub struct executeVarList ; # [derive (Debug , Clone ,)] pub struct cloneStatement ; # [derive (Debug , Clone ,)] pub struct dataDirSSL ; # [derive (Debug , Clone ,)] pub struct ssl ; # [derive (Debug , Clone ,)] pub struct accountManagementStatement ; # [derive (Debug , Clone ,)] pub struct alterUser ; # [derive (Debug , Clone ,)] pub struct alterUserTail ; # [derive (Debug , Clone ,)] pub struct userFunction ; # [derive (Debug , Clone ,)] pub struct createUser ; # [derive (Debug , Clone ,)] pub struct createUserTail ; # [derive (Debug , Clone ,)] pub struct defaultRoleClause ; # [derive (Debug , Clone ,)] pub struct requireClause ; # [derive (Debug , Clone ,)] pub struct connectOptions ; # [derive (Debug , Clone ,)] pub struct accountLockPasswordExpireOptions ; # [derive (Debug , Clone ,)] pub struct dropUser ; # [derive (Debug , Clone ,)] pub struct grant ; # [derive (Debug , Clone ,)] pub struct grantTargetList ; # [derive (Debug , Clone ,)] pub struct grantOptions ; # [derive (Debug , Clone ,)] pub struct exceptRoleList ; # [derive (Debug , Clone ,)] pub struct withRoles ; # [derive (Debug , Clone ,)] pub struct grantAs ; # [derive (Debug , Clone ,)] pub struct versionedRequireClause ; # [derive (Debug , Clone ,)] pub struct renameUser ; # [derive (Debug , Clone ,)] pub struct revoke ; # [derive (Debug , Clone ,)] pub struct onTypeTo ; # [derive (Debug , Clone ,)] pub struct aclType ; # [derive (Debug , Clone ,)] pub struct roleOrPrivilegesList ; # [derive (Debug , Clone ,)] pub struct roleOrPrivilege ; # [derive (Debug , Clone ,)] pub struct grantIdentifier ; # [derive (Debug , Clone ,)] pub struct requireList ; # [derive (Debug , Clone ,)] pub struct requireListElement ; # [derive (Debug , Clone ,)] pub struct grantOption ; # [derive (Debug , Clone ,)] pub struct setRole ; # [derive (Debug , Clone ,)] pub struct roleList ; # [derive (Debug , Clone ,)] pub struct role ; # [derive (Debug , Clone ,)] pub struct tableAdministrationStatement ; # [derive (Debug , Clone ,)] pub struct histogram ; # [derive (Debug , Clone ,)] pub struct checkOption ; # [derive (Debug , Clone ,)] pub struct repairType ; # [derive (Debug , Clone ,)] pub struct installUninstallStatment ; # [derive (Debug , Clone ,)] pub struct setStatement ; # [derive (Debug , Clone ,)] pub struct startOptionValueList ; # [derive (Debug , Clone ,)] pub struct transactionCharacteristics ; # [derive (Debug , Clone ,)] pub struct transactionAccessMode ; # [derive (Debug , Clone ,)] pub struct isolationLevel ; # [derive (Debug , Clone ,)] pub struct optionValueListContinued ; # [derive (Debug , Clone ,)] pub struct optionValueNoOptionType ; # [derive (Debug , Clone ,)] pub struct optionValue ; # [derive (Debug , Clone ,)] pub struct setSystemVariable ; # [derive (Debug , Clone ,)] pub struct startOptionValueListFollowingOptionType ; # [derive (Debug , Clone ,)] pub struct optionValueFollowingOptionType ; # [derive (Debug , Clone ,)] pub struct setExprOrDefault ; # [derive (Debug , Clone ,)] pub struct showStatement ; # [derive (Debug , Clone ,)] pub struct showCommandType ; # [derive (Debug , Clone ,)] pub struct nonBlocking ; # [derive (Debug , Clone ,)] pub struct fromOrIn ; # [derive (Debug , Clone ,)] pub struct inDb ; # [derive (Debug , Clone ,)] pub struct profileType ; # [derive (Debug , Clone ,)] pub struct otherAdministrativeStatement ; # [derive (Debug , Clone ,)] pub struct keyCacheListOrParts ; # [derive (Debug , Clone ,)] pub struct keyCacheList ; # [derive (Debug , Clone ,)] pub struct assignToKeycache ; # [derive (Debug , Clone ,)] pub struct assignToKeycachePartition ; # [derive (Debug , Clone ,)] pub struct cacheKeyList ; # [derive (Debug , Clone ,)] pub struct keyUsageElement ; # [derive (Debug , Clone ,)] pub struct keyUsageList ; # [derive (Debug , Clone ,)] pub struct flushOption ; # [derive (Debug , Clone ,)] pub struct logType ; # [derive (Debug , Clone ,)] pub struct flushTables ; # [derive (Debug , Clone ,)] pub struct flushTablesOptions ; # [derive (Debug , Clone ,)] pub struct preloadTail ; # [derive (Debug , Clone ,)] pub struct preloadList ; # [derive (Debug , Clone ,)] pub struct preloadKeys ; # [derive (Debug , Clone ,)] pub struct adminPartition ; # [derive (Debug , Clone ,)] pub struct resourceGroupManagement ; # [derive (Debug , Clone ,)] pub struct createResourceGroup ; # [derive (Debug , Clone ,)] pub struct resourceGroupVcpuList ; # [derive (Debug , Clone ,)] pub struct vcpuNumOrRange ; # [derive (Debug , Clone ,)] pub struct resourceGroupPriority ; # [derive (Debug , Clone ,)] pub struct resourceGroupEnableDisable ; # [derive (Debug , Clone ,)] pub struct alterResourceGroup ; # [derive (Debug , Clone ,)] pub struct setResourceGroup ; # [derive (Debug , Clone ,)] pub struct threadIdList ; # [derive (Debug , Clone ,)] pub struct dropResourceGroup ; # [derive (Debug , Clone ,)] pub struct utilityStatement ; # [derive (Debug , Clone ,)] pub struct describeStatement ; # [derive (Debug , Clone ,)] pub struct explainStatement ; # [derive (Debug , Clone ,)] pub struct explainableStatement ; # [derive (Debug , Clone ,)] pub struct helpCommand ; # [derive (Debug , Clone ,)] pub struct useCommand ; # [derive (Debug , Clone ,)] pub struct restartServer ; # [derive (Debug , Clone ,)] pub struct expr ; # [derive (Debug , Clone ,)] pub struct boolPri ; # [derive (Debug , Clone ,)] pub struct compOp ; # [derive (Debug , Clone ,)] pub struct predicate ; # [derive (Debug , Clone ,)] pub struct predicateOperations ; # [derive (Debug , Clone ,)] pub struct bitExpr ; # [derive (Debug , Clone ,)] pub struct simpleExpr ; # [derive (Debug , Clone ,)] pub struct arrayCast ; # [derive (Debug , Clone ,)] pub struct jsonOperator ; # [derive (Debug , Clone ,)] pub struct sumExpr ; # [derive (Debug , Clone ,)] pub struct groupingOperation ; # [derive (Debug , Clone ,)] pub struct windowFunctionCall ; # [derive (Debug , Clone ,)] pub struct windowingClause ; # [derive (Debug , Clone ,)] pub struct leadLagInfo ; # [derive (Debug , Clone ,)] pub struct nullTreatment ; # [derive (Debug , Clone ,)] pub struct jsonFunction ; # [derive (Debug , Clone ,)] pub struct inSumExpr ; # [derive (Debug , Clone ,)] pub struct identListArg ; # [derive (Debug , Clone ,)] pub struct identList ; # [derive (Debug , Clone ,)] pub struct fulltextOptions ; # [derive (Debug , Clone ,)] pub struct runtimeFunctionCall ; # [derive (Debug , Clone ,)] pub struct geometryFunction ; # [derive (Debug , Clone ,)] pub struct timeFunctionParameters ; # [derive (Debug , Clone ,)] pub struct fractionalPrecision ; # [derive (Debug , Clone ,)] pub struct weightStringLevels ; # [derive (Debug , Clone ,)] pub struct weightStringLevelListItem ; # [derive (Debug , Clone ,)] pub struct dateTimeTtype ; # [derive (Debug , Clone ,)] pub struct trimFunction ; # [derive (Debug , Clone ,)] pub struct substringFunction ; # [derive (Debug , Clone ,)] pub struct functionCall ; # [derive (Debug , Clone ,)] pub struct udfExprList ; # [derive (Debug , Clone ,)] pub struct udfExpr ; # [derive (Debug , Clone ,)] pub struct variable ; # [derive (Debug , Clone ,)] pub struct userVariable ; # [derive (Debug , Clone ,)] pub struct systemVariable ; # [derive (Debug , Clone ,)] pub struct internalVariableName ; # [derive (Debug , Clone ,)] pub struct whenExpression ; # [derive (Debug , Clone ,)] pub struct thenExpression ; # [derive (Debug , Clone ,)] pub struct elseExpression ; # [derive (Debug , Clone ,)] pub struct castType ; # [derive (Debug , Clone ,)] pub struct exprList ; # [derive (Debug , Clone ,)] pub struct charset ; # [derive (Debug , Clone ,)] pub struct notRule ; # [derive (Debug , Clone ,)] pub struct not2Rule ; # [derive (Debug , Clone ,)] pub struct interval ; # [derive (Debug , Clone ,)] pub struct intervalTimeStamp ; # [derive (Debug , Clone ,)] pub struct exprListWithParentheses ; # [derive (Debug , Clone ,)] pub struct exprWithParentheses ; # [derive (Debug , Clone ,)] pub struct simpleExprWithParentheses ; # [derive (Debug , Clone ,)] pub struct orderList ; # [derive (Debug , Clone ,)] pub struct orderExpression ; # [derive (Debug , Clone ,)] pub struct groupList ; # [derive (Debug , Clone ,)] pub struct groupingExpression ; # [derive (Debug , Clone ,)] pub struct channel ; # [derive (Debug , Clone ,)] pub struct compoundStatement ; # [derive (Debug , Clone ,)] pub struct returnStatement ; # [derive (Debug , Clone ,)] pub struct ifStatement ; # [derive (Debug , Clone ,)] pub struct ifBody ; # [derive (Debug , Clone ,)] pub struct thenStatement ; # [derive (Debug , Clone ,)] pub struct compoundStatementList ; # [derive (Debug , Clone ,)] pub struct caseStatement ; # [derive (Debug , Clone ,)] pub struct elseStatement ; # [derive (Debug , Clone ,)] pub struct labeledBlock ; # [derive (Debug , Clone ,)] pub struct unlabeledBlock ; # [derive (Debug , Clone ,)] pub struct label ; # [derive (Debug , Clone ,)] pub struct beginEndBlock ; # [derive (Debug , Clone ,)] pub struct labeledControl ; # [derive (Debug , Clone ,)] pub struct unlabeledControl ; # [derive (Debug , Clone ,)] pub struct loopBlock ; # [derive (Debug , Clone ,)] pub struct whileDoBlock ; # [derive (Debug , Clone ,)] pub struct repeatUntilBlock ; # [derive (Debug , Clone ,)] pub struct spDeclarations ; # [derive (Debug , Clone ,)] pub struct spDeclaration ; # [derive (Debug , Clone ,)] pub struct variableDeclaration ; # [derive (Debug , Clone ,)] pub struct conditionDeclaration ; # [derive (Debug , Clone ,)] pub struct spCondition ; # [derive (Debug , Clone ,)] pub struct sqlstate ; # [derive (Debug , Clone ,)] pub struct handlerDeclaration ; # [derive (Debug , Clone ,)] pub struct handlerCondition ; # [derive (Debug , Clone ,)] pub struct cursorDeclaration ; # [derive (Debug , Clone ,)] pub struct iterateStatement ; # [derive (Debug , Clone ,)] pub struct leaveStatement ; # [derive (Debug , Clone ,)] pub struct getDiagnostics ; # [derive (Debug , Clone ,)] pub struct signalAllowedExpr ; # [derive (Debug , Clone ,)] pub struct statementInformationItem ; # [derive (Debug , Clone ,)] pub struct conditionInformationItem ; # [derive (Debug , Clone ,)] pub struct signalInformationItemName ; # [derive (Debug , Clone ,)] pub struct signalStatement ; # [derive (Debug , Clone ,)] pub struct resignalStatement ; # [derive (Debug , Clone ,)] pub struct signalInformationItem ; # [derive (Debug , Clone ,)] pub struct cursorOpen ; # [derive (Debug , Clone ,)] pub struct cursorClose ; # [derive (Debug , Clone ,)] pub struct cursorFetch ; # [derive (Debug , Clone ,)] pub struct schedule ; # [derive (Debug , Clone ,)] pub struct columnDefinition ; # [derive (Debug , Clone ,)] pub struct checkOrReferences ; # [derive (Debug , Clone ,)] pub struct checkConstraint ; # [derive (Debug , Clone ,)] pub struct constraintEnforcement ; # [derive (Debug , Clone ,)] pub struct tableConstraintDef ; # [derive (Debug , Clone ,)] pub struct constraintName ; # [derive (Debug , Clone ,)] pub struct fieldDefinition ; # [derive (Debug , Clone ,)] pub struct columnAttribute ; # [derive (Debug , Clone ,)] pub struct columnFormat ; # [derive (Debug , Clone ,)] pub struct storageMedia ; # [derive (Debug , Clone ,)] pub struct gcolAttribute ; # [derive (Debug , Clone ,)] pub struct references ; # [derive (Debug , Clone ,)] pub struct deleteOption ; # [derive (Debug , Clone ,)] pub struct keyList ; # [derive (Debug , Clone ,)] pub struct keyPart ; # [derive (Debug , Clone ,)] pub struct keyListWithExpression ; # [derive (Debug , Clone ,)] pub struct keyPartOrExpression ; # [derive (Debug , Clone ,)] pub struct keyListVariants ; # [derive (Debug , Clone ,)] pub struct indexType ; # [derive (Debug , Clone ,)] pub struct indexOption ; # [derive (Debug , Clone ,)] pub struct commonIndexOption ; # [derive (Debug , Clone ,)] pub struct visibility ; # [derive (Debug , Clone ,)] pub struct indexTypeClause ; # [derive (Debug , Clone ,)] pub struct fulltextIndexOption ; # [derive (Debug , Clone ,)] pub struct spatialIndexOption ; # [derive (Debug , Clone ,)] pub struct dataTypeDefinition ; # [derive (Debug , Clone ,)] pub struct dataType ; # [derive (Debug , Clone ,)] pub struct nchar ; # [derive (Debug , Clone ,)] pub struct realType ; # [derive (Debug , Clone ,)] pub struct fieldLength ; # [derive (Debug , Clone ,)] pub struct fieldOptions ; # [derive (Debug , Clone ,)] pub struct charsetWithOptBinary ; # [derive (Debug , Clone ,)] pub struct ascii ; # [derive (Debug , Clone ,)] pub struct unicode ; # [derive (Debug , Clone ,)] pub struct wsNumCodepoints ; # [derive (Debug , Clone ,)] pub struct typeDatetimePrecision ; # [derive (Debug , Clone ,)] pub struct charsetName ; # [derive (Debug , Clone ,)] pub struct collationName ; # [derive (Debug , Clone ,)] pub struct createTableOptions ; # [derive (Debug , Clone ,)] pub struct createTableOptionsSpaceSeparated ; # [derive (Debug , Clone ,)] pub struct createTableOption ; # [derive (Debug , Clone ,)] pub struct ternaryOption ; # [derive (Debug , Clone ,)] pub struct defaultCollation ; # [derive (Debug , Clone ,)] pub struct defaultEncryption ; # [derive (Debug , Clone ,)] pub struct defaultCharset ; # [derive (Debug , Clone ,)] pub struct partitionClause ; # [derive (Debug , Clone ,)] pub struct partitionTypeDef ; # [derive (Debug , Clone ,)] pub struct subPartitions ; # [derive (Debug , Clone ,)] pub struct partitionKeyAlgorithm ; # [derive (Debug , Clone ,)] pub struct partitionDefinitions ; # [derive (Debug , Clone ,)] pub struct partitionDefinition ; # [derive (Debug , Clone ,)] pub struct partitionValuesIn ; # [derive (Debug , Clone ,)] pub struct partitionOption ; # [derive (Debug , Clone ,)] pub struct subpartitionDefinition ; # [derive (Debug , Clone ,)] pub struct partitionValueItemListParen ; # [derive (Debug , Clone ,)] pub struct partitionValueItem ; # [derive (Debug , Clone ,)] pub struct definerClause ; # [derive (Debug , Clone ,)] pub struct ifExists ; # [derive (Debug , Clone ,)] pub struct ifNotExists ; # [derive (Debug , Clone ,)] pub struct procedureParameter ; # [derive (Debug , Clone ,)] pub struct functionParameter ; # [derive (Debug , Clone ,)] pub struct collate ; # [derive (Debug , Clone ,)] pub struct typeWithOptCollate ; # [derive (Debug , Clone ,)] pub struct schemaIdentifierPair ; # [derive (Debug , Clone ,)] pub struct viewRefList ; # [derive (Debug , Clone ,)] pub struct updateList ; # [derive (Debug , Clone ,)] pub struct updateElement ; # [derive (Debug , Clone ,)] pub struct charsetClause ; # [derive (Debug , Clone ,)] pub struct fieldsClause ; # [derive (Debug , Clone ,)] pub struct fieldTerm ; # [derive (Debug , Clone ,)] pub struct linesClause ; # [derive (Debug , Clone ,)] pub struct lineTerm ; # [derive (Debug , Clone ,)] pub struct userList ; # [derive (Debug , Clone ,)] pub struct createUserList ; # [derive (Debug , Clone ,)] pub struct alterUserList ; # [derive (Debug , Clone ,)] pub struct createUserEntry ; # [derive (Debug , Clone ,)] pub struct alterUserEntry ; # [derive (Debug , Clone ,)] pub struct retainCurrentPassword ; # [derive (Debug , Clone ,)] pub struct discardOldPassword ; # [derive (Debug , Clone ,)] pub struct replacePassword ; # [derive (Debug , Clone ,)] pub struct userIdentifierOrText ; # [derive (Debug , Clone ,)] pub struct user ; # [derive (Debug , Clone ,)] pub struct likeClause ; # [derive (Debug , Clone ,)] pub struct likeOrWhere ; # [derive (Debug , Clone ,)] pub struct onlineOption ; # [derive (Debug , Clone ,)] pub struct noWriteToBinLog ; # [derive (Debug , Clone ,)] pub struct usePartition ; # [derive (Debug , Clone ,)] pub struct fieldIdentifier ; # [derive (Debug , Clone ,)] pub struct columnName ; # [derive (Debug , Clone ,)] pub struct columnInternalRef ; # [derive (Debug , Clone ,)] pub struct columnInternalRefList ; # [derive (Debug , Clone ,)] pub struct columnRef ; # [derive (Debug , Clone ,)] pub struct insertIdentifier ; # [derive (Debug , Clone ,)] pub struct indexName ; # [derive (Debug , Clone ,)] pub struct indexRef ; # [derive (Debug , Clone ,)] pub struct tableWild ; # [derive (Debug , Clone ,)] pub struct schemaName ; # [derive (Debug , Clone ,)] pub struct schemaRef ; # [derive (Debug , Clone ,)] pub struct procedureName ; # [derive (Debug , Clone ,)] pub struct procedureRef ; # [derive (Debug , Clone ,)] pub struct functionName ; # [derive (Debug , Clone ,)] pub struct functionRef ; # [derive (Debug , Clone ,)] pub struct triggerName ; # [derive (Debug , Clone ,)] pub struct triggerRef ; # [derive (Debug , Clone ,)] pub struct viewName ; # [derive (Debug , Clone ,)] pub struct viewRef ; # [derive (Debug , Clone ,)] pub struct tablespaceName ; # [derive (Debug , Clone ,)] pub struct tablespaceRef ; # [derive (Debug , Clone ,)] pub struct logfileGroupName ; # [derive (Debug , Clone ,)] pub struct logfileGroupRef ; # [derive (Debug , Clone ,)] pub struct eventName ; # [derive (Debug , Clone ,)] pub struct eventRef ; # [derive (Debug , Clone ,)] pub struct udfName ; # [derive (Debug , Clone ,)] pub struct serverName ; # [derive (Debug , Clone ,)] pub struct serverRef ; # [derive (Debug , Clone ,)] pub struct engineRef ; # [derive (Debug , Clone ,)] pub struct tableName ; # [derive (Debug , Clone ,)] pub struct filterTableRef ; # [derive (Debug , Clone ,)] pub struct tableRefWithWildcard ; # [derive (Debug , Clone ,)] pub struct tableRef ; # [derive (Debug , Clone ,)] pub struct tableRefList ; # [derive (Debug , Clone ,)] pub struct tableAliasRefList ; # [derive (Debug , Clone ,)] pub struct parameterName ; # [derive (Debug , Clone ,)] pub struct labelIdentifier ; # [derive (Debug , Clone ,)] pub struct labelRef ; # [derive (Debug , Clone ,)] pub struct roleIdentifier ; # [derive (Debug , Clone ,)] pub struct roleRef ; # [derive (Debug , Clone ,)] pub struct pluginRef ; # [derive (Debug , Clone ,)] pub struct componentRef ; # [derive (Debug , Clone ,)] pub struct resourceGroupRef ; # [derive (Debug , Clone ,)] pub struct windowName ; # [derive (Debug , Clone ,)] pub struct pureIdentifier ; # [derive (Debug , Clone ,)] pub struct identifier ; # [derive (Debug , Clone ,)] pub struct identifierList ; # [derive (Debug , Clone ,)] pub struct identifierListWithParentheses ; # [derive (Debug , Clone ,)] pub struct qualifiedIdentifier ; # [derive (Debug , Clone ,)] pub struct simpleIdentifier ; # [derive (Debug , Clone ,)] pub struct dotIdentifier ; # [derive (Debug , Clone ,)] pub struct ulong_number ; # [derive (Debug , Clone ,)] pub struct real_ulong_number ; # [derive (Debug , Clone ,)] pub struct ulonglong_number ; # [derive (Debug , Clone ,)] pub struct real_ulonglong_number ; # [derive (Debug , Clone ,)] pub struct literal ; # [derive (Debug , Clone ,)] pub struct signedLiteral ; # [derive (Debug , Clone ,)] pub struct stringList ; # [derive (Debug , Clone ,)] pub struct textStringLiteral ; # [derive (Debug , Clone ,)] pub struct textString ; # [derive (Debug , Clone ,)] pub struct textStringHash ; # [derive (Debug , Clone ,)] pub struct textLiteral ; # [derive (Debug , Clone ,)] pub struct textStringNoLinebreak ; # [derive (Debug , Clone ,)] pub struct textStringLiteralList ; # [derive (Debug , Clone ,)] pub struct numLiteral ; # [derive (Debug , Clone ,)] pub struct boolLiteral ; # [derive (Debug , Clone ,)] pub struct nullLiteral ; # [derive (Debug , Clone ,)] pub struct temporalLiteral ; # [derive (Debug , Clone ,)] pub struct floatOptions ; # [derive (Debug , Clone ,)] pub struct standardFloatOptions ; # [derive (Debug , Clone ,)] pub struct precision ; # [derive (Debug , Clone ,)] pub struct textOrIdentifier ; # [derive (Debug , Clone ,)] pub struct lValueIdentifier ; # [derive (Debug , Clone ,)] pub struct roleIdentifierOrText ; # [derive (Debug , Clone ,)] pub struct sizeNumber ; # [derive (Debug , Clone ,)] pub struct parentheses ; # [derive (Debug , Clone ,)] pub struct equal ; # [derive (Debug , Clone ,)] pub struct optionType ; # [derive (Debug , Clone ,)] pub struct varIdentType ; # [derive (Debug , Clone ,)] pub struct setVarIdentType ; # [derive (Debug , Clone ,)] pub struct identifierKeyword ; # [derive (Debug , Clone ,)] pub struct identifierKeywordsAmbiguous1RolesAndLabels ; # [derive (Debug , Clone ,)] pub struct identifierKeywordsAmbiguous2Labels ; # [derive (Debug , Clone ,)] pub struct labelKeyword ; # [derive (Debug , Clone ,)] pub struct identifierKeywordsAmbiguous3Roles ; # [derive (Debug , Clone ,)] pub struct identifierKeywordsUnambiguous ; # [derive (Debug , Clone ,)] pub struct roleKeyword ; # [derive (Debug , Clone ,)] pub struct lValueKeyword ; # [derive (Debug , Clone ,)] pub struct identifierKeywordsAmbiguous4SystemVariables ; # [derive (Debug , Clone ,)] pub struct roleOrIdentifierKeyword ; # [derive (Debug , Clone ,)] pub struct roleOrLabelKeyword ; # [derive (Debug , Clone ,)] pub struct EQUAL_OPERATOR ; # [derive (Debug , Clone ,)] pub struct ASSIGN_OPERATOR ; # [derive (Debug , Clone ,)] pub struct NULL_SAFE_EQUAL_OPERATOR ; # [derive (Debug , Clone ,)] pub struct GREATER_OR_EQUAL_OPERATOR ; # [derive (Debug , Clone ,)] pub struct GREATER_THAN_OPERATOR ; # [derive (Debug , Clone ,)] pub struct LESS_OR_EQUAL_OPERATOR ; # [derive (Debug , Clone ,)] pub struct LESS_THAN_OPERATOR ; # [derive (Debug , Clone ,)] pub struct NOT_EQUAL_OPERATOR ; # [derive (Debug , Clone ,)] pub struct NOT_EQUAL2_OPERATOR ; # [derive (Debug , Clone ,)] pub struct PLUS_OPERATOR ; # [derive (Debug , Clone ,)] pub struct MINUS_OPERATOR ; # [derive (Debug , Clone ,)] pub struct MULT_OPERATOR ; # [derive (Debug , Clone ,)] pub struct DIV_OPERATOR ; # [derive (Debug , Clone ,)] pub struct MOD_OPERATOR ; # [derive (Debug , Clone ,)] pub struct LOGICAL_NOT_OPERATOR ; # [derive (Debug , Clone ,)] pub struct BITWISE_NOT_OPERATOR ; # [derive (Debug , Clone ,)] pub struct SHIFT_LEFT_OPERATOR ; # [derive (Debug , Clone ,)] pub struct SHIFT_RIGHT_OPERATOR ; # [derive (Debug , Clone ,)] pub struct LOGICAL_AND_OPERATOR ; # [derive (Debug , Clone ,)] pub struct BITWISE_AND_OPERATOR ; # [derive (Debug , Clone ,)] pub struct BITWISE_XOR_OPERATOR ; # [derive (Debug , Clone ,)] pub struct LOGICAL_OR_OPERATOR ; # [derive (Debug , Clone ,)] pub struct BITWISE_OR_OPERATOR ; # [derive (Debug , Clone ,)] pub struct DOT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COMMA_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SEMICOLON_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COLON_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OPEN_PAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CLOSE_PAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OPEN_CURLY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CLOSE_CURLY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNDERLINE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct JSON_SEPARATOR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct JSON_UNQUOTED_SEPARATOR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AT_SIGN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AT_TEXT_SUFFIX ; # [derive (Debug , Clone ,)] pub struct AT_AT_SIGN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NULL2_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PARAM_MARKER ; # [derive (Debug , Clone ,)] pub struct A ; # [derive (Debug , Clone ,)] pub struct B ; # [derive (Debug , Clone ,)] pub struct C ; # [derive (Debug , Clone ,)] pub struct D ; # [derive (Debug , Clone ,)] pub struct E ; # [derive (Debug , Clone ,)] pub struct F ; # [derive (Debug , Clone ,)] pub struct G ; # [derive (Debug , Clone ,)] pub struct H ; # [derive (Debug , Clone ,)] pub struct I ; # [derive (Debug , Clone ,)] pub struct J ; # [derive (Debug , Clone ,)] pub struct K ; # [derive (Debug , Clone ,)] pub struct L ; # [derive (Debug , Clone ,)] pub struct M ; # [derive (Debug , Clone ,)] pub struct N ; # [derive (Debug , Clone ,)] pub struct O ; # [derive (Debug , Clone ,)] pub struct P ; # [derive (Debug , Clone ,)] pub struct Q ; # [derive (Debug , Clone ,)] pub struct R ; # [derive (Debug , Clone ,)] pub struct S ; # [derive (Debug , Clone ,)] pub struct T ; # [derive (Debug , Clone ,)] pub struct U ; # [derive (Debug , Clone ,)] pub struct V ; # [derive (Debug , Clone ,)] pub struct W ; # [derive (Debug , Clone ,)] pub struct X ; # [derive (Debug , Clone ,)] pub struct Y ; # [derive (Debug , Clone ,)] pub struct Z ; pub type DIGIT = char ; # [derive (Debug , Clone ,)] pub struct DIGITS ; pub type HEXDIGIT = char ; # [derive (Debug , Clone ,)] pub struct HEX_NUMBER ; pub type BIN_NUMBER = String ; # [derive (Debug , Clone ,)] pub struct INT_NUMBER ; # [derive (Debug , Clone ,)] pub struct LONG_NUMBER ; # [derive (Debug , Clone ,)] pub struct ULONGLONG_NUMBER ; # [derive (Debug , Clone ,)] pub struct DECIMAL_NUMBER ; pub type FLOAT_NUMBER = String ; # [derive (Debug , Clone ,)] pub struct DOT_IDENTIFIER ; pub type UNDERSCORE_CHARSET = String ; pub type IDENTIFIER = String ; pub type NCHAR_TEXT = String ; # [derive (Debug , Clone ,)] pub struct BACK_TICK ; # [derive (Debug , Clone ,)] pub struct SINGLE_QUOTE ; # [derive (Debug , Clone ,)] pub struct DOUBLE_QUOTE ; # [derive (Debug , Clone ,)] pub struct BACK_TICK_QUOTED_ID ; # [derive (Debug , Clone ,)] pub struct BACK_TICK_ESCAPE ; pub type ANY = char ; pub type BACK_TICK_CONTENT = String ; # [derive (Debug , Clone ,)] pub struct DOUBLE_QUOTED_TEXT ; # [derive (Debug , Clone ,)] pub struct DOUBLE_QUOTED_CONTENT ; # [derive (Debug , Clone ,)] pub struct DOUBLE_QUOTE_ESCAPE ; pub type DOUBLE_QUOTE_CHAR = String ; # [derive (Debug , Clone ,)] pub struct SINGLE_QUOTED_TEXT ; # [derive (Debug , Clone ,)] pub struct SINGLE_QUOTED_CONTENT ; # [derive (Debug , Clone ,)] pub struct SINGLE_QUOTE_ESCAPE ; pub type SINGLE_QUOTE_CHAR = String ; # [derive (Debug , Clone ,)] pub struct VERSION_COMMENT ; # [derive (Debug , Clone ,)] pub struct MYSQL_COMMENT ; # [derive (Debug , Clone ,)] pub struct BLOCK_COMMENT ; pub type POUND_COMMENT = String ; pub type DASHDASH_COMMENT = String ; # [derive (Debug , Clone ,)] pub struct DOUBLE_DASH ; pub type LINEBREAK = char ; pub type SIMPLE_IDENTIFIER = String ; # [derive (Debug , Clone ,)] pub struct ML_COMMENT_HEAD ; # [derive (Debug , Clone ,)] pub struct ML_COMMENT_END ; # [derive (Debug , Clone ,)] pub struct LETTER_WHEN_UNQUOTED ; # [derive (Debug , Clone ,)] pub struct LETTER_WHEN_UNQUOTED_NO_DIGIT ; # [derive (Debug , Clone ,)] pub struct LETTER_WITHOUT_FLOAT_PART ; # [derive (Debug , Clone ,)] pub struct ACCESSIBLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ACCOUNT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ACTION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ADD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ADDDATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AFTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AGAINST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AGGREGATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ALGORITHM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ALL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ALTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ALWAYS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ANALYSE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ANALYZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ANY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ASC_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ASCII_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ASENSITIVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AUTHORS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AUTOEXTEND_SIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AUTO_INCREMENT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AVG_ROW_LENGTH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct AVG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BACKUP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BEFORE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BEGIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BETWEEN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BIGINT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BINARY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BINLOG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BIN_NUM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BIT_AND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BIT_OR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BIT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BIT_XOR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BLOB_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BLOCK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BOOLEAN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BOOL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BOTH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BTREE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BYTE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CACHE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CALL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CASCADE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CASCADED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CASE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CAST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CATALOG_NAME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CHAIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CHANGE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CHANGED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CHANNEL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CHARSET_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CHARACTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CHAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CHECKSUM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CHECK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CIPHER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CLASS_ORIGIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CLIENT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CLOSE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COALESCE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CODE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COLLATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COLLATION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COLUMNS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COLUMN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COLUMN_NAME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COLUMN_FORMAT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COMMENT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COMMITTED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COMMIT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COMPACT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COMPLETION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COMPRESSED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COMPRESSION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONCURRENT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONDITION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONNECTION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONSISTENT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONSTRAINT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONSTRAINT_CATALOG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONSTRAINT_NAME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONSTRAINT_SCHEMA_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONTAINS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONTEXT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONTINUE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONTRIBUTORS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONVERT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COUNT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CPU_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CREATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CROSS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CUBE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CURDATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CURRENT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CURRENT_DATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CURRENT_TIME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CURRENT_TIMESTAMP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CURRENT_USER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CURSOR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CURSOR_NAME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CURTIME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DATABASE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DATABASES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DATAFILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DATA_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DATETIME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DATE_ADD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DATE_SUB_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DAYOFMONTH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DAY_HOUR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DAY_MICROSECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DAY_MINUTE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DAY_SECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DAY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DEALLOCATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DEC_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DECIMAL_NUM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DECIMAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DECLARE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DEFAULT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DEFAULT_AUTH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DEFINER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DELAYED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DELAY_KEY_WRITE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DELETE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DESC_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DESCRIBE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DES_KEY_FILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DETERMINISTIC_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DIAGNOSTICS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DIRECTORY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DISABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DISCARD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DISK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DISTINCT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DISTINCTROW_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DIV_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DOUBLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DO_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DROP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DUAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DUMPFILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DUPLICATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DYNAMIC_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EACH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ELSE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ELSEIF_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ENABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ENCLOSED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ENCRYPTION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct END_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ENDS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct END_OF_INPUT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ENGINES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ENGINE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ENUM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ERROR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ERRORS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ESCAPED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ESCAPE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EVENTS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EVENT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EVERY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXCHANGE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXECUTE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXISTS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXIT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXPANSION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXPIRE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXPLAIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXPORT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXTENDED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXTENT_SIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXTRACT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FALSE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FAST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FAULTS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FETCH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FIELDS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FILE_BLOCK_SIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FILTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FIRST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FIXED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FLOAT4_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FLOAT8_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FLOAT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FLUSH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FOLLOWS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FORCE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FOREIGN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FOR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FORMAT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FOUND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FROM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FULL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FULLTEXT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FUNCTION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GET_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GENERAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GENERATED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GROUP_REPLICATION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GEOMETRYCOLLECTION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GEOMETRY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GET_FORMAT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GLOBAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GRANT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GRANTS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GROUP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GROUP_CONCAT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HANDLER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HASH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HAVING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HELP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HIGH_PRIORITY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HOST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HOSTS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HOUR_MICROSECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HOUR_MINUTE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HOUR_SECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HOUR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IDENTIFIED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IF_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IGNORE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IGNORE_SERVER_IDS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IMPORT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INDEXES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INDEX_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INFILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INITIAL_SIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INNER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INOUT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INSENSITIVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INSERT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INSERT_METHOD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INSTANCE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INSTALL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INTEGER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INTERVAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INTO_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INVOKER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IO_AFTER_GTIDS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IO_BEFORE_GTIDS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IO_THREAD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IO_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IPC_SYMBOL ; # [derive (Debug , Clone ,)] pub struct IS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ISOLATION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ISSUER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ITERATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct JOIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct JSON_SYMBOL ; # [derive (Debug , Clone ,)] pub struct KEYS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct KEY_BLOCK_SIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct KEY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct KILL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LANGUAGE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LAST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LEADING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LEAVES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LEAVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LEFT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LESS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LEVEL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LIKE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LIMIT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LINEAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LINES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LINESTRING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LIST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOAD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOCALTIME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOCALTIMESTAMP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOCAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOCATOR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOCKS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOCK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOGFILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOGS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LONGBLOB_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LONGTEXT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LONG_NUM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LONG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOOP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOW_PRIORITY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_AUTO_POSITION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_BIND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_CONNECT_RETRY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_DELAY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_HOST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_LOG_FILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_LOG_POS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_PASSWORD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_PORT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_RETRY_COUNT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SERVER_ID_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SSL_CAPATH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SSL_CA_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SSL_CERT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SSL_CIPHER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SSL_CRL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SSL_CRLPATH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SSL_KEY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SSL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_TLS_VERSION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_USER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_HEARTBEAT_PERIOD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MATCH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MAX_CONNECTIONS_PER_HOUR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MAX_QUERIES_PER_HOUR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MAX_ROWS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MAX_SIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MAX_STATEMENT_TIME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MAX_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MAX_UPDATES_PER_HOUR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MAX_USER_CONNECTIONS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MAXVALUE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MEDIUMBLOB_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MEDIUMINT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MEDIUMTEXT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MEDIUM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MEMORY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MERGE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MESSAGE_TEXT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MICROSECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MID_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MIDDLEINT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MIGRATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MINUTE_MICROSECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MINUTE_SECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MINUTE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MIN_ROWS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MODE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MODIFIES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MODIFY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MOD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MONTH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MULTILINESTRING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MULTIPOINT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MULTIPOLYGON_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MUTEX_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MYSQL_ERRNO_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NAMES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NAME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NATIONAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NATURAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NCHAR_STRING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NCHAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NDB_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NDBCLUSTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NEG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NEVER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NEW_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NEXT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NODEGROUP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NONE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NONBLOCKING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NOT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NOT2_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CONCAT_PIPES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NOW_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NO_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NO_WAIT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NO_WRITE_TO_BINLOG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NULL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NUMBER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NUMERIC_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NVARCHAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OFFLINE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OFFSET_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OLD_PASSWORD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ON_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ONE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ONLINE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ONLY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OPEN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OPTIMIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OPTIMIZER_COSTS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OPTIONS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OPTION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OPTIONALLY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ORDER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OUTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OUTFILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OUT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OWNER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PACK_KEYS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PAGE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PARSER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PARTIAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PARTITIONING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PARTITIONS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PARTITION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PASSWORD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PHASE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PLUGINS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PLUGIN_DIR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PLUGIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct POINT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct POLYGON_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PORT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct POSITION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PRECEDES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PRECISION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PREPARE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PRESERVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PREV_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PRIMARY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PRIVILEGES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PROCEDURE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PROCESS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PROCESSLIST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PROFILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PROFILES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PROXY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PURGE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct QUARTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct QUERY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct QUICK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RANGE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct READS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct READ_ONLY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct READ_SYMBOL ; # [derive (Debug , Clone ,)] pub struct READ_WRITE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REBUILD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RECOVER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REDOFILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REDO_BUFFER_SIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REDUNDANT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REFERENCES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REGEXP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RELAY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RELAYLOG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RELAY_LOG_FILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RELAY_LOG_POS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RELAY_THREAD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RELEASE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RELOAD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REMOVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RENAME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REORGANIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPAIR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPEATABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPEAT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPLACE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPLICATION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPLICATE_DO_DB_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPLICATE_IGNORE_DB_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPLICATE_DO_TABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPLICATE_IGNORE_TABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPLICATE_WILD_DO_TABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPLICATE_WILD_IGNORE_TABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REPLICATE_REWRITE_DB_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REQUIRE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RESET_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RESIGNAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RESTORE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RESTRICT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RESUME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RETURNED_SQLSTATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RETURNS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RETURN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REVERSE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REVOKE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RIGHT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RLIKE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROLLBACK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROLLUP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROTATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROUTINE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROWS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROW_COUNT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROW_FORMAT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROW_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RTREE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SAVEPOINT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SCHEDULE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SCHEMA_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SCHEMA_NAME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SCHEMAS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SECOND_MICROSECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SECURITY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SELECT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SENSITIVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SEPARATOR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SERIALIZABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SERIAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SESSION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SERVER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SERVER_OPTIONS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SESSION_USER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SET_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SET_VAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SHARE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SHOW_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SHUTDOWN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SIGNAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SIGNED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SIMPLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SLAVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SLOW_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SMALLINT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SNAPSHOT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SOME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SOCKET_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SONAME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SOUNDS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SOURCE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SPATIAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SPECIFIC_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQLEXCEPTION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQLSTATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQLWARNING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_AFTER_GTIDS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_AFTER_MTS_GAPS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_BEFORE_GTIDS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_BIG_RESULT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_BUFFER_RESULT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_CACHE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_CALC_FOUND_ROWS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_NO_CACHE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_SMALL_RESULT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_THREAD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SSL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STACKED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STARTING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STARTS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct START_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STATS_AUTO_RECALC_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STATS_PERSISTENT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STATS_SAMPLE_PAGES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STATUS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STDDEV_SAMP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STDDEV_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STDDEV_POP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STOP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STORAGE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STORED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STRAIGHT_JOIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STRING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUBCLASS_ORIGIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUBDATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUBJECT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUBPARTITIONS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUBPARTITION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUBSTR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUBSTRING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUPER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SUSPEND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SWAPS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SWITCHES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SYSDATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SYSTEM_USER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TABLES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TABLESPACE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TABLE_REF_PRIORITY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TABLE_CHECKSUM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TABLE_NAME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TEMPORARY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TEMPTABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TERMINATED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TEXT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct THAN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct THEN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TIMESTAMP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TIMESTAMP_ADD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TIMESTAMP_DIFF_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TIME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TINYBLOB_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TINYINT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TINYTEXT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TO_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TRAILING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TRANSACTION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TRIGGERS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TRIGGER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TRIM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TRUE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TRUNCATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TYPES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TYPE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UDF_RETURNS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNCOMMITTED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNDEFINED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNDOFILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNDO_BUFFER_SIZE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNDO_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNICODE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNINSTALL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNIQUE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNKNOWN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNLOCK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNSIGNED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNTIL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UPDATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UPGRADE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct USAGE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct USER_RESOURCES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct USER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct USE_FRM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct USE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct USING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UTC_DATE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UTC_TIMESTAMP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UTC_TIME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VALIDATION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VALUES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VALUE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VARBINARY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VARCHAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VARCHARACTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VARIABLES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VARIANCE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VARYING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VAR_POP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VAR_SAMP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VIEW_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VIRTUAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WAIT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WARNINGS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WEEK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WEIGHT_STRING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WHEN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WHERE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WHILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WITH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WITHOUT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WORK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WRAPPER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WRITE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct X509_SYMBOL ; # [derive (Debug , Clone ,)] pub struct XA_SYMBOL ; # [derive (Debug , Clone ,)] pub struct XID_SYMBOL ; # [derive (Debug , Clone ,)] pub struct XML_SYMBOL ; # [derive (Debug , Clone ,)] pub struct XOR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct YEAR_MONTH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct YEAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ZEROFILL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PERSIST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ADMIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INVISIBLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VISIBLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXCEPT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct COMPONENT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RECURSIVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct JSON_OBJECTAGG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct JSON_ARRAYAGG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OF_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SKIP_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LOCKED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NOWAIT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GROUPING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PERSIST_ONLY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HISTOGRAM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct BUCKETS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REMOTE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CLONE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct CUME_DIST_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DENSE_RANK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EXCLUDE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FIRST_VALUE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FOLLOWING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GROUPS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LAG_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LAST_VALUE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LEAD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NTH_VALUE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NTILE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NULLS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OTHERS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OVER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PERCENT_RANK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PRECEDING_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RANK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RESPECT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ROW_NUMBER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct TIES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct UNBOUNDED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WINDOW_SYMBOL ; # [derive (Debug , Clone ,)] pub struct EMPTY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct JSON_TABLE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NESTED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ORDINALITY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PATH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct HISTORY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REUSE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SRID_SYMBOL ; # [derive (Debug , Clone ,)] pub struct THREAD_PRIORITY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RESOURCE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SYSTEM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct VCPU_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_PUBLIC_KEY_PATH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct GET_MASTER_PUBLIC_KEY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RESTART_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DEFINITION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct DESCRIPTION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ORGANIZATION_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REFERENCE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OPTIONAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SECONDARY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SECONDARY_ENGINE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SECONDARY_LOAD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SECONDARY_UNLOAD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ACTIVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INACTIVE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct LATERAL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RETAIN_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OLD_SYMBOL ; # [derive (Debug , Clone ,)] pub struct NETWORK_NAMESPACE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ENFORCED_SYMBOL ; # [derive (Debug , Clone ,)] pub struct ARRAY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OJ_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MEMBER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct RANDOM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_COMPRESSION_ALGORITHM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PRIVILEGE_CHECKS_USER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct MASTER_TLS_CIPHERSUITES_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REQUIRE_ROW_FORMAT_SYMBOL ; # [derive (Debug , Clone ,)] pub struct PASSWORD_LOCK_TIME_SYMBOL ; # [derive (Debug , Clone ,)] pub struct FAILED_LOGIN_ATTEMPTS_SYMBOL ; # [derive (Debug , Clone ,)] pub struct REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct STREAM_SYMBOL ; # [derive (Debug , Clone ,)] pub struct OFF_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INT1_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INT2_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INT3_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INT4_SYMBOL ; # [derive (Debug , Clone ,)] pub struct INT8_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_TSI_SECOND_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_TSI_MINUTE_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_TSI_HOUR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_TSI_DAY_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_TSI_WEEK_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_TSI_MONTH_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_TSI_QUARTER_SYMBOL ; # [derive (Debug , Clone ,)] pub struct SQL_TSI_YEAR_SYMBOL ; # [derive (Debug , Clone ,)] pub struct WHITESPACE ; pub type INVALID_INPUT = char ; # [derive (Debug , Clone ,)] pub struct EOF ; impl peginator_generated :: PegParserAdvanced < () > for query { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_query (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } impl peginator_generated :: PegParserAdvanced < () > for simpleStatement { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_simpleStatement (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } impl peginator_generated :: PegParserAdvanced < () > for querySpecification { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_querySpecification (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod query_impl { use super :: * ; mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SEMICOLON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EOF (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EOF (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_beginWork (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EOF (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_query < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , query > { global . tracer . print_trace_start (& state , "query") ; let result = (|| { let result = query_impl :: parse (state , global) ? . map (| r | super :: query { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod simpleStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_renameTableStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_truncateTableStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_importStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_callStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_deleteStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_doStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_handlerStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_loadStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_replaceStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_updateStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_transactionOrLockingStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_replicationStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_preparedStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_cloneStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_accountManagementStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAdministrationStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_installUninstallStatment (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_setStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_showStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resourceGroupManagement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_otherAdministrativeStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_utilityStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_getDiagnostics (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signalStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resignalStatement (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_simpleStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , simpleStatement > { global . tracer . print_trace_start (& state , "simpleStatement") ; let result = (|| { let result = simpleStatement_impl :: parse (state , global) ? . map (| r | super :: simpleStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterStatement_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCEDURE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_procedureRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_routineAlterOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FUNCTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_functionRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_routineAlterOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTANCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROTATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterTable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterDatabase (state , & mut * global) }) . discard_result ()) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterView (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterEvent (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterTablespace (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterUndoTablespace (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterLogfileGroup (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterServer (state , & mut * global) }) . discard_result ()) . choice (| state | choice_10 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterStatement > { global . tracer . print_trace_start (& state , "alterStatement") ; let result = (|| { let result = alterStatement_impl :: parse (state , global) ? . map (| r | super :: alterStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterDatabase_impl { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createDatabaseOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPGRADE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIRECTORY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATABASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterDatabase < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterDatabase > { global . tracer . print_trace_start (& state , "alterDatabase") ; let result = (|| { let result = alterDatabase_impl :: parse (state , global) ? . map (| r | super :: alterDatabase { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterEvent_impl { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SCHEDULE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schedule (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_4 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPLETION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRESERVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RENAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_6 { use super :: * ; mod optional { use super :: * ; mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLAVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_7 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_8 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_definerClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_eventRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; let ParseOk { state , .. } = part_5 :: parse (state , global) ? ; let ParseOk { state , .. } = part_6 :: parse (state , global) ? ; let ParseOk { state , .. } = part_7 :: parse (state , global) ? ; let ParseOk { state , .. } = part_8 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterEvent < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterEvent > { global . tracer . print_trace_start (& state , "alterEvent") ; let result = (|| { let result = alterEvent_impl :: parse (state , global) ? . map (| r | super :: alterEvent { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterLogfileGroup_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_logfileGroupRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDOFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterLogfileGroupOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterLogfileGroup < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterLogfileGroup > { global . tracer . print_trace_start (& state , "alterLogfileGroup") ; let result = (|| { let result = alterLogfileGroup_impl :: parse (state , global) ? . map (| r | super :: alterLogfileGroup { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterLogfileGroupOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterLogfileGroupOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterLogfileGroupOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterLogfileGroupOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterLogfileGroupOptions > { global . tracer . print_trace_start (& state , "alterLogfileGroupOptions") ; let result = (|| { let result = alterLogfileGroupOptions_impl :: parse (state , global) ? . map (| r | super :: alterLogfileGroupOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterLogfileGroupOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionInitialSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionEngine (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionWait (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterLogfileGroupOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterLogfileGroupOption > { global . tracer . print_trace_start (& state , "alterLogfileGroupOption") ; let result = (|| { let result = alterLogfileGroupOption_impl :: parse (state , global) ? . map (| r | super :: alterLogfileGroupOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterServer_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERVER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_serverRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_serverOptions (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterServer < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterServer > { global . tracer . print_trace_start (& state , "alterServer") ; let result = (|| { let result = alterServer_impl :: parse (state , global) ? . map (| r | super :: alterServer { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterTable_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_onlineOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterTableActions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterTable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterTable > { global . tracer . print_trace_start (& state , "alterTable") ; let result = (|| { let result = alterTable_impl :: parse (state , global) ? . map (| r | super :: alterTable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterTableActions_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterCommandList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionClause (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_removePartitioning (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterCommandsModifierList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_standaloneAlterCommands (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionClause (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_removePartitioning (state , & mut * global) }) . discard_result ()) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterTableActions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterTableActions > { global . tracer . print_trace_start (& state , "alterTableActions") ; let result = (|| { let result = alterTableActions_impl :: parse (state , global) ? . map (| r | super :: alterTableActions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterCommandList_impl { use super :: * ; mod choice_1 { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterCommandsModifierList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterCommandsModifierList (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterCommandList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterCommandList > { global . tracer . print_trace_start (& state , "alterCommandList") ; let result = (|| { let result = alterCommandList_impl :: parse (state , global) ? . map (| r | super :: alterCommandList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterCommandsModifierList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterCommandsModifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterCommandsModifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterCommandsModifierList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterCommandsModifierList > { global . tracer . print_trace_start (& state , "alterCommandsModifierList") ; let result = (|| { let result = alterCommandsModifierList_impl :: parse (state , global) ? . map (| r | super :: alterCommandsModifierList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod standaloneAlterCommands_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISCARD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IMPORT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterPartition (state , & mut * global) }) . discard_result ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_LOAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_UNLOAD_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_standaloneAlterCommands < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , standaloneAlterCommands > { global . tracer . print_trace_start (& state , "standaloneAlterCommands") ; let result = (|| { let result = standaloneAlterCommands_impl :: parse (state , global) ? . map (| r | super :: standaloneAlterCommands { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterPartition_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITIONS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionDefinitions (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REBUILD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIMIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANALYZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_checkOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; mod part_4 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_repairType (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPAIR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COALESCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRUNCATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_9 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionDefinitions (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REORGANIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXCHANGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_withValidation (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISCARD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_12 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IMPORT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | choice_9 :: parse (state , global)) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | choice_12 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterPartition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterPartition > { global . tracer . print_trace_start (& state , "alterPartition") ; let result = (|| { let result = alterPartition_impl :: parse (state , global) ? . map (| r | super :: alterPartition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterListItem (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterCommandsModifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createTableOptionsSpaceSeparated (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterListItem (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createTableOptionsSpaceSeparated (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterList > { global . tracer . print_trace_start (& state , "alterList") ; let result = (|| { let result = alterList_impl :: parse (state , global) ? . map (| r | super :: alterList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterCommandsModifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterAlgorithmOption (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterLockOption (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_withValidation (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterCommandsModifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterCommandsModifier > { global . tracer . print_trace_start (& state , "alterCommandsModifier") ; let result = (|| { let result = alterCommandsModifier_impl :: parse (state , global) ? . map (| r | super :: alterCommandsModifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterListItem_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldDefinition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_checkOrReferences (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_place (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableElementList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableConstraintDef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldDefinition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_place (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MODIFY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldDefinition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_place (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_restrict (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOREIGN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRef (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRef (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , }))) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIMARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyOrIndex (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEYS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEYS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; mod part_3 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signedLiteral (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_visibility (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_9 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_constraintEnforcement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_constraintEnforcement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RENAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_12 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RENAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_13 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RENAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyOrIndex (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_14 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONVERT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charset (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetName (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_collate (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_16 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ORDER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterOrderList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_17 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPGRADE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITIONING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | choice_9 :: parse (state , global)) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | choice_12 :: parse (state , global)) . choice (| state | choice_13 :: parse (state , global)) . choice (| state | choice_14 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FORCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_16 :: parse (state , global)) . choice (| state | choice_17 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterListItem < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterListItem > { global . tracer . print_trace_start (& state , "alterListItem") ; let result = (|| { let result = alterListItem_impl :: parse (state , global) ? . map (| r | super :: alterListItem { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod place_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AFTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIRST_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_place < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , place > { global . tracer . print_trace_start (& state , "place") ; let result = (|| { let result = place_impl :: parse (state , global) ? . map (| r | super :: place { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod restrict_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESTRICT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASCADE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_restrict < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , restrict > { global . tracer . print_trace_start (& state , "restrict") ; let result = (|| { let result = restrict_impl :: parse (state , global) ? . map (| r | super :: restrict { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterOrderList_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_direction (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_direction (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterOrderList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterOrderList > { global . tracer . print_trace_start (& state , "alterOrderList") ; let result = (|| { let result = alterOrderList_impl :: parse (state , global) ? . map (| r | super :: alterOrderList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterAlgorithmOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALGORITHM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterAlgorithmOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterAlgorithmOption > { global . tracer . print_trace_start (& state , "alterAlgorithmOption") ; let result = (|| { let result = alterAlgorithmOption_impl :: parse (state , global) ? . map (| r | super :: alterAlgorithmOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterLockOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterLockOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterLockOption > { global . tracer . print_trace_start (& state , "alterLockOption") ; let result = (|| { let result = alterLockOption_impl :: parse (state , global) ? . map (| r | super :: alterLockOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexLockAndAlgorithm_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterAlgorithmOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterLockOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterLockOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterAlgorithmOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexLockAndAlgorithm < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexLockAndAlgorithm > { global . tracer . print_trace_start (& state , "indexLockAndAlgorithm") ; let result = (|| { let result = indexLockAndAlgorithm_impl :: parse (state , global) ? . map (| r | super :: indexLockAndAlgorithm { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod withValidation_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITHOUT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALIDATION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_withValidation < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , withValidation > { global . tracer . print_trace_start (& state , "withValidation") ; let result = (|| { let result = withValidation_impl :: parse (state , global) ? . map (| r | super :: withValidation { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod removePartitioning_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REMOVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITIONING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_removePartitioning < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , removePartitioning > { global . tracer . print_trace_start (& state , "removePartitioning") ; let result = (|| { let result = removePartitioning_impl :: parse (state , global) ? . map (| r | super :: removePartitioning { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod allOrPartitionNameList_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_allOrPartitionNameList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , allOrPartitionNameList > { global . tracer . print_trace_start (& state , "allOrPartitionNameList") ; let result = (|| { let result = allOrPartitionNameList_impl :: parse (state , global) ? . map (| r | super :: allOrPartitionNameList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterTablespace_impl { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATAFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterTablespaceOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_changeTablespaceOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_changeTablespaceOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATAFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACCESSIBLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_ONLY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_WRITE_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RENAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterTablespaceOptions (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablespaceRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterTablespace < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterTablespace > { global . tracer . print_trace_start (& state , "alterTablespace") ; let result = (|| { let result = alterTablespace_impl :: parse (state , global) ? . map (| r | super :: alterTablespace { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterUndoTablespace_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablespaceRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACTIVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INACTIVE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_undoTableSpaceOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterUndoTablespace < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterUndoTablespace > { global . tracer . print_trace_start (& state , "alterUndoTablespace") ; let result = (|| { let result = alterUndoTablespace_impl :: parse (state , global) ? . map (| r | super :: alterUndoTablespace { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod undoTableSpaceOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_undoTableSpaceOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_undoTableSpaceOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_undoTableSpaceOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , undoTableSpaceOptions > { global . tracer . print_trace_start (& state , "undoTableSpaceOptions") ; let result = (|| { let result = undoTableSpaceOptions_impl :: parse (state , global) ? . map (| r | super :: undoTableSpaceOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod undoTableSpaceOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionEngine (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_undoTableSpaceOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , undoTableSpaceOption > { global . tracer . print_trace_start (& state , "undoTableSpaceOption") ; let result = (|| { let result = undoTableSpaceOption_impl :: parse (state , global) ? . map (| r | super :: undoTableSpaceOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterTablespaceOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterTablespaceOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterTablespaceOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterTablespaceOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterTablespaceOptions > { global . tracer . print_trace_start (& state , "alterTablespaceOptions") ; let result = (|| { let result = alterTablespaceOptions_impl :: parse (state , global) ? . map (| r | super :: alterTablespaceOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterTablespaceOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INITIAL_SIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sizeNumber (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionAutoextendSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionMaxSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionEngine (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionWait (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionEncryption (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterTablespaceOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterTablespaceOption > { global . tracer . print_trace_start (& state , "alterTablespaceOption") ; let result = (|| { let result = alterTablespaceOption_impl :: parse (state , global) ? . map (| r | super :: alterTablespaceOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod changeTablespaceOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INITIAL_SIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sizeNumber (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionAutoextendSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionMaxSize (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_changeTablespaceOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , changeTablespaceOption > { global . tracer . print_trace_start (& state , "changeTablespaceOption") ; let result = (|| { let result = changeTablespaceOption_impl :: parse (state , global) ? . map (| r | super :: changeTablespaceOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterView_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewAlgorithm (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_definerClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewSuid (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VIEW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewTail (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterView < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterView > { global . tracer . print_trace_start (& state , "alterView") ; let result = (|| { let result = alterView_impl :: parse (state , global) ? . map (| r | super :: alterView { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod viewTail_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRefList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewSelect (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_viewTail < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , viewTail > { global . tracer . print_trace_start (& state , "viewTail") ; let result = (|| { let result = viewTail_impl :: parse (state , global) ? . map (| r | super :: viewTail { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod viewSelect_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionOrParens (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewCheckOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_viewSelect < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , viewSelect > { global . tracer . print_trace_start (& state , "viewSelect") ; let result = (|| { let result = viewSelect_impl :: parse (state , global) ? . map (| r | super :: viewSelect { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod viewCheckOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASCADED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_viewCheckOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , viewCheckOption > { global . tracer . print_trace_start (& state , "viewCheckOption") ; let result = (|| { let result = viewCheckOption_impl :: parse (state , global) ? . map (| r | super :: viewCheckOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CREATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createDatabase (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createTable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createFunction (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createProcedure (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUdf (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createLogfileGroup (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createView (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createTrigger (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createIndex (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createServer (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createTablespace (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createEvent (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createRole (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createSpatialReference (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUndoTablespace (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createStatement > { global . tracer . print_trace_start (& state , "createStatement") ; let result = (|| { let result = createStatement_impl :: parse (state , global) ? . map (| r | super :: createStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createDatabase_impl { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createDatabaseOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATABASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifNotExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createDatabase < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createDatabase > { global . tracer . print_trace_start (& state , "createDatabase") ; let result = (|| { let result = createDatabase_impl :: parse (state , global) ? . map (| r | super :: createDatabase { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createDatabaseOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_defaultCharset (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_defaultCollation (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_defaultEncryption (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_createDatabaseOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createDatabaseOption > { global . tracer . print_trace_start (& state , "createDatabaseOption") ; let result = (|| { let result = createDatabaseOption_impl :: parse (state , global) ? . map (| r | super :: createDatabaseOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createTable_impl { use super :: * ; mod part_4 { use super :: * ; mod choice_0 { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableElementList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createTableOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_duplicateAsQueryExpression (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIKE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIKE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEMPORARY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifNotExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createTable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createTable > { global . tracer . print_trace_start (& state , "createTable") ; let result = (|| { let result = createTable_impl :: parse (state , global) ? . map (| r | super :: createTable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableElementList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableElement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableElement (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableElementList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableElementList > { global . tracer . print_trace_start (& state , "tableElementList") ; let result = (|| { let result = tableElementList_impl :: parse (state , global) ? . map (| r | super :: tableElementList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableElement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnDefinition (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableConstraintDef (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableElement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableElement > { global . tracer . print_trace_start (& state , "tableElement") ; let result = (|| { let result = tableElement_impl :: parse (state , global) ? . map (| r | super :: tableElement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod duplicateAsQueryExpression_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLACE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionOrParens (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_duplicateAsQueryExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , duplicateAsQueryExpression > { global . tracer . print_trace_start (& state , "duplicateAsQueryExpression") ; let result = (|| { let result = duplicateAsQueryExpression_impl :: parse (state , global) ? . map (| r | super :: duplicateAsQueryExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod queryExpressionOrParens_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpression (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionParens (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_queryExpressionOrParens < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , queryExpressionOrParens > { global . tracer . print_trace_start (& state , "queryExpressionOrParens") ; let result = (|| { let result = queryExpressionOrParens_impl :: parse (state , global) ? . map (| r | super :: queryExpressionOrParens { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createRoutine_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CREATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createProcedure (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createFunction (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUdf (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SEMICOLON_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EOF (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createRoutine < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createRoutine > { global . tracer . print_trace_start (& state , "createRoutine") ; let result = (|| { let result = createRoutine_impl :: parse (state , global) ? . map (| r | super :: createRoutine { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createProcedure_impl { use super :: * ; mod part_4 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_procedureParameter (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_procedureParameter (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_6 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_routineCreateOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_definerClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCEDURE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_procedureName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_6 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createProcedure < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createProcedure > { global . tracer . print_trace_start (& state , "createProcedure") ; let result = (|| { let result = createProcedure_impl :: parse (state , global) ? . map (| r | super :: createProcedure { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createFunction_impl { use super :: * ; mod part_4 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_functionParameter (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_functionParameter (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_8 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_routineCreateOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_definerClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FUNCTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_functionName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETURNS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_typeWithOptCollate (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_8 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createFunction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createFunction > { global . tracer . print_trace_start (& state , "createFunction") ; let result = (|| { let result = createFunction_impl :: parse (state , global) ? . map (| r | super :: createFunction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createUdf_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AGGREGATE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FUNCTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_udfName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETURNS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECIMAL_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SONAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createUdf < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createUdf > { global . tracer . print_trace_start (& state , "createUdf") ; let result = (|| { let result = createUdf_impl :: parse (state , global) ? . map (| r | super :: createUdf { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod routineCreateOption_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DETERMINISTIC_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_routineOption (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_routineCreateOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , routineCreateOption > { global . tracer . print_trace_start (& state , "routineCreateOption") ; let result = (|| { let result = routineCreateOption_impl :: parse (state , global) ? . map (| r | super :: routineCreateOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod routineAlterOptions_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_routineCreateOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_routineAlterOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , routineAlterOptions > { global . tracer . print_trace_start (& state , "routineAlterOptions") ; let result = (|| { let result = routineAlterOptions_impl :: parse (state , global) ? . map (| r | super :: routineAlterOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod routineOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LANGUAGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTAINS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MODIFIES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECURITY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFINER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INVOKER_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_routineOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , routineOption > { global . tracer . print_trace_start (& state , "routineOption") ; let result = (|| { let result = routineOption_impl :: parse (state , global) ? . map (| r | super :: routineOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createIndex_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexTypeClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexNameAndType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexNameAndType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , }))) . end () } pub type Parsed = () ; } mod part_4 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNIQUE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createIndexTarget (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_4 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fulltextIndexOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FULLTEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createIndexTarget (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_4 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_spatialIndexOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SPATIAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createIndexTarget (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_onlineOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexLockAndAlgorithm (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createIndex < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createIndex > { global . tracer . print_trace_start (& state , "createIndex") ; let result = (|| { let result = createIndex_impl :: parse (state , global) ? . map (| r | super :: createIndex { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexNameAndType_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexType (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TYPE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexType (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexNameAndType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexNameAndType > { global . tracer . print_trace_start (& state , "indexNameAndType") ; let result = (|| { let result = indexNameAndType_impl :: parse (state , global) ? . map (| r | super :: indexNameAndType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createIndexTarget_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyListVariants (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createIndexTarget < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createIndexTarget > { global . tracer . print_trace_start (& state , "createIndexTarget") ; let result = (|| { let result = createIndexTarget_impl :: parse (state , global) ? . map (| r | super :: createIndexTarget { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createLogfileGroup_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_logfileGroupName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDOFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REDOFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_logfileGroupOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createLogfileGroup < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createLogfileGroup > { global . tracer . print_trace_start (& state , "createLogfileGroup") ; let result = (|| { let result = createLogfileGroup_impl :: parse (state , global) ? . map (| r | super :: createLogfileGroup { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod logfileGroupOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_logfileGroupOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_logfileGroupOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_logfileGroupOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , logfileGroupOptions > { global . tracer . print_trace_start (& state , "logfileGroupOptions") ; let result = (|| { let result = logfileGroupOptions_impl :: parse (state , global) ? . map (| r | super :: logfileGroupOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod logfileGroupOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionInitialSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionUndoRedoBufferSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionNodegroup (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionEngine (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionWait (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionComment (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_logfileGroupOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , logfileGroupOption > { global . tracer . print_trace_start (& state , "logfileGroupOption") ; let result = (|| { let result = logfileGroupOption_impl :: parse (state , global) ? . map (| r | super :: logfileGroupOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createServer_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERVER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_serverName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOREIGN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WRAPPER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_serverOptions (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createServer < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createServer > { global . tracer . print_trace_start (& state , "createServer") ; let result = (|| { let result = createServer_impl :: parse (state , global) ? . map (| r | super :: createServer { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod serverOptions_impl { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_serverOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIONS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_serverOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_serverOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , serverOptions > { global . tracer . print_trace_start (& state , "serverOptions") ; let result = (|| { let result = serverOptions_impl :: parse (state , global) ? . map (| r | super :: serverOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod serverOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOST_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATABASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SOCKET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OWNER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PORT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_serverOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , serverOption > { global . tracer . print_trace_start (& state , "serverOption") ; let result = (|| { let result = serverOption_impl :: parse (state , global) ? . map (| r | super :: serverOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createTablespace_impl { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_logfileGroupRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablespaceName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsDataFileName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablespaceOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createTablespace < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createTablespace > { global . tracer . print_trace_start (& state , "createTablespace") ; let result = (|| { let result = createTablespace_impl :: parse (state , global) ? . map (| r | super :: createTablespace { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createUndoTablespace_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablespaceName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsDataFile (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_undoTableSpaceOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createUndoTablespace < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createUndoTablespace > { global . tracer . print_trace_start (& state , "createUndoTablespace") ; let result = (|| { let result = createUndoTablespace_impl :: parse (state , global) ? . map (| r | super :: createUndoTablespace { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsDataFileName_impl { use super :: * ; mod choice_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsDataFile (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsDataFile (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsDataFileName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsDataFileName > { global . tracer . print_trace_start (& state , "tsDataFileName") ; let result = (|| { let result = tsDataFileName_impl :: parse (state , global) ? . map (| r | super :: tsDataFileName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsDataFile_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATAFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsDataFile < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsDataFile > { global . tracer . print_trace_start (& state , "tsDataFile") ; let result = (|| { let result = tsDataFile_impl :: parse (state , global) ? . map (| r | super :: tsDataFile { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tablespaceOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablespaceOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablespaceOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tablespaceOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tablespaceOptions > { global . tracer . print_trace_start (& state , "tablespaceOptions") ; let result = (|| { let result = tablespaceOptions_impl :: parse (state , global) ? . map (| r | super :: tablespaceOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tablespaceOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionInitialSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionAutoextendSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionMaxSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionExtentSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionNodegroup (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionEngine (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionWait (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionComment (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionFileblockSize (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionEncryption (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tablespaceOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tablespaceOption > { global . tracer . print_trace_start (& state , "tablespaceOption") ; let result = (|| { let result = tablespaceOption_impl :: parse (state , global) ? . map (| r | super :: tablespaceOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionInitialSize_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INITIAL_SIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sizeNumber (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionInitialSize < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionInitialSize > { global . tracer . print_trace_start (& state , "tsOptionInitialSize") ; let result = (|| { let result = tsOptionInitialSize_impl :: parse (state , global) ? . map (| r | super :: tsOptionInitialSize { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionUndoRedoBufferSize_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDO_BUFFER_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REDO_BUFFER_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sizeNumber (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionUndoRedoBufferSize < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionUndoRedoBufferSize > { global . tracer . print_trace_start (& state , "tsOptionUndoRedoBufferSize") ; let result = (|| { let result = tsOptionUndoRedoBufferSize_impl :: parse (state , global) ? . map (| r | super :: tsOptionUndoRedoBufferSize { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionAutoextendSize_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AUTOEXTEND_SIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sizeNumber (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionAutoextendSize < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionAutoextendSize > { global . tracer . print_trace_start (& state , "tsOptionAutoextendSize") ; let result = (|| { let result = tsOptionAutoextendSize_impl :: parse (state , global) ? . map (| r | super :: tsOptionAutoextendSize { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionMaxSize_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_SIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sizeNumber (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionMaxSize < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionMaxSize > { global . tracer . print_trace_start (& state , "tsOptionMaxSize") ; let result = (|| { let result = tsOptionMaxSize_impl :: parse (state , global) ? . map (| r | super :: tsOptionMaxSize { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionExtentSize_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENT_SIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sizeNumber (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionExtentSize < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionExtentSize > { global . tracer . print_trace_start (& state , "tsOptionExtentSize") ; let result = (|| { let result = tsOptionExtentSize_impl :: parse (state , global) ? . map (| r | super :: tsOptionExtentSize { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionNodegroup_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NODEGROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionNodegroup < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionNodegroup > { global . tracer . print_trace_start (& state , "tsOptionNodegroup") ; let result = (|| { let result = tsOptionNodegroup_impl :: parse (state , global) ? . map (| r | super :: tsOptionNodegroup { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionEngine_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STORAGE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_engineRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionEngine < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionEngine > { global . tracer . print_trace_start (& state , "tsOptionEngine") ; let result = (|| { let result = tsOptionEngine_impl :: parse (state , global) ? . map (| r | super :: tsOptionEngine { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionWait_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WAIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_WAIT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionWait < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionWait > { global . tracer . print_trace_start (& state , "tsOptionWait") ; let result = (|| { let result = tsOptionWait_impl :: parse (state , global) ? . map (| r | super :: tsOptionWait { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionComment_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionComment < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionComment > { global . tracer . print_trace_start (& state , "tsOptionComment") ; let result = (|| { let result = tsOptionComment_impl :: parse (state , global) ? . map (| r | super :: tsOptionComment { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionFileblockSize_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FILE_BLOCK_SIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sizeNumber (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionFileblockSize < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionFileblockSize > { global . tracer . print_trace_start (& state , "tsOptionFileblockSize") ; let result = (|| { let result = tsOptionFileblockSize_impl :: parse (state , global) ? . map (| r | super :: tsOptionFileblockSize { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tsOptionEncryption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENCRYPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tsOptionEncryption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tsOptionEncryption > { global . tracer . print_trace_start (& state , "tsOptionEncryption") ; let result = (|| { let result = tsOptionEncryption_impl :: parse (state , global) ? . map (| r | super :: tsOptionEncryption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createView_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewReplaceOrAlgorithm (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_definerClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewSuid (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VIEW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewTail (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createView < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createView > { global . tracer . print_trace_start (& state , "createView") ; let result = (|| { let result = createView_impl :: parse (state , global) ? . map (| r | super :: createView { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod viewReplaceOrAlgorithm_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewAlgorithm (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewAlgorithm (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_viewReplaceOrAlgorithm < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , viewReplaceOrAlgorithm > { global . tracer . print_trace_start (& state , "viewReplaceOrAlgorithm") ; let result = (|| { let result = viewReplaceOrAlgorithm_impl :: parse (state , global) ? . map (| r | super :: viewReplaceOrAlgorithm { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod viewAlgorithm_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALGORITHM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDEFINED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MERGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEMPTABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_viewAlgorithm < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , viewAlgorithm > { global . tracer . print_trace_start (& state , "viewAlgorithm") ; let result = (|| { let result = viewAlgorithm_impl :: parse (state , global) ? . map (| r | super :: viewAlgorithm { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod viewSuid_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECURITY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFINER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INVOKER_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_viewSuid < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , viewSuid > { global . tracer . print_trace_start (& state , "viewSuid") ; let result = (|| { let result = viewSuid_impl :: parse (state , global) ? . map (| r | super :: viewSuid { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createTrigger_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_definerClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRIGGER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_triggerName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BEFORE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AFTER_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSERT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPDATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELETE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EACH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_triggerFollowsPrecedesClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createTrigger < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createTrigger > { global . tracer . print_trace_start (& state , "createTrigger") ; let result = (|| { let result = createTrigger_impl :: parse (state , global) ? . map (| r | super :: createTrigger { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod triggerFollowsPrecedesClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOLLOWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECEDES_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_triggerFollowsPrecedesClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , triggerFollowsPrecedesClause > { global . tracer . print_trace_start (& state , "triggerFollowsPrecedesClause") ; let result = (|| { let result = triggerFollowsPrecedesClause_impl :: parse (state , global) ? . map (| r | super :: triggerFollowsPrecedesClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createEvent_impl { use super :: * ; mod part_7 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPLETION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRESERVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_8 { use super :: * ; mod optional { use super :: * ; mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLAVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_9 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_definerClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifNotExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_eventName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SCHEDULE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schedule (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_7 :: parse (state , global) ? ; let ParseOk { state , .. } = part_8 :: parse (state , global) ? ; let ParseOk { state , .. } = part_9 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createEvent < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createEvent > { global . tracer . print_trace_start (& state , "createEvent") ; let result = (|| { let result = createEvent_impl :: parse (state , global) ? . map (| r | super :: createEvent { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createRole_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifNotExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createRole < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createRole > { global . tracer . print_trace_start (& state , "createRole") ; let result = (|| { let result = createRole_impl :: parse (state , global) ? . map (| r | super :: createRole { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createSpatialReference_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_6 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_srsAttribute (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SPATIAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REFERENCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SYSTEM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulonglong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_6 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_5 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_srsAttribute (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SPATIAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REFERENCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SYSTEM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifNotExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulonglong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_createSpatialReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createSpatialReference > { global . tracer . print_trace_start (& state , "createSpatialReference") ; let result = (|| { let result = createSpatialReference_impl :: parse (state , global) ? . map (| r | super :: createSpatialReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod srsAttribute_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFINITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ORGANIZATION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulonglong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DESCRIPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_srsAttribute < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , srsAttribute > { global . tracer . print_trace_start (& state , "srsAttribute") ; let result = (|| { let result = srsAttribute_impl :: parse (state , global) ? . map (| r | super :: srsAttribute { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropDatabase (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropEvent (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropFunction (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropProcedure (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropIndex (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropLogfileGroup (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropServer (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropTable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropTableSpace (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropTrigger (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropView (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropRole (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropSpatialReference (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropUndoTablespace (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropStatement > { global . tracer . print_trace_start (& state , "dropStatement") ; let result = (|| { let result = dropStatement_impl :: parse (state , global) ? . map (| r | super :: dropStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropDatabase_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATABASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropDatabase < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropDatabase > { global . tracer . print_trace_start (& state , "dropDatabase") ; let result = (|| { let result = dropDatabase_impl :: parse (state , global) ? . map (| r | super :: dropDatabase { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropEvent_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_eventRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropEvent < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropEvent > { global . tracer . print_trace_start (& state , "dropEvent") ; let result = (|| { let result = dropEvent_impl :: parse (state , global) ? . map (| r | super :: dropEvent { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropFunction_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FUNCTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_functionRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropFunction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropFunction > { global . tracer . print_trace_start (& state , "dropFunction") ; let result = (|| { let result = dropFunction_impl :: parse (state , global) ? . map (| r | super :: dropFunction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropProcedure_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCEDURE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_procedureRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropProcedure < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropProcedure > { global . tracer . print_trace_start (& state , "dropProcedure") ; let result = (|| { let result = dropProcedure_impl :: parse (state , global) ? . map (| r | super :: dropProcedure { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropIndex_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_onlineOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexLockAndAlgorithm (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropIndex < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropIndex > { global . tracer . print_trace_start (& state , "dropIndex") ; let result = (|| { let result = dropIndex_impl :: parse (state , global) ? . map (| r | super :: dropIndex { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropLogfileGroup_impl { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropLogfileGroupOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropLogfileGroupOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_logfileGroupRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropLogfileGroup < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropLogfileGroup > { global . tracer . print_trace_start (& state , "dropLogfileGroup") ; let result = (|| { let result = dropLogfileGroup_impl :: parse (state , global) ? . map (| r | super :: dropLogfileGroup { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropLogfileGroupOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionWait (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tsOptionEngine (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropLogfileGroupOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropLogfileGroupOption > { global . tracer . print_trace_start (& state , "dropLogfileGroupOption") ; let result = (|| { let result = dropLogfileGroupOption_impl :: parse (state , global) ? . map (| r | super :: dropLogfileGroupOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropServer_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERVER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_serverRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropServer < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropServer > { global . tracer . print_trace_start (& state , "dropServer") ; let result = (|| { let result = dropServer_impl :: parse (state , global) ? . map (| r | super :: dropServer { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropTable_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEMPORARY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRefList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESTRICT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASCADE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropTable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropTable > { global . tracer . print_trace_start (& state , "dropTable") ; let result = (|| { let result = dropTable_impl :: parse (state , global) ? . map (| r | super :: dropTable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropTableSpace_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropLogfileGroupOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropLogfileGroupOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablespaceRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropTableSpace < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropTableSpace > { global . tracer . print_trace_start (& state , "dropTableSpace") ; let result = (|| { let result = dropTableSpace_impl :: parse (state , global) ? . map (| r | super :: dropTableSpace { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropTrigger_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRIGGER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_triggerRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropTrigger < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropTrigger > { global . tracer . print_trace_start (& state , "dropTrigger") ; let result = (|| { let result = dropTrigger_impl :: parse (state , global) ? . map (| r | super :: dropTrigger { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropView_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VIEW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewRefList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESTRICT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASCADE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropView < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropView > { global . tracer . print_trace_start (& state , "dropView") ; let result = (|| { let result = dropView_impl :: parse (state , global) ? . map (| r | super :: dropView { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropRole_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropRole < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropRole > { global . tracer . print_trace_start (& state , "dropRole") ; let result = (|| { let result = dropRole_impl :: parse (state , global) ? . map (| r | super :: dropRole { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropSpatialReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SPATIAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REFERENCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SYSTEM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulonglong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropSpatialReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropSpatialReference > { global . tracer . print_trace_start (& state , "dropSpatialReference") ; let result = (|| { let result = dropSpatialReference_impl :: parse (state , global) ? . map (| r | super :: dropSpatialReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropUndoTablespace_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablespaceRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_undoTableSpaceOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropUndoTablespace < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropUndoTablespace > { global . tracer . print_trace_start (& state , "dropUndoTablespace") ; let result = (|| { let result = dropUndoTablespace_impl :: parse (state , global) ? . map (| r | super :: dropUndoTablespace { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod renameTableStatement_impl { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_renamePair (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RENAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_renamePair (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_renameTableStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , renameTableStatement > { global . tracer . print_trace_start (& state , "renameTableStatement") ; let result = (|| { let result = renameTableStatement_impl :: parse (state , global) ? . map (| r | super :: renameTableStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod renamePair_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_renamePair < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , renamePair > { global . tracer . print_trace_start (& state , "renamePair") ; let result = (|| { let result = renamePair_impl :: parse (state , global) ? . map (| r | super :: renamePair { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod truncateTableStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRUNCATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_truncateTableStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , truncateTableStatement > { global . tracer . print_trace_start (& state , "truncateTableStatement") ; let result = (|| { let result = truncateTableStatement_impl :: parse (state , global) ? . map (| r | super :: truncateTableStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod importStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IMPORT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteralList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_importStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , importStatement > { global . tracer . print_trace_start (& state , "importStatement") ; let result = (|| { let result = importStatement_impl :: parse (state , global) ? . map (| r | super :: importStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod callStatement_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CALL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_procedureRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_callStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , callStatement > { global . tracer . print_trace_start (& state , "callStatement") ; let result = (|| { let result = callStatement_impl :: parse (state , global) ? . map (| r | super :: callStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod deleteStatement_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_deleteStatementOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod part_3 { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAliasRefList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReferenceList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whereClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAlias (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionDelete (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whereClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleLimitClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAliasRefList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReferenceList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whereClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_withClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELETE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_deleteStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , deleteStatement > { global . tracer . print_trace_start (& state , "deleteStatement") ; let result = (|| { let result = deleteStatement_impl :: parse (state , global) ? . map (| r | super :: deleteStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionDelete_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionDelete < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionDelete > { global . tracer . print_trace_start (& state , "partitionDelete") ; let result = (|| { let result = partitionDelete_impl :: parse (state , global) ? . map (| r | super :: partitionDelete { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod deleteStatementOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUICK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOW_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUICK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_deleteStatementOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , deleteStatementOption > { global . tracer . print_trace_start (& state , "deleteStatementOption") ; let result = (|| { let result = deleteStatementOption_impl :: parse (state , global) ? . map (| r | super :: deleteStatementOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod doStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectItemList (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_doStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , doStatement > { global . tracer . print_trace_start (& state , "doStatement") ; let result = (|| { let result = doStatement_impl :: parse (state , global) ? . map (| r | super :: doStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod handlerStatement_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAlias (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_handlerReadOrScan (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whereClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HANDLER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_handlerStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , handlerStatement > { global . tracer . print_trace_start (& state , "handlerStatement") ; let result = (|| { let result = handlerStatement_impl :: parse (state , global) ? . map (| r | super :: handlerStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod handlerReadOrScan_impl { use super :: * ; mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LESS_THAN_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GREATER_THAN_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LESS_OR_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GREATER_OR_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_values (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIRST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PREV_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LAST_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIRST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_handlerReadOrScan < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , handlerReadOrScan > { global . tracer . print_trace_start (& state , "handlerReadOrScan") ; let result = (|| { let result = handlerReadOrScan_impl :: parse (state , global) ? . map (| r | super :: handlerReadOrScan { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod insertStatement_impl { use super :: * ; mod part_6 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertFromConstructor (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_valuesReference (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_updateList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_valuesReference (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertQueryExpression (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSERT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertLockOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTO_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_usePartition (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_6 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertUpdateList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_insertStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , insertStatement > { global . tracer . print_trace_start (& state , "insertStatement") ; let result = (|| { let result = insertStatement_impl :: parse (state , global) ? . map (| r | super :: insertStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod insertLockOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOW_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELAYED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HIGH_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_insertLockOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , insertLockOption > { global . tracer . print_trace_start (& state , "insertLockOption") ; let result = (|| { let result = insertLockOption_impl :: parse (state , global) ? . map (| r | super :: insertLockOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod insertFromConstructor_impl { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fields (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertValues (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_insertFromConstructor < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , insertFromConstructor > { global . tracer . print_trace_start (& state , "insertFromConstructor") ; let result = (|| { let result = insertFromConstructor_impl :: parse (state , global) ? . map (| r | super :: insertFromConstructor { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fields_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_fields < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fields > { global . tracer . print_trace_start (& state , "fields") ; let result = (|| { let result = fields_impl :: parse (state , global) ? . map (| r | super :: fields { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod insertValues_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_valueList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_insertValues < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , insertValues > { global . tracer . print_trace_start (& state , "insertValues") ; let result = (|| { let result = insertValues_impl :: parse (state , global) ? . map (| r | super :: insertValues { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod insertQueryExpression_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fields (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionOrParens (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionOrParens (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_insertQueryExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , insertQueryExpression > { global . tracer . print_trace_start (& state , "insertQueryExpression") ; let result = (|| { let result = insertQueryExpression_impl :: parse (state , global) ? . map (| r | super :: insertQueryExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod valueList_impl { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_values (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_values (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_valueList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , valueList > { global . tracer . print_trace_start (& state , "valueList") ; let result = (|| { let result = valueList_impl :: parse (state , global) ? . map (| r | super :: valueList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod values_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_values < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , values > { global . tracer . print_trace_start (& state , "values") ; let result = (|| { let result = values_impl :: parse (state , global) ? . map (| r | super :: values { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod valuesReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRefList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_valuesReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , valuesReference > { global . tracer . print_trace_start (& state , "valuesReference") ; let result = (|| { let result = valuesReference_impl :: parse (state , global) ? . map (| r | super :: valuesReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod insertUpdateList_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DUPLICATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPDATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_updateList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_insertUpdateList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , insertUpdateList > { global . tracer . print_trace_start (& state , "insertUpdateList") ; let result = (|| { let result = insertUpdateList_impl :: parse (state , global) ? . map (| r | super :: insertUpdateList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod loadStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOAD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dataOrXml (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOW_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONCURRENT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLACE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_usePartition (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_xmlRowsIdentifiedBy (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldsClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_linesClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_loadDataFileTail (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_loadStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , loadStatement > { global . tracer . print_trace_start (& state , "loadStatement") ; let result = (|| { let result = loadStatement_impl :: parse (state , global) ? . map (| r | super :: loadStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dataOrXml_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XML_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_dataOrXml < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dataOrXml > { global . tracer . print_trace_start (& state , "dataOrXml") ; let result = (|| { let result = dataOrXml_impl :: parse (state , global) ? . map (| r | super :: dataOrXml { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod xmlRowsIdentifiedBy_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROWS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_xmlRowsIdentifiedBy < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , xmlRowsIdentifiedBy > { global . tracer . print_trace_start (& state , "xmlRowsIdentifiedBy") ; let result = (|| { let result = xmlRowsIdentifiedBy_impl :: parse (state , global) ? . map (| r | super :: xmlRowsIdentifiedBy { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod loadDataFileTail_impl { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_updateList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_loadDataFileTargetList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_loadDataFileTail < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , loadDataFileTail > { global . tracer . print_trace_start (& state , "loadDataFileTail") ; let result = (|| { let result = loadDataFileTail_impl :: parse (state , global) ? . map (| r | super :: loadDataFileTail { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod loadDataFileTargetList_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldOrVariableList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_loadDataFileTargetList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , loadDataFileTargetList > { global . tracer . print_trace_start (& state , "loadDataFileTargetList") ; let result = (|| { let result = loadDataFileTargetList_impl :: parse (state , global) ? . map (| r | super :: loadDataFileTargetList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fieldOrVariableList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnRef (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userVariable (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnRef (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userVariable (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_fieldOrVariableList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fieldOrVariableList > { global . tracer . print_trace_start (& state , "fieldOrVariableList") ; let result = (|| { let result = fieldOrVariableList_impl :: parse (state , global) ? . map (| r | super :: fieldOrVariableList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod replaceStatement_impl { use super :: * ; mod part_5 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_updateList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertFromConstructor (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertQueryExpression (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOW_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELAYED_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTO_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_usePartition (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_replaceStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , replaceStatement > { global . tracer . print_trace_start (& state , "replaceStatement") ; let result = (|| { let result = replaceStatement_impl :: parse (state , global) ? . map (| r | super :: replaceStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod selectStatement_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpression (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockingClauseList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionParens (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectStatementWithInto (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_selectStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , selectStatement > { global . tracer . print_trace_start (& state , "selectStatement") ; let result = (|| { let result = selectStatement_impl :: parse (state , global) ? . map (| r | super :: selectStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod selectStatementWithInto_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectStatementWithInto (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpression (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_intoClause (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockingClauseList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockingClauseList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_intoClause (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_selectStatementWithInto < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , selectStatementWithInto > { global . tracer . print_trace_start (& state , "selectStatementWithInto") ; let result = (|| { let result = selectStatementWithInto_impl :: parse (state , global) ? . map (| r | super :: selectStatementWithInto { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod queryExpression_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionBody (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionParens (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_withClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_procedureAnalyseClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_queryExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , queryExpression > { global . tracer . print_trace_start (& state , "queryExpression") ; let result = (|| { let result = queryExpression_impl :: parse (state , global) ? . map (| r | super :: queryExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod queryExpressionBody_impl { use super :: * ; mod part_0 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionParens (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_unionOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryPrimary (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionParens (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryPrimary (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_unionOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryPrimary (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionParens (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_queryExpressionBody < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , queryExpressionBody > { global . tracer . print_trace_start (& state , "queryExpressionBody") ; let result = (|| { let result = queryExpressionBody_impl :: parse (state , global) ? . map (| r | super :: queryExpressionBody { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod queryExpressionParens_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpression (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockingClauseList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionParens (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_queryExpressionParens < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , queryExpressionParens > { global . tracer . print_trace_start (& state , "queryExpressionParens") ; let result = (|| { let result = queryExpressionParens_impl :: parse (state , global) ? . map (| r | super :: queryExpressionParens { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod queryPrimary_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_querySpecification (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableValueConstructor (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_explicitTable (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_queryPrimary < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , queryPrimary > { global . tracer . print_trace_start (& state , "queryPrimary") ; let result = (|| { let result = queryPrimary_impl :: parse (state , global) ? . map (| r | super :: queryPrimary { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod querySpecification_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut opts : Vec < selectOption > = Vec :: new () ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectOption (state , & mut * global) }) . map_inner (| result | vec ! [result]) { Ok (ParseOk { result : __result , state : new_state , .. }) => { opts . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : opts , state }) } pub type Parsed = Vec < selectOption > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SELECT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { result : mut opts , state } = part_1 :: parse (state , global) ? ; let ParseOk { result : selectItemList , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectItemList (state , & mut * global) }) ? ; let ParseOk { result : into , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_intoClause (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fromClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whereClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_groupByClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_havingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : Parsed { opts , selectItemList , into , } , state }) } pub struct Parsed { pub opts : Vec < selectOption > , pub selectItemList : selectItemList , pub into : Option < intoClause > , } } # [inline] pub (super) fn parse_querySpecification < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , querySpecification > { global . tracer . print_trace_start (& state , "querySpecification") ; let result = (|| { let result = querySpecification_impl :: parse (state , global) ? . map (| r | super :: querySpecification { opts : r . opts , selectItemList : r . selectItemList , into : r . into , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod subquery_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_queryExpressionParens (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_subquery < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , subquery > { global . tracer . print_trace_start (& state , "subquery") ; let result = (|| { let result = subquery_impl :: parse (state , global) ? . map (| r | super :: subquery { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod querySpecOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISTINCT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STRAIGHT_JOIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HIGH_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_SMALL_RESULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_BIG_RESULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_BUFFER_RESULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_CALC_FOUND_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_querySpecOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , querySpecOption > { global . tracer . print_trace_start (& state , "querySpecOption") ; let result = (|| { let result = querySpecOption_impl :: parse (state , global) ? . map (| r | super :: querySpecOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod limitClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIMIT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitOptions (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_limitClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , limitClause > { global . tracer . print_trace_start (& state , "limitClause") ; let result = (|| { let result = limitClause_impl :: parse (state , global) ? . map (| r | super :: limitClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod simpleLimitClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIMIT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_simpleLimitClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , simpleLimitClause > { global . tracer . print_trace_start (& state , "simpleLimitClause") ; let result = (|| { let result = simpleLimitClause_impl :: parse (state , global) ? . map (| r | super :: simpleLimitClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod limitOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OFFSET_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_limitOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , limitOptions > { global . tracer . print_trace_start (& state , "limitOptions") ; let result = (|| { let result = limitOptions_impl :: parse (state , global) ? . map (| r | super :: limitOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod limitOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARAM_MARKER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ULONGLONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_limitOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , limitOption > { global . tracer . print_trace_start (& state , "limitOption") ; let result = (|| { let result = limitOption_impl :: parse (state , global) ? . map (| r | super :: limitOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod intoClause_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OUTFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldsClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_linesClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DUMPFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userVariable (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userVariable (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_intoClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , intoClause > { global . tracer . print_trace_start (& state , "intoClause") ; let result = (|| { let result = intoClause_impl :: parse (state , global) ? . map (| r | super :: intoClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod procedureAnalyseClause_impl { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCEDURE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANALYSE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_procedureAnalyseClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , procedureAnalyseClause > { global . tracer . print_trace_start (& state , "procedureAnalyseClause") ; let result = (|| { let result = procedureAnalyseClause_impl :: parse (state , global) ? . map (| r | super :: procedureAnalyseClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod havingClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HAVING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_havingClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , havingClause > { global . tracer . print_trace_start (& state , "havingClause") ; let result = (|| { let result = havingClause_impl :: parse (state , global) ? . map (| r | super :: havingClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowClause_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowDefinition (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WINDOW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowDefinition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowClause > { global . tracer . print_trace_start (& state , "windowClause") ; let result = (|| { let result = windowClause_impl :: parse (state , global) ? . map (| r | super :: windowClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowDefinition_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowSpec (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowDefinition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowDefinition > { global . tracer . print_trace_start (& state , "windowDefinition") ; let result = (|| { let result = windowDefinition_impl :: parse (state , global) ? . map (| r | super :: windowDefinition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowSpec_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowSpecDetails (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowSpec < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowSpec > { global . tracer . print_trace_start (& state , "windowSpec") ; let result = (|| { let result = windowSpec_impl :: parse (state , global) ? . map (| r | super :: windowSpec { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowSpecDetails_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowName (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFrameClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowSpecDetails < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowSpecDetails > { global . tracer . print_trace_start (& state , "windowSpecDetails") ; let result = (|| { let result = windowSpecDetails_impl :: parse (state , global) ? . map (| r | super :: windowSpecDetails { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowFrameClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFrameUnits (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFrameExtent (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFrameExclusion (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowFrameClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowFrameClause > { global . tracer . print_trace_start (& state , "windowFrameClause") ; let result = (|| { let result = windowFrameClause_impl :: parse (state , global) ? . map (| r | super :: windowFrameClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowFrameUnits_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RANGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUPS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowFrameUnits < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowFrameUnits > { global . tracer . print_trace_start (& state , "windowFrameUnits") ; let result = (|| { let result = windowFrameUnits_impl :: parse (state , global) ? . map (| r | super :: windowFrameUnits { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowFrameExtent_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFrameStart (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFrameBetween (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowFrameExtent < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowFrameExtent > { global . tracer . print_trace_start (& state , "windowFrameExtent") ; let result = (|| { let result = windowFrameExtent_impl :: parse (state , global) ? . map (| r | super :: windowFrameExtent { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowFrameStart_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNBOUNDED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECEDING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulonglong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECEDING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARAM_MARKER (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECEDING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTERVAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_interval (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECEDING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURRENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowFrameStart < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowFrameStart > { global . tracer . print_trace_start (& state , "windowFrameStart") ; let result = (|| { let result = windowFrameStart_impl :: parse (state , global) ? . map (| r | super :: windowFrameStart { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowFrameBetween_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BETWEEN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFrameBound (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AND_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFrameBound (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowFrameBetween < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowFrameBetween > { global . tracer . print_trace_start (& state , "windowFrameBetween") ; let result = (|| { let result = windowFrameBetween_impl :: parse (state , global) ? . map (| r | super :: windowFrameBetween { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowFrameBound_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNBOUNDED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOLLOWING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulonglong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOLLOWING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARAM_MARKER (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOLLOWING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTERVAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_interval (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOLLOWING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFrameStart (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowFrameBound < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowFrameBound > { global . tracer . print_trace_start (& state , "windowFrameBound") ; let result = (|| { let result = windowFrameBound_impl :: parse (state , global) ? . map (| r | super :: windowFrameBound { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowFrameExclusion_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURRENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OTHERS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXCLUDE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowFrameExclusion < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowFrameExclusion > { global . tracer . print_trace_start (& state , "windowFrameExclusion") ; let result = (|| { let result = windowFrameExclusion_impl :: parse (state , global) ? . map (| r | super :: windowFrameExclusion { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod withClause_impl { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_commonTableExpression (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RECURSIVE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_commonTableExpression (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_withClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , withClause > { global . tracer . print_trace_start (& state , "withClause") ; let result = (|| { let result = withClause_impl :: parse (state , global) ? . map (| r | super :: withClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod commonTableExpression_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRefList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_subquery (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_commonTableExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , commonTableExpression > { global . tracer . print_trace_start (& state , "commonTableExpression") ; let result = (|| { let result = commonTableExpression_impl :: parse (state , global) ? . map (| r | super :: commonTableExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod groupByClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_olapOption (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_groupByClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , groupByClause > { global . tracer . print_trace_start (& state , "groupByClause") ; let result = (|| { let result = groupByClause_impl :: parse (state , global) ? . map (| r | super :: groupByClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod olapOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLLUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CUBE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_olapOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , olapOption > { global . tracer . print_trace_start (& state , "olapOption") ; let result = (|| { let result = olapOption_impl :: parse (state , global) ? . map (| r | super :: olapOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod orderClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ORDER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_orderClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , orderClause > { global . tracer . print_trace_start (& state , "orderClause") ; let result = (|| { let result = orderClause_impl :: parse (state , global) ? . map (| r | super :: orderClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod direction_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ASC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DESC_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_direction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , direction > { global . tracer . print_trace_start (& state , "direction") ; let result = (|| { let result = direction_impl :: parse (state , global) ? . map (| r | super :: direction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fromClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DUAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReferenceList (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_fromClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fromClause > { global . tracer . print_trace_start (& state , "fromClause") ; let result = (|| { let result = fromClause_impl :: parse (state , global) ? . map (| r | super :: fromClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableReferenceList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReference (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReference (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableReferenceList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableReferenceList > { global . tracer . print_trace_start (& state , "tableReferenceList") ; let result = (|| { let result = tableReferenceList_impl :: parse (state , global) ? . map (| r | super :: tableReferenceList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableValueConstructor_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_rowValueExplicit (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_rowValueExplicit (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableValueConstructor < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableValueConstructor > { global . tracer . print_trace_start (& state , "tableValueConstructor") ; let result = (|| { let result = tableValueConstructor_impl :: parse (state , global) ? . map (| r | super :: tableValueConstructor { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod explicitTable_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_explicitTable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , explicitTable > { global . tracer . print_trace_start (& state , "explicitTable") ; let result = (|| { let result = explicitTable_impl :: parse (state , global) ? . map (| r | super :: explicitTable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod rowValueExplicit_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_values (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_rowValueExplicit < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , rowValueExplicit > { global . tracer . print_trace_start (& state , "rowValueExplicit") ; let result = (|| { let result = rowValueExplicit_impl :: parse (state , global) ? . map (| r | super :: rowValueExplicit { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod selectOption_impl { use super :: * ; mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_STATEMENT_TIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_querySpecOption (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_NO_CACHE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_CACHE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_selectOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , selectOption > { global . tracer . print_trace_start (& state , "selectOption") ; let result = (|| { let result = selectOption_impl :: parse (state , global) ? . map (| r | super :: selectOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lockingClauseList_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockingClause (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_lockingClauseList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lockingClauseList > { global . tracer . print_trace_start (& state , "lockingClauseList") ; let result = (|| { let result = lockingClauseList_impl :: parse (state , global) ? . map (| r | super :: lockingClauseList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lockingClause_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OF_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAliasRefList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockStrengh (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockedRowAction (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHARE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MODE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_lockingClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lockingClause > { global . tracer . print_trace_start (& state , "lockingClause") ; let result = (|| { let result = lockingClause_impl :: parse (state , global) ? . map (| r | super :: lockingClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lockStrengh_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPDATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHARE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_lockStrengh < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lockStrengh > { global . tracer . print_trace_start (& state , "lockStrengh") ; let result = (|| { let result = lockStrengh_impl :: parse (state , global) ? . map (| r | super :: lockStrengh { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lockedRowAction_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SKIP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCKED_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOWAIT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_lockedRowAction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lockedRowAction > { global . tracer . print_trace_start (& state , "lockedRowAction") ; let result = (|| { let result = lockedRowAction_impl :: parse (state , global) ? . map (| r | super :: lockedRowAction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod selectItemList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectItem (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectItem (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_selectItemList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , selectItemList > { global . tracer . print_trace_start (& state , "selectItemList") ; let result = (|| { let result = selectItemList_impl :: parse (state , global) ? . map (| r | super :: selectItemList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod selectItem_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectAlias (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableWild (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_selectItem < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , selectItem > { global . tracer . print_trace_start (& state , "selectItem") ; let result = (|| { let result = selectItem_impl :: parse (state , global) ? . map (| r | super :: selectItem { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod selectAlias_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_selectAlias < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , selectAlias > { global . tracer . print_trace_start (& state , "selectAlias") ; let result = (|| { let result = selectAlias_impl :: parse (state , global) ? . map (| r | super :: selectAlias { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod whereClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WHERE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_whereClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , whereClause > { global . tracer . print_trace_start (& state , "whereClause") ; let result = (|| { let result = whereClause_impl :: parse (state , global) ? . map (| r | super :: whereClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableReference_impl { use super :: * ; mod part_0 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_CURLY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OJ_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_escapedTableReference (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_CURLY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableFactor (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_joinedTable (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableReference > { global . tracer . print_trace_start (& state , "tableReference") ; let result = (|| { let result = tableReference_impl :: parse (state , global) ? . map (| r | super :: tableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod escapedTableReference_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_joinedTable (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableFactor (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_escapedTableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , escapedTableReference > { global . tracer . print_trace_start (& state , "escapedTableReference") ; let result = (|| { let result = escapedTableReference_impl :: parse (state , global) ? . map (| r | super :: escapedTableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod joinedTable_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_innerJoinType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReference (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_outerJoinType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReference (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_naturalJoinType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableFactor (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_joinedTable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , joinedTable > { global . tracer . print_trace_start (& state , "joinedTable") ; let result = (|| { let result = joinedTable_impl :: parse (state , global) ? . map (| r | super :: joinedTable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod naturalJoinType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NATURAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INNER_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JOIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NATURAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEFT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RIGHT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OUTER_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JOIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_naturalJoinType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , naturalJoinType > { global . tracer . print_trace_start (& state , "naturalJoinType") ; let result = (|| { let result = naturalJoinType_impl :: parse (state , global) ? . map (| r | super :: naturalJoinType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod innerJoinType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INNER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CROSS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JOIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STRAIGHT_JOIN_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_innerJoinType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , innerJoinType > { global . tracer . print_trace_start (& state , "innerJoinType") ; let result = (|| { let result = innerJoinType_impl :: parse (state , global) ? . map (| r | super :: innerJoinType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod outerJoinType_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEFT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RIGHT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OUTER_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JOIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_outerJoinType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , outerJoinType > { global . tracer . print_trace_start (& state , "outerJoinType") ; let result = (|| { let result = outerJoinType_impl :: parse (state , global) ? . map (| r | super :: outerJoinType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableFactor_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_singleTable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_singleTableParens (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_derivedTable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReferenceListParens (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableFunction (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableFactor < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableFactor > { global . tracer . print_trace_start (& state , "tableFactor") ; let result = (|| { let result = tableFactor_impl :: parse (state , global) ? . map (| r | super :: tableFactor { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod singleTable_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_usePartition (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAlias (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexHintList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_singleTable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , singleTable > { global . tracer . print_trace_start (& state , "singleTable") ; let result = (|| { let result = singleTable_impl :: parse (state , global) ? . map (| r | super :: singleTable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod singleTableParens_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_singleTable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_singleTableParens (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_singleTableParens < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , singleTableParens > { global . tracer . print_trace_start (& state , "singleTableParens") ; let result = (|| { let result = singleTableParens_impl :: parse (state , global) ? . map (| r | super :: singleTableParens { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod derivedTable_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_subquery (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAlias (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRefList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LATERAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_subquery (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAlias (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRefList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_derivedTable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , derivedTable > { global . tracer . print_trace_start (& state , "derivedTable") ; let result = (|| { let result = derivedTable_impl :: parse (state , global) ? . map (| r | super :: derivedTable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableReferenceListParens_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReferenceList (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReferenceListParens (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableReferenceListParens < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableReferenceListParens > { global . tracer . print_trace_start (& state , "tableReferenceListParens") ; let result = (|| { let result = tableReferenceListParens_impl :: parse (state , global) ? . map (| r | super :: tableReferenceListParens { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableFunction_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JSON_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnsClause (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAlias (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableFunction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableFunction > { global . tracer . print_trace_start (& state , "tableFunction") ; let result = (|| { let result = tableFunction_impl :: parse (state , global) ? . map (| r | super :: tableFunction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod columnsClause_impl { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_jtColumn (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMNS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_jtColumn (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_columnsClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , columnsClause > { global . tracer . print_trace_start (& state , "columnsClause") ; let result = (|| { let result = columnsClause_impl :: parse (state , global) ? . map (| r | super :: columnsClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod jtColumn_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ORDINALITY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dataType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_collate (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXISTS_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PATH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_onEmptyOrError (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NESTED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PATH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnsClause (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_jtColumn < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , jtColumn > { global . tracer . print_trace_start (& state , "jtColumn") ; let result = (|| { let result = jtColumn_impl :: parse (state , global) ? . map (| r | super :: jtColumn { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod onEmptyOrError_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_onEmpty (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_onError (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_onError (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_onEmpty (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_onEmptyOrError < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , onEmptyOrError > { global . tracer . print_trace_start (& state , "onEmptyOrError") ; let result = (|| { let result = onEmptyOrError_impl :: parse (state , global) ? . map (| r | super :: onEmptyOrError { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod onEmpty_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_jtOnResponse (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EMPTY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_onEmpty < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , onEmpty > { global . tracer . print_trace_start (& state , "onEmpty") ; let result = (|| { let result = onEmpty_impl :: parse (state , global) ? . map (| r | super :: onEmpty { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod onError_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_jtOnResponse (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ERROR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_onError < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , onError > { global . tracer . print_trace_start (& state , "onError") ; let result = (|| { let result = onError_impl :: parse (state , global) ? . map (| r | super :: onError { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod jtOnResponse_impl { use super :: * ; mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ERROR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_jtOnResponse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , jtOnResponse > { global . tracer . print_trace_start (& state , "jtOnResponse") ; let result = (|| { let result = jtOnResponse_impl :: parse (state , global) ? . map (| r | super :: jtOnResponse { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod unionOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISTINCT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_unionOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , unionOption > { global . tracer . print_trace_start (& state , "unionOption") ; let result = (|| { let result = unionOption_impl :: parse (state , global) ? . map (| r | super :: unionOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableAlias_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableAlias < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableAlias > { global . tracer . print_trace_start (& state , "tableAlias") ; let result = (|| { let result = tableAlias_impl :: parse (state , global) ? . map (| r | super :: tableAlias { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexHintList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexHint (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexHint (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexHintList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexHintList > { global . tracer . print_trace_start (& state , "indexHintList") ; let result = (|| { let result = indexHintList_impl :: parse (state , global) ? . map (| r | super :: indexHintList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexHint_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexHintType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyOrIndex (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexHintClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyOrIndex (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexHintClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexHint < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexHint > { global . tracer . print_trace_start (& state , "indexHint") ; let result = (|| { let result = indexHint_impl :: parse (state , global) ? . map (| r | super :: indexHint { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexHintType_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FORCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexHintType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexHintType > { global . tracer . print_trace_start (& state , "indexHintType") ; let result = (|| { let result = indexHintType_impl :: parse (state , global) ? . map (| r | super :: indexHintType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyOrIndex_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyOrIndex < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyOrIndex > { global . tracer . print_trace_start (& state , "keyOrIndex") ; let result = (|| { let result = keyOrIndex_impl :: parse (state , global) ? . map (| r | super :: keyOrIndex { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod constraintKeyType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIMARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNIQUE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyOrIndex (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_constraintKeyType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , constraintKeyType > { global . tracer . print_trace_start (& state , "constraintKeyType") ; let result = (|| { let result = constraintKeyType_impl :: parse (state , global) ? . map (| r | super :: constraintKeyType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexHintClause_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ORDER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JOIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexHintClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexHintClause > { global . tracer . print_trace_start (& state , "indexHintClause") ; let result = (|| { let result = indexHintClause_impl :: parse (state , global) ? . map (| r | super :: indexHintClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexListElement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexListElement (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexList > { global . tracer . print_trace_start (& state , "indexList") ; let result = (|| { let result = indexList_impl :: parse (state , global) ? . map (| r | super :: indexList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexListElement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIMARY_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexListElement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexListElement > { global . tracer . print_trace_start (& state , "indexListElement") ; let result = (|| { let result = indexListElement_impl :: parse (state , global) ? . map (| r | super :: indexListElement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod updateStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_withClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPDATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOW_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableReferenceList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_updateList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whereClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleLimitClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_updateStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , updateStatement > { global . tracer . print_trace_start (& state , "updateStatement") ; let result = (|| { let result = updateStatement_impl :: parse (state , global) ? . map (| r | super :: updateStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod transactionOrLockingStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_transactionStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_savepointStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_xaStatement (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_transactionOrLockingStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , transactionOrLockingStatement > { global . tracer . print_trace_start (& state , "transactionOrLockingStatement") ; let result = (|| { let result = transactionOrLockingStatement_impl :: parse (state , global) ? . map (| r | super :: transactionOrLockingStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod transactionStatement_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_transactionCharacteristic (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_START_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRANSACTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AND_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELEASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMIT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WORK_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_transactionStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , transactionStatement > { global . tracer . print_trace_start (& state , "transactionStatement") ; let result = (|| { let result = transactionStatement_impl :: parse (state , global) ? . map (| r | super :: transactionStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod beginWork_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BEGIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WORK_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_beginWork < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , beginWork > { global . tracer . print_trace_start (& state , "beginWork") ; let result = (|| { let result = beginWork_impl :: parse (state , global) ? . map (| r | super :: beginWork { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod transactionCharacteristic_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSISTENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SNAPSHOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WRITE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ONLY_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_transactionCharacteristic < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , transactionCharacteristic > { global . tracer . print_trace_start (& state , "transactionCharacteristic") ; let result = (|| { let result = transactionCharacteristic_impl :: parse (state , global) ? . map (| r | super :: transactionCharacteristic { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod savepointStatement_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SAVEPOINT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SAVEPOINT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AND_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELEASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLLBACK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WORK_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELEASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SAVEPOINT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_savepointStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , savepointStatement > { global . tracer . print_trace_start (& state , "savepointStatement") ; let result = (|| { let result = savepointStatement_impl :: parse (state , global) ? . map (| r | super :: savepointStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lockStatement_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockItem (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockItem (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTANCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BACKUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNLOCK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTANCE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_lockStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lockStatement > { global . tracer . print_trace_start (& state , "lockStatement") ; let result = (|| { let result = lockStatement_impl :: parse (state , global) ? . map (| r | super :: lockStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lockItem_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableAlias (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lockOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_lockItem < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lockItem > { global . tracer . print_trace_start (& state , "lockItem") ; let result = (|| { let result = lockItem_impl :: parse (state , global) ? . map (| r | super :: lockItem { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lockOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOW_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WRITE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_lockOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lockOption > { global . tracer . print_trace_start (& state , "lockOption") ; let result = (|| { let result = lockOption_impl :: parse (state , global) ? . map (| r | super :: lockOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod xaStatement_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_START_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BEGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_xid (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JOIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESUME_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MIGRATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUSPEND_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_xid (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PREPARE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_xid (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ONE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PHASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMIT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_xid (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLLBACK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_xid (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RECOVER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_xaConvert (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_xaStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , xaStatement > { global . tracer . print_trace_start (& state , "xaStatement") ; let result = (|| { let result = xaStatement_impl :: parse (state , global) ? . map (| r | super :: xaStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod xaConvert_impl { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONVERT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XID_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline] pub (super) fn parse_xaConvert < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , xaConvert > { global . tracer . print_trace_start (& state , "xaConvert") ; let result = (|| { let result = xaConvert_impl :: parse (state , global) ? . map (| r | super :: xaConvert { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod xid_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_xid < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , xid > { global . tracer . print_trace_start (& state , "xid") ; let result = (|| { let result = xid_impl :: parse (state , global) ? . map (| r | super :: xid { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod replicationStatement_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BEFORE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PURGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resetOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resetOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PERSIST_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_changeMaster (state , & mut * global) }) . discard_result ()) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_slave (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_changeReplication (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_replicationLoad (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_groupReplication (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_replicationStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , replicationStatement > { global . tracer . print_trace_start (& state , "replicationStatement") ; let result = (|| { let result = replicationStatement_impl :: parse (state , global) ? . map (| r | super :: replicationStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod resetOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_masterResetOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUERY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CACHE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLAVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_channel (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_resetOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , resetOption > { global . tracer . print_trace_start (& state , "resetOption") ; let result = (|| { let result = resetOption_impl :: parse (state , global) ? . map (| r | super :: resetOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod masterResetOptions_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulonglong_number (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_masterResetOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , masterResetOptions > { global . tracer . print_trace_start (& state , "masterResetOptions") ; let result = (|| { let result = masterResetOptions_impl :: parse (state , global) ? . map (| r | super :: masterResetOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod replicationLoad_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOAD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_replicationLoad < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , replicationLoad > { global . tracer . print_trace_start (& state , "replicationLoad") ; let result = (|| { let result = replicationLoad_impl :: parse (state , global) ? . map (| r | super :: replicationLoad { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod changeMaster_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_changeMasterOptions (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_channel (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_changeMaster < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , changeMaster > { global . tracer . print_trace_start (& state , "changeMaster") ; let result = (|| { let result = changeMaster_impl :: parse (state , global) ? . map (| r | super :: changeMaster { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod changeMasterOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_masterOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_masterOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_changeMasterOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , changeMasterOptions > { global . tracer . print_trace_start (& state , "changeMasterOptions") ; let result = (|| { let result = changeMasterOptions_impl :: parse (state , global) ? . map (| r | super :: changeMasterOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod masterOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_HOST_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NETWORK_NAMESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_BIND_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_PORT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_CONNECT_RETRY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_RETRY_COUNT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_DELAY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_9 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CAPATH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_12 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_TLS_VERSION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_13 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CERT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_14 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_TLS_CIPHERSUITES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_masterTlsCiphersuitesDef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_15 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CIPHER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_16 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_17 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_18 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CRL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_19 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CRLPATH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_20 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_PUBLIC_KEY_PATH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_21 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GET_MASTER_PUBLIC_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_22 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_HEARTBEAT_PERIOD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_23 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SERVER_IDS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_serverIdList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_24 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_COMPRESSION_ALGORITHM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_25 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_26 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_AUTO_POSITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_27 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIVILEGE_CHECKS_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_privilegeCheckDef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_28 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REQUIRE_ROW_FORMAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_29 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tablePrimaryKeyCheckDef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | choice_9 :: parse (state , global)) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | choice_12 :: parse (state , global)) . choice (| state | choice_13 :: parse (state , global)) . choice (| state | choice_14 :: parse (state , global)) . choice (| state | choice_15 :: parse (state , global)) . choice (| state | choice_16 :: parse (state , global)) . choice (| state | choice_17 :: parse (state , global)) . choice (| state | choice_18 :: parse (state , global)) . choice (| state | choice_19 :: parse (state , global)) . choice (| state | choice_20 :: parse (state , global)) . choice (| state | choice_21 :: parse (state , global)) . choice (| state | choice_22 :: parse (state , global)) . choice (| state | choice_23 :: parse (state , global)) . choice (| state | choice_24 :: parse (state , global)) . choice (| state | choice_25 :: parse (state , global)) . choice (| state | choice_26 :: parse (state , global)) . choice (| state | choice_27 :: parse (state , global)) . choice (| state | choice_28 :: parse (state , global)) . choice (| state | choice_29 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_masterFileDef (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_masterOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , masterOption > { global . tracer . print_trace_start (& state , "masterOption") ; let result = (|| { let result = masterOption_impl :: parse (state , global) ? . map (| r | super :: masterOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod privilegeCheckDef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userIdentifierOrText (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULL_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_privilegeCheckDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , privilegeCheckDef > { global . tracer . print_trace_start (& state , "privilegeCheckDef") ; let result = (|| { let result = privilegeCheckDef_impl :: parse (state , global) ? . map (| r | super :: privilegeCheckDef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tablePrimaryKeyCheckDef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STREAM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OFF_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tablePrimaryKeyCheckDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tablePrimaryKeyCheckDef > { global . tracer . print_trace_start (& state , "tablePrimaryKeyCheckDef") ; let result = (|| { let result = tablePrimaryKeyCheckDef_impl :: parse (state , global) ? . map (| r | super :: tablePrimaryKeyCheckDef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod masterTlsCiphersuitesDef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULL_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_masterTlsCiphersuitesDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , masterTlsCiphersuitesDef > { global . tracer . print_trace_start (& state , "masterTlsCiphersuitesDef") ; let result = (|| { let result = masterTlsCiphersuitesDef_impl :: parse (state , global) ? . map (| r | super :: masterTlsCiphersuitesDef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod masterFileDef_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_LOG_FILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_LOG_POS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulonglong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_LOG_FILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_LOG_POS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_masterFileDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , masterFileDef > { global . tracer . print_trace_start (& state , "masterFileDef") ; let result = (|| { let result = masterFileDef_impl :: parse (state , global) ? . map (| r | super :: masterFileDef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod serverIdList_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_serverIdList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , serverIdList > { global . tracer . print_trace_start (& state , "serverIdList") ; let result = (|| { let result = serverIdList_impl :: parse (state , global) ? . map (| r | super :: serverIdList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod changeReplication_impl { use super :: * ; mod part_4 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterDefinition (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FILTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterDefinition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_channel (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_changeReplication < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , changeReplication > { global . tracer . print_trace_start (& state , "changeReplication") ; let result = (|| { let result = changeReplication_impl :: parse (state , global) ? . map (| r | super :: changeReplication { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod filterDefinition_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_DO_DB_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterDbList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_IGNORE_DB_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterDbList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_DO_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterTableList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_IGNORE_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterTableList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_WILD_DO_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterStringList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_WILD_IGNORE_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterStringList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_REWRITE_DB_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterDbPairList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_filterDefinition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , filterDefinition > { global . tracer . print_trace_start (& state , "filterDefinition") ; let result = (|| { let result = filterDefinition_impl :: parse (state , global) ? . map (| r | super :: filterDefinition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod filterDbList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_filterDbList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , filterDbList > { global . tracer . print_trace_start (& state , "filterDbList") ; let result = (|| { let result = filterDbList_impl :: parse (state , global) ? . map (| r | super :: filterDbList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod filterTableList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterTableRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterTableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_filterTableList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , filterTableList > { global . tracer . print_trace_start (& state , "filterTableList") ; let result = (|| { let result = filterTableList_impl :: parse (state , global) ? . map (| r | super :: filterTableList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod filterStringList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterWildDbTableString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_filterWildDbTableString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_filterStringList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , filterStringList > { global . tracer . print_trace_start (& state , "filterStringList") ; let result = (|| { let result = filterStringList_impl :: parse (state , global) ? . map (| r | super :: filterStringList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod filterWildDbTableString_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_filterWildDbTableString < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , filterWildDbTableString > { global . tracer . print_trace_start (& state , "filterWildDbTableString") ; let result = (|| { let result = filterWildDbTableString_impl :: parse (state , global) ? . map (| r | super :: filterWildDbTableString { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod filterDbPairList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaIdentifierPair (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaIdentifierPair (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_filterDbPairList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , filterDbPairList > { global . tracer . print_trace_start (& state , "filterDbPairList") ; let result = (|| { let result = filterDbPairList_impl :: parse (state , global) ? . map (| r | super :: filterDbPairList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod slave_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNTIL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_slaveUntilOptions (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_START_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLAVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_slaveThreadOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_slaveConnectionOptions (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_channel (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STOP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLAVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_slaveThreadOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_channel (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_slave < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , slave > { global . tracer . print_trace_start (& state , "slave") ; let result = (|| { let result = slave_impl :: parse (state , global) ? . map (| r | super :: slave { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod slaveUntilOptions_impl { use super :: * ; mod part_0 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_BEFORE_GTIDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_AFTER_GTIDS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_masterFileDef (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_AFTER_MTS_GAPS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_masterFileDef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_slaveUntilOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , slaveUntilOptions > { global . tracer . print_trace_start (& state , "slaveUntilOptions") ; let result = (|| { let result = slaveUntilOptions_impl :: parse (state , global) ? . map (| r | super :: slaveUntilOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod slaveConnectionOptions_impl { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_AUTH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGIN_DIR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_slaveConnectionOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , slaveConnectionOptions > { global . tracer . print_trace_start (& state , "slaveConnectionOptions") ; let result = (|| { let result = slaveConnectionOptions_impl :: parse (state , global) ? . map (| r | super :: slaveConnectionOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod slaveThreadOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_slaveThreadOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_slaveThreadOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_slaveThreadOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , slaveThreadOptions > { global . tracer . print_trace_start (& state , "slaveThreadOptions") ; let result = (|| { let result = slaveThreadOptions_impl :: parse (state , global) ? . map (| r | super :: slaveThreadOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod slaveThreadOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_THREAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_THREAD_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_slaveThreadOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , slaveThreadOption > { global . tracer . print_trace_start (& state , "slaveThreadOption") ; let result = (|| { let result = slaveThreadOption_impl :: parse (state , global) ? . map (| r | super :: slaveThreadOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod groupReplication_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_START_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STOP_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_REPLICATION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_groupReplication < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , groupReplication > { global . tracer . print_trace_start (& state , "groupReplication") ; let result = (|| { let result = groupReplication_impl :: parse (state , global) ? . map (| r | super :: groupReplication { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod preparedStatement_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PREPARE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userVariable (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEALLOCATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PREPARE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_executeStatement (state , & mut * global) }) . discard_result ()) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_preparedStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , preparedStatement > { global . tracer . print_trace_start (& state , "preparedStatement") ; let result = (|| { let result = preparedStatement_impl :: parse (state , global) ? . map (| r | super :: preparedStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod executeStatement_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_executeVarList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXECUTE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_executeStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , executeStatement > { global . tracer . print_trace_start (& state , "executeStatement") ; let result = (|| { let result = executeStatement_impl :: parse (state , global) ? . map (| r | super :: executeStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod executeVarList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userVariable (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userVariable (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_executeVarList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , executeVarList > { global . tracer . print_trace_start (& state , "executeVarList") ; let result = (|| { let result = executeVarList_impl :: parse (state , global) ? . map (| r | super :: executeVarList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod cloneStatement_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIRECTORY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REMOTE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTANCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dataDirSSL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLONE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_cloneStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , cloneStatement > { global . tracer . print_trace_start (& state , "cloneStatement") ; let result = (|| { let result = cloneStatement_impl :: parse (state , global) ? . map (| r | super :: cloneStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dataDirSSL_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIRECTORY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ssl (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ssl (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_dataDirSSL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dataDirSSL > { global . tracer . print_trace_start (& state , "dataDirSSL") ; let result = (|| { let result = dataDirSSL_impl :: parse (state , global) ? . map (| r | super :: dataDirSSL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ssl_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REQUIRE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SSL_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_ssl < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ssl > { global . tracer . print_trace_start (& state , "ssl") ; let result = (|| { let result = ssl_impl :: parse (state , global) ? . map (| r | super :: ssl { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod accountManagementStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterUser (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUser (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropUser (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grant (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_renameUser (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_revoke (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_setRole (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_accountManagementStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , accountManagementStatement > { global . tracer . print_trace_start (& state , "accountManagementStatement") ; let result = (|| { let result = accountManagementStatement_impl :: parse (state , global) ? . map (| r | super :: accountManagementStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterUser_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterUserTail (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterUser < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterUser > { global . tracer . print_trace_start (& state , "alterUser") ; let result = (|| { let result = alterUser_impl :: parse (state , global) ? . map (| r | super :: alterUser { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterUserTail_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUserList (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterUserList (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUserTail (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_replacePassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_retainCurrentPassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_discardOldPassword (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RANDOM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_retainCurrentPassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FAILED_LOGIN_ATTEMPTS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_LOCK_TIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNBOUNDED_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterUserTail < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterUserTail > { global . tracer . print_trace_start (& state , "alterUserTail") ; let result = (|| { let result = alterUserTail_impl :: parse (state , global) ? . map (| r | super :: alterUserTail { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod userFunction_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_userFunction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , userFunction > { global . tracer . print_trace_start (& state , "userFunction") ; let result = (|| { let result = userFunction_impl :: parse (state , global) ? . map (| r | super :: userFunction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createUser_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CREATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifNotExists (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUserList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_defaultRoleClause (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUserTail (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createUser < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createUser > { global . tracer . print_trace_start (& state , "createUser") ; let result = (|| { let result = createUser_impl :: parse (state , global) ? . map (| r | super :: createUser { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createUserTail_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_accountLockPasswordExpireOptions (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_requireClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_connectOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createUserTail < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createUserTail > { global . tracer . print_trace_start (& state , "createUserTail") ; let result = (|| { let result = createUserTail_impl :: parse (state , global) ? . map (| r | super :: createUserTail { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod defaultRoleClause_impl { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline] pub (super) fn parse_defaultRoleClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , defaultRoleClause > { global . tracer . print_trace_start (& state , "defaultRoleClause") ; let result = (|| { let result = defaultRoleClause_impl :: parse (state , global) ? . map (| r | super :: defaultRoleClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod requireClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REQUIRE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_requireList (state , & mut * global) }) . discard_result ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SSL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_X509_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NONE_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_requireClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , requireClause > { global . tracer . print_trace_start (& state , "requireClause") ; let result = (|| { let result = requireClause_impl :: parse (state , global) ? . map (| r | super :: requireClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod connectOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_QUERIES_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_UPDATES_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_CONNECTIONS_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_USER_CONNECTIONS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_connectOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , connectOptions > { global . tracer . print_trace_start (& state , "connectOptions") ; let result = (|| { let result = connectOptions_impl :: parse (state , global) ? . map (| r | super :: connectOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod accountLockPasswordExpireOptions_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACCOUNT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNLOCK_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTERVAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEVER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPIRE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HISTORY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REUSE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTERVAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REQUIRE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURRENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIONAL_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_accountLockPasswordExpireOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , accountLockPasswordExpireOptions > { global . tracer . print_trace_start (& state , "accountLockPasswordExpireOptions") ; let result = (|| { let result = accountLockPasswordExpireOptions_impl :: parse (state , global) ? . map (| r | super :: accountLockPasswordExpireOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropUser_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropUser < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropUser > { global . tracer . print_trace_start (& state , "dropUser") ; let result = (|| { let result = dropUser_impl :: parse (state , global) ? . map (| r | super :: dropUser { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod grant_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADMIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrPrivilegesList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_0 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIVILEGES_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrPrivilegesList (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_aclType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grantIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grantTargetList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_versionedRequireClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grantOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grantAs (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROXY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grantTargetList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_grant < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , grant > { global . tracer . print_trace_start (& state , "grant") ; let result = (|| { let result = grant_impl :: parse (state , global) ? . map (| r | super :: grant { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod grantTargetList_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUserList (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userList (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_grantTargetList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , grantTargetList > { global . tracer . print_trace_start (& state , "grantTargetList") ; let result = (|| { let result = grantTargetList_impl :: parse (state , global) ? . map (| r | super :: grantTargetList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod grantOptions_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grantOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_grantOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , grantOptions > { global . tracer . print_trace_start (& state , "grantOptions") ; let result = (|| { let result = grantOptions_impl :: parse (state , global) ? . map (| r | super :: grantOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod exceptRoleList_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXCEPT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_exceptRoleList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , exceptRoleList > { global . tracer . print_trace_start (& state , "exceptRoleList") ; let result = (|| { let result = exceptRoleList_impl :: parse (state , global) ? . map (| r | super :: exceptRoleList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod withRoles_impl { use super :: * ; mod part_2 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exceptRoleList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_withRoles < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , withRoles > { global . tracer . print_trace_start (& state , "withRoles") ; let result = (|| { let result = withRoles_impl :: parse (state , global) ? . map (| r | super :: withRoles { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod grantAs_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_withRoles (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_grantAs < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , grantAs > { global . tracer . print_trace_start (& state , "grantAs") ; let result = (|| { let result = grantAs_impl :: parse (state , global) ? . map (| r | super :: grantAs { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod versionedRequireClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_requireClause (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_versionedRequireClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , versionedRequireClause > { global . tracer . print_trace_start (& state , "versionedRequireClause") ; let result = (|| { let result = versionedRequireClause_impl :: parse (state , global) ? . map (| r | super :: versionedRequireClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod renameUser_impl { use super :: * ; mod part_5 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RENAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_renameUser < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , renameUser > { global . tracer . print_trace_start (& state , "renameUser") ; let result = (|| { let result = renameUser_impl :: parse (state , global) ? . map (| r | super :: renameUser { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod revoke_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrPrivilegesList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrPrivilegesList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_onTypeTo (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_aclType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grantIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIVILEGES_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROXY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REVOKE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_revoke < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , revoke > { global . tracer . print_trace_start (& state , "revoke") ; let result = (|| { let result = revoke_impl :: parse (state , global) ? . map (| r | super :: revoke { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod onTypeTo_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_aclType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grantIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_aclType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_grantIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_onTypeTo < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , onTypeTo > { global . tracer . print_trace_start (& state , "onTypeTo") ; let result = (|| { let result = onTypeTo_impl :: parse (state , global) ? . map (| r | super :: onTypeTo { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod aclType_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FUNCTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCEDURE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_aclType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , aclType > { global . tracer . print_trace_start (& state , "aclType") ; let result = (|| { let result = aclType_impl :: parse (state , global) ? . map (| r | super :: aclType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod roleOrPrivilegesList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrPrivilege (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrPrivilege (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_roleOrPrivilegesList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , roleOrPrivilegesList > { global . tracer . print_trace_start (& state , "roleOrPrivilegesList") ; let result = (|| { let result = roleOrPrivilegesList_impl :: parse (state , global) ? . map (| r | super :: roleOrPrivilegesList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod roleOrPrivilege_impl { use super :: * ; mod choice_0 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleIdentifierOrText (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRefList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_SIGN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_TEXT_SUFFIX (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleIdentifierOrText (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SELECT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSERT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPDATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REFERENCES_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRefList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHOW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATABASES_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEMPORARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROUTINE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VIEW_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CREATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLIENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLAVE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHOW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VIEW_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_9 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROUTINE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CREATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELETE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USAGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXECUTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELOAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHUTDOWN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCESS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROXY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUPER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRIGGER_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | choice_9 :: parse (state , global)) . choice (| state | choice_10 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_roleOrPrivilege < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , roleOrPrivilege > { global . tracer . print_trace_start (& state , "roleOrPrivilege") ; let result = (|| { let result = roleOrPrivilege_impl :: parse (state , global) ? . map (| r | super :: roleOrPrivilege { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod grantIdentifier_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result ()) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_grantIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , grantIdentifier > { global . tracer . print_trace_start (& state , "grantIdentifier") ; let result = (|| { let result = grantIdentifier_impl :: parse (state , global) ? . map (| r | super :: grantIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod requireList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AND_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_requireListElement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_requireListElement (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_requireList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , requireList > { global . tracer . print_trace_start (& state , "requireList") ; let result = (|| { let result = requireList_impl :: parse (state , global) ? . map (| r | super :: requireList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod requireListElement_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CIPHER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ISSUER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBJECT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_requireListElement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , requireListElement > { global . tracer . print_trace_start (& state , "requireListElement") ; let result = (|| { let result = requireListElement_impl :: parse (state , global) ? . map (| r | super :: requireListElement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod grantOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_QUERIES_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_UPDATES_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_CONNECTIONS_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_USER_CONNECTIONS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_grantOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , grantOption > { global . tracer . print_trace_start (& state , "grantOption") ; let result = (|| { let result = grantOption_impl :: parse (state , global) ? . map (| r | super :: grantOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod setRole_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXCEPT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_setRole < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , setRole > { global . tracer . print_trace_start (& state , "setRole") ; let result = (|| { let result = setRole_impl :: parse (state , global) ? . map (| r | super :: setRole { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod roleList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_role (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_role (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_roleList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , roleList > { global . tracer . print_trace_start (& state , "roleList") ; let result = (|| { let result = roleList_impl :: parse (state , global) ? . map (| r | super :: roleList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod role_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_SIGN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_TEXT_SUFFIX (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleIdentifierOrText (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_role < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , role > { global . tracer . print_trace_start (& state , "role") ; let result = (|| { let result = role_impl :: parse (state , global) ? . map (| r | super :: role { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableAdministrationStatement_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANALYZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRefList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_histogram (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_checkOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRefList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECKSUM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRefList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUICK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENDED_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIMIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRefList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; mod part_4 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_repairType (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPAIR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRefList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableAdministrationStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableAdministrationStatement > { global . tracer . print_trace_start (& state , "tableAdministrationStatement") ; let result = (|| { let result = tableAdministrationStatement_impl :: parse (state , global) ? . map (| r | super :: tableAdministrationStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod histogram_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_4 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BUCKETS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPDATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HISTOGRAM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HISTOGRAM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_histogram < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , histogram > { global . tracer . print_trace_start (& state , "histogram") ; let result = (|| { let result = histogram_impl :: parse (state , global) ? . map (| r | super :: histogram { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod checkOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPGRADE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUICK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FAST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEDIUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENDED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANGED_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_checkOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , checkOption > { global . tracer . print_trace_start (& state , "checkOption") ; let result = (|| { let result = checkOption_impl :: parse (state , global) ? . map (| r | super :: checkOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod repairType_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUICK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENDED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USE_FRM_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_repairType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , repairType > { global . tracer . print_trace_start (& state , "repairType") ; let result = (|| { let result = repairType_impl :: parse (state , global) ? . map (| r | super :: repairType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod installUninstallStatment_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTALL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SONAME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTALL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPONENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteralList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNINSTALL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_pluginRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_componentRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNINSTALL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPONENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_componentRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_installUninstallStatment < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , installUninstallStatment > { global . tracer . print_trace_start (& state , "installUninstallStatment") ; let result = (|| { let result = installUninstallStatment_impl :: parse (state , global) ? . map (| r | super :: installUninstallStatment { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod setStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_startOptionValueList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_setStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , setStatement > { global . tracer . print_trace_start (& state , "setStatement") ; let result = (|| { let result = setStatement_impl :: parse (state , global) ? . map (| r | super :: setStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod startOptionValueList_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_optionValueNoOptionType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_optionValueListContinued (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRANSACTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_transactionCharacteristics (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_optionType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_startOptionValueListFollowingOptionType (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_3 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_replacePassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_retainCurrentPassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_replacePassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_retainCurrentPassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OLD_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RANDOM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_replacePassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_retainCurrentPassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_startOptionValueList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , startOptionValueList > { global . tracer . print_trace_start (& state , "startOptionValueList") ; let result = (|| { let result = startOptionValueList_impl :: parse (state , global) ? . map (| r | super :: startOptionValueList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod transactionCharacteristics_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_transactionAccessMode (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_isolationLevel (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_transactionAccessMode (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_isolationLevel (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_transactionCharacteristics < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , transactionCharacteristics > { global . tracer . print_trace_start (& state , "transactionCharacteristics") ; let result = (|| { let result = transactionCharacteristics_impl :: parse (state , global) ? . map (| r | super :: transactionCharacteristics { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod transactionAccessMode_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WRITE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ONLY_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_transactionAccessMode < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , transactionAccessMode > { global . tracer . print_trace_start (& state , "transactionAccessMode") ; let result = (|| { let result = transactionAccessMode_impl :: parse (state , global) ? . map (| r | super :: transactionAccessMode { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod isolationLevel_impl { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPEATABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMITTED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNCOMMITTED_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERIALIZABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ISOLATION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEVEL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_isolationLevel < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , isolationLevel > { global . tracer . print_trace_start (& state , "isolationLevel") ; let result = (|| { let result = isolationLevel_impl :: parse (state , global) ? . map (| r | super :: isolationLevel { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod optionValueListContinued_impl { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_optionValue (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_optionValueListContinued < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , optionValueListContinued > { global . tracer . print_trace_start (& state , "optionValueListContinued") ; let result = (|| { let result = optionValueListContinued_impl :: parse (state , global) ? . map (| r | super :: optionValueListContinued { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod optionValueNoOptionType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_internalVariableName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_setExprOrDefault (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userVariable (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_setSystemVariable (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_setExprOrDefault (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_collate (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NAMES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetClause (state , & mut * global) }) . discard_result ()) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_optionValueNoOptionType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , optionValueNoOptionType > { global . tracer . print_trace_start (& state , "optionValueNoOptionType") ; let result = (|| { let result = optionValueNoOptionType_impl :: parse (state , global) ? . map (| r | super :: optionValueNoOptionType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod optionValue_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_optionType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_internalVariableName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_setExprOrDefault (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_optionValueNoOptionType (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_optionValue < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , optionValue > { global . tracer . print_trace_start (& state , "optionValue") ; let result = (|| { let result = optionValue_impl :: parse (state , global) ? . map (| r | super :: optionValue { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod setSystemVariable_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_AT_SIGN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_setVarIdentType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_internalVariableName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_setSystemVariable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , setSystemVariable > { global . tracer . print_trace_start (& state , "setSystemVariable") ; let result = (|| { let result = setSystemVariable_impl :: parse (state , global) ? . map (| r | super :: setSystemVariable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod startOptionValueListFollowingOptionType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_optionValueFollowingOptionType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_optionValueListContinued (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRANSACTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_transactionCharacteristics (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_startOptionValueListFollowingOptionType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , startOptionValueListFollowingOptionType > { global . tracer . print_trace_start (& state , "startOptionValueListFollowingOptionType") ; let result = (|| { let result = startOptionValueListFollowingOptionType_impl :: parse (state , global) ? . map (| r | super :: startOptionValueListFollowingOptionType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod optionValueFollowingOptionType_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_internalVariableName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_setExprOrDefault (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_optionValueFollowingOptionType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , optionValueFollowingOptionType > { global . tracer . print_trace_start (& state , "optionValueFollowingOptionType") ; let result = (|| { let result = optionValueFollowingOptionType_impl :: parse (state , global) ? . map (| r | super :: optionValueFollowingOptionType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod setExprOrDefault_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SYSTEM_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_setExprOrDefault < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , setExprOrDefault > { global . tracer . print_trace_start (& state , "setExprOrDefault") ; let result = (|| { let result = setExprOrDefault_impl :: parse (state , global) ? . map (| r | super :: setExprOrDefault { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod showStatement_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATABASES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_showCommandType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inDb (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FULL_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRIGGERS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inDb (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENTS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inDb (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inDb (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inDb (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_engineRef (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MUTEX_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_9 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_showCommandType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMNS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inDb (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_nonBlocking (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_channel (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOSTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLAVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_12 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulonglong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINLOG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAYLOG_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENTS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_channel (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_13 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENDED_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEXES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEYS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fromOrIn (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inDb (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whereClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_14 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STORAGE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINES_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_15 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COUNT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WARNINGS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ERRORS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_16 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WARNINGS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_17 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ERRORS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_19 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_profileType (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_profileType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUERY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROFILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_limitClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_20 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_optionType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARIABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_21 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FULL_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCESSLIST_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_22 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charset (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_23 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLLATION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_26 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANTS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_27 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANTS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_28 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_29 { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATABASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifNotExists (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_eventRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FUNCTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_functionRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCEDURE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_procedureRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRIGGER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_triggerRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VIEW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CREATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_30 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCEDURE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_31 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FUNCTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeOrWhere (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_32 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCEDURE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CODE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_procedureRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_33 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FUNCTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CODE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_functionRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AUTHORS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGINS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | choice_9 :: parse (state , global)) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | choice_12 :: parse (state , global)) . choice (| state | choice_13 :: parse (state , global)) . choice (| state | choice_14 :: parse (state , global)) . choice (| state | choice_15 :: parse (state , global)) . choice (| state | choice_16 :: parse (state , global)) . choice (| state | choice_17 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROFILES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_19 :: parse (state , global)) . choice (| state | choice_20 :: parse (state , global)) . choice (| state | choice_21 :: parse (state , global)) . choice (| state | choice_22 :: parse (state , global)) . choice (| state | choice_23 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTRIBUTORS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIVILEGES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_26 :: parse (state , global)) . choice (| state | choice_27 :: parse (state , global)) . choice (| state | choice_28 :: parse (state , global)) . choice (| state | choice_29 :: parse (state , global)) . choice (| state | choice_30 :: parse (state , global)) . choice (| state | choice_31 :: parse (state , global)) . choice (| state | choice_32 :: parse (state , global)) . choice (| state | choice_33 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHOW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_showStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , showStatement > { global . tracer . print_trace_start (& state , "showStatement") ; let result = (|| { let result = showStatement_impl :: parse (state , global) ? . map (| r | super :: showStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod showCommandType_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENDED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FULL_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FULL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_showCommandType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , showCommandType > { global . tracer . print_trace_start (& state , "showCommandType") ; let result = (|| { let result = showCommandType_impl :: parse (state , global) ? . map (| r | super :: showCommandType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod nonBlocking_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NONBLOCKING_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline] pub (super) fn parse_nonBlocking < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , nonBlocking > { global . tracer . print_trace_start (& state , "nonBlocking") ; let result = (|| { let result = nonBlocking_impl :: parse (state , global) ? . map (| r | super :: nonBlocking { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fromOrIn_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_fromOrIn < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fromOrIn > { global . tracer . print_trace_start (& state , "fromOrIn") ; let result = (|| { let result = fromOrIn_impl :: parse (state , global) ? . map (| r | super :: fromOrIn { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod inDb_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fromOrIn (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_inDb < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , inDb > { global . tracer . print_trace_start (& state , "inDb") ; let result = (|| { let result = inDb_impl :: parse (state , global) ? . map (| r | super :: inDb { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod profileType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BLOCK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IO_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SWITCHES_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PAGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FAULTS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CPU_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IPC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEMORY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SOURCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SWAPS_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_profileType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , profileType > { global . tracer . print_trace_start (& state , "profileType") ; let result = (|| { let result = profileType_impl :: parse (state , global) ? . map (| r | super :: profileType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod otherAdministrativeStatement_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINLOG_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CACHE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyCacheListOrParts (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_2 { use super :: * ; mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_flushOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_flushOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_flushTables (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FLUSH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_noWriteToBinLog (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KILL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONNECTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUERY_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOAD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CACHE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_preloadTail (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHUTDOWN_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_otherAdministrativeStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , otherAdministrativeStatement > { global . tracer . print_trace_start (& state , "otherAdministrativeStatement") ; let result = (|| { let result = otherAdministrativeStatement_impl :: parse (state , global) ? . map (| r | super :: otherAdministrativeStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyCacheListOrParts_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyCacheList (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_assignToKeycachePartition (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyCacheListOrParts < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyCacheListOrParts > { global . tracer . print_trace_start (& state , "keyCacheListOrParts") ; let result = (|| { let result = keyCacheListOrParts_impl :: parse (state , global) ? . map (| r | super :: keyCacheListOrParts { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyCacheList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_assignToKeycache (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_assignToKeycache (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyCacheList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyCacheList > { global . tracer . print_trace_start (& state , "keyCacheList") ; let result = (|| { let result = keyCacheList_impl :: parse (state , global) ? . map (| r | super :: keyCacheList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod assignToKeycache_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_cacheKeyList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_assignToKeycache < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , assignToKeycache > { global . tracer . print_trace_start (& state , "assignToKeycache") ; let result = (|| { let result = assignToKeycache_impl :: parse (state , global) ? . map (| r | super :: assignToKeycache { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod assignToKeycachePartition_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_cacheKeyList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_assignToKeycachePartition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , assignToKeycachePartition > { global . tracer . print_trace_start (& state , "assignToKeycachePartition") ; let result = (|| { let result = assignToKeycachePartition_impl :: parse (state , global) ? . map (| r | super :: assignToKeycachePartition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod cacheKeyList_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyOrIndex (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyUsageList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_cacheKeyList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , cacheKeyList > { global . tracer . print_trace_start (& state , "cacheKeyList") ; let result = (|| { let result = cacheKeyList_impl :: parse (state , global) ? . map (| r | super :: cacheKeyList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyUsageElement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIMARY_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyUsageElement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyUsageElement > { global . tracer . print_trace_start (& state , "keyUsageElement") ; let result = (|| { let result = keyUsageElement_impl :: parse (state , global) ? . map (| r | super :: keyUsageElement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyUsageList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyUsageElement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyUsageElement (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyUsageList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyUsageList > { global . tracer . print_trace_start (& state , "keyUsageList") ; let result = (|| { let result = keyUsageList_impl :: parse (state , global) ? . map (| r | super :: keyUsageList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod flushOption_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_logType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_channel (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUERY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CACHE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DES_KEY_FILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOSTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIVILEGES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_RESOURCES_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIMIZER_COSTS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_flushOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , flushOption > { global . tracer . print_trace_start (& state , "flushOption") ; let result = (|| { let result = flushOption_impl :: parse (state , global) ? . map (| r | super :: flushOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod logType_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ERROR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GENERAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLOW_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_logType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , logType > { global . tracer . print_trace_start (& state , "logType") ; let result = (|| { let result = logType_impl :: parse (state , global) ? . map (| r | super :: logType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod flushTables_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCK_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_flushTablesOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_flushTables < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , flushTables > { global . tracer . print_trace_start (& state , "flushTables") ; let result = (|| { let result = flushTables_impl :: parse (state , global) ? . map (| r | super :: flushTables { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod flushTablesOptions_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPORT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCK_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_flushTablesOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , flushTablesOptions > { global . tracer . print_trace_start (& state , "flushTablesOptions") ; let result = (|| { let result = flushTablesOptions_impl :: parse (state , global) ? . map (| r | super :: flushTablesOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod preloadTail_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEAVES_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_adminPartition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_cacheKeyList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_preloadList (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_preloadTail < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , preloadTail > { global . tracer . print_trace_start (& state , "preloadTail") ; let result = (|| { let result = preloadTail_impl :: parse (state , global) ? . map (| r | super :: preloadTail { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod preloadList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_preloadKeys (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_preloadKeys (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_preloadList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , preloadList > { global . tracer . print_trace_start (& state , "preloadList") ; let result = (|| { let result = preloadList_impl :: parse (state , global) ? . map (| r | super :: preloadList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod preloadKeys_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEAVES_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_cacheKeyList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_preloadKeys < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , preloadKeys > { global . tracer . print_trace_start (& state , "preloadKeys") ; let result = (|| { let result = preloadKeys_impl :: parse (state , global) ? . map (| r | super :: preloadKeys { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod adminPartition_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_allOrPartitionNameList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_adminPartition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , adminPartition > { global . tracer . print_trace_start (& state , "adminPartition") ; let result = (|| { let result = adminPartition_impl :: parse (state , global) ? . map (| r | super :: adminPartition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod resourceGroupManagement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createResourceGroup (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterResourceGroup (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_setResourceGroup (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dropResourceGroup (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_resourceGroupManagement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , resourceGroupManagement > { global . tracer . print_trace_start (& state , "resourceGroupManagement") ; let result = (|| { let result = resourceGroupManagement_impl :: parse (state , global) ? . map (| r | super :: resourceGroupManagement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createResourceGroup_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CREATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESOURCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TYPE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SYSTEM_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resourceGroupVcpuList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resourceGroupPriority (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resourceGroupEnableDisable (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createResourceGroup < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createResourceGroup > { global . tracer . print_trace_start (& state , "createResourceGroup") ; let result = (|| { let result = createResourceGroup_impl :: parse (state , global) ? . map (| r | super :: createResourceGroup { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod resourceGroupVcpuList_impl { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_vcpuNumOrRange (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VCPU_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_vcpuNumOrRange (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_resourceGroupVcpuList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , resourceGroupVcpuList > { global . tracer . print_trace_start (& state , "resourceGroupVcpuList") ; let result = (|| { let result = resourceGroupVcpuList_impl :: parse (state , global) ? . map (| r | super :: resourceGroupVcpuList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod vcpuNumOrRange_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUS_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_vcpuNumOrRange < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , vcpuNumOrRange > { global . tracer . print_trace_start (& state , "vcpuNumOrRange") ; let result = (|| { let result = vcpuNumOrRange_impl :: parse (state , global) ? . map (| r | super :: vcpuNumOrRange { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod resourceGroupPriority_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_THREAD_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_resourceGroupPriority < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , resourceGroupPriority > { global . tracer . print_trace_start (& state , "resourceGroupPriority") ; let result = (|| { let result = resourceGroupPriority_impl :: parse (state , global) ? . map (| r | super :: resourceGroupPriority { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod resourceGroupEnableDisable_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_resourceGroupEnableDisable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , resourceGroupEnableDisable > { global . tracer . print_trace_start (& state , "resourceGroupEnableDisable") ; let result = (|| { let result = resourceGroupEnableDisable_impl :: parse (state , global) ? . map (| r | super :: resourceGroupEnableDisable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterResourceGroup_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESOURCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resourceGroupRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resourceGroupVcpuList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resourceGroupPriority (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resourceGroupEnableDisable (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FORCE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterResourceGroup < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterResourceGroup > { global . tracer . print_trace_start (& state , "alterResourceGroup") ; let result = (|| { let result = alterResourceGroup_impl :: parse (state , global) ? . map (| r | super :: alterResourceGroup { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod setResourceGroup_impl { use super :: * ; mod part_4 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_threadIdList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESOURCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_setResourceGroup < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , setResourceGroup > { global . tracer . print_trace_start (& state , "setResourceGroup") ; let result = (|| { let result = setResourceGroup_impl :: parse (state , global) ? . map (| r | super :: setResourceGroup { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod threadIdList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_threadIdList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , threadIdList > { global . tracer . print_trace_start (& state , "threadIdList") ; let result = (|| { let result = threadIdList_impl :: parse (state , global) ? . map (| r | super :: threadIdList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dropResourceGroup_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DROP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESOURCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_resourceGroupRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FORCE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dropResourceGroup < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dropResourceGroup > { global . tracer . print_trace_start (& state , "dropResourceGroup") ; let result = (|| { let result = dropResourceGroup_impl :: parse (state , global) ? . map (| r | super :: dropResourceGroup { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod utilityStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_describeStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_explainStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_helpCommand (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_useCommand (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_restartServer (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_utilityStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , utilityStatement > { global . tracer . print_trace_start (& state , "utilityStatement") ; let result = (|| { let result = utilityStatement_impl :: parse (state , global) ? . map (| r | super :: utilityStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod describeStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPLAIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DESCRIBE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DESC_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnRef (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_describeStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , describeStatement > { global . tracer . print_trace_start (& state , "describeStatement") ; let result = (|| { let result = describeStatement_impl :: parse (state , global) ? . map (| r | super :: describeStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod explainStatement_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FORMAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANALYZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FORMAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENDED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITIONS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANALYZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPLAIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DESCRIBE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DESC_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_explainableStatement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_explainStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , explainStatement > { global . tracer . print_trace_start (& state , "explainStatement") ; let result = (|| { let result = explainStatement_impl :: parse (state , global) ? . map (| r | super :: explainStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod explainableStatement_impl { use super :: * ; mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONNECTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectStatement (state , & mut * global) }) . discard_result ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_deleteStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_insertStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_replaceStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_updateStatement (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_explainableStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , explainableStatement > { global . tracer . print_trace_start (& state , "explainableStatement") ; let result = (|| { let result = explainableStatement_impl :: parse (state , global) ? . map (| r | super :: explainableStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod helpCommand_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HELP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_helpCommand < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , helpCommand > { global . tracer . print_trace_start (& state , "helpCommand") ; let result = (|| { let result = helpCommand_impl :: parse (state , global) ? . map (| r | super :: helpCommand { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod useCommand_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_useCommand < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , useCommand > { global . tracer . print_trace_start (& state , "useCommand") ; let result = (|| { let result = useCommand_impl :: parse (state , global) ? . map (| r | super :: useCommand { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod restartServer_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESTART_SYMBOL (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_restartServer < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , restartServer > { global . tracer . print_trace_start (& state , "restartServer") ; let result = (|| { let result = restartServer_impl :: parse (state , global) ? . map (| r | super :: restartServer { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod expr_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_notRule (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRUE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FALSE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNKNOWN_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_boolPri (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGICAL_AND_OPERATOR (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGICAL_OR_OPERATOR (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_expr < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , expr > { global . tracer . print_trace_start (& state , "expr") ; let result = (|| { let result = expr_impl :: parse (state , global) ? . map (| r | super :: expr { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod boolPri_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_boolPri (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_notRule (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULL_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_boolPri (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compOp (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_predicate (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_boolPri (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compOp (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_subquery (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_predicate (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_boolPri < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , boolPri > { global . tracer . print_trace_start (& state , "boolPri") ; let result = (|| { let result = boolPri_impl :: parse (state , global) ? . map (| r | super :: boolPri { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod compOp_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULL_SAFE_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GREATER_OR_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GREATER_THAN_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LESS_OR_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LESS_THAN_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_compOp < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , compOp > { global . tracer . print_trace_start (& state , "compOp") ; let result = (|| { let result = compOp_impl :: parse (state , global) ? . map (| r | super :: compOp { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod predicate_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_notRule (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_predicateOperations (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEMBER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OF_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SOUNDS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIKE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_predicate < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , predicate > { global . tracer . print_trace_start (& state , "predicate") ; let result = (|| { let result = predicate_impl :: parse (state , global) ? . map (| r | super :: predicate { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod predicateOperations_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_subquery (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BETWEEN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AND_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_predicate (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ESCAPE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIKE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REGEXP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_predicateOperations < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , predicateOperations > { global . tracer . print_trace_start (& state , "predicateOperations") ; let result = (|| { let result = predicateOperations_impl :: parse (state , global) ? . map (| r | super :: predicateOperations { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod bitExpr_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BITWISE_XOR_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIV_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MOD_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIV_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MOD_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUS_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUS_OPERATOR (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUS_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUS_OPERATOR (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTERVAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_interval (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHIFT_LEFT_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHIFT_RIGHT_OPERATOR (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BITWISE_AND_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BITWISE_OR_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_bitExpr < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , bitExpr > { global . tracer . print_trace_start (& state , "bitExpr") ; let result = (|| { let result = bitExpr_impl :: parse (state , global) ? . map (| r | super :: bitExpr { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod simpleExpr_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_variable (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_jsonOperator (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLLATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONCAT_PIPES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUS_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUS_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BITWISE_NOT_OPERATOR (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_12 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_not2Rule (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_13 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_14 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXISTS_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_subquery (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_15 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_CURLY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_CURLY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_16 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MATCH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identListArg (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AGAINST_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fulltextOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_17 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_18 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CAST_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_castType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_arrayCast (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_19 { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whenExpression (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_thenExpression (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_elseExpression (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_20 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONVERT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_castType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_21 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONVERT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_22 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_23 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_24 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTERVAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_interval (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUS_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_runtimeFunctionCall (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_functionCall (state , & mut * global) }) . discard_result ()) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_literal (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARAM_MARKER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sumExpr (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_groupingOperation (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowFunctionCall (state , & mut * global) }) . discard_result ()) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | choice_12 :: parse (state , global)) . choice (| state | choice_13 :: parse (state , global)) . choice (| state | choice_14 :: parse (state , global)) . choice (| state | choice_15 :: parse (state , global)) . choice (| state | choice_16 :: parse (state , global)) . choice (| state | choice_17 :: parse (state , global)) . choice (| state | choice_18 :: parse (state , global)) . choice (| state | choice_19 :: parse (state , global)) . choice (| state | choice_20 :: parse (state , global)) . choice (| state | choice_21 :: parse (state , global)) . choice (| state | choice_22 :: parse (state , global)) . choice (| state | choice_23 :: parse (state , global)) . choice (| state | choice_24 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_simpleExpr < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , simpleExpr > { global . tracer . print_trace_start (& state , "simpleExpr") ; let result = (|| { let result = simpleExpr_impl :: parse (state , global) ? . map (| r | super :: simpleExpr { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod arrayCast_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ARRAY_SYMBOL (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_arrayCast < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , arrayCast > { global . tracer . print_trace_start (& state , "arrayCast") ; let result = (|| { let result = arrayCast_impl :: parse (state , global) ? . map (| r | super :: arrayCast { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod jsonOperator_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JSON_SEPARATOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JSON_UNQUOTED_SEPARATOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_jsonOperator < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , jsonOperator > { global . tracer . print_trace_start (& state , "jsonOperator") ; let result = (|| { let result = jsonOperator_impl :: parse (state , global) ? . map (| r | super :: jsonOperator { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod sumExpr_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AVG_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISTINCT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BIT_AND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BIT_OR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BIT_XOR_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COUNT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISTINCT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result ()) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COUNT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISTINCT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISTINCT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARIANCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_9 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STDDEV_SAMP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VAR_SAMP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISTINCT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_12 { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SEPARATOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_CONCAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISTINCT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_5 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_jsonFunction (state , & mut * global) }) . discard_result ()) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | choice_9 :: parse (state , global)) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | choice_12 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_sumExpr < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , sumExpr > { global . tracer . print_trace_start (& state , "sumExpr") ; let result = (|| { let result = sumExpr_impl :: parse (state , global) ? . map (| r | super :: sumExpr { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod groupingOperation_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUPING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_groupingOperation < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , groupingOperation > { global . tracer . print_trace_start (& state , "groupingOperation") ; let result = (|| { let result = groupingOperation_impl :: parse (state , global) ? . map (| r | super :: groupingOperation { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowFunctionCall_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_NUMBER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RANK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DENSE_RANK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CUME_DIST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PERCENT_RANK_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parentheses (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NTILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExprWithParentheses (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LAG_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_leadLagInfo (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_nullTreatment (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIRST_VALUE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LAST_VALUE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_nullTreatment (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; mod part_6 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIRST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LAST_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NTH_VALUE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_6 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_nullTreatment (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowFunctionCall < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowFunctionCall > { global . tracer . print_trace_start (& state , "windowFunctionCall") ; let result = (|| { let result = windowFunctionCall_impl :: parse (state , global) ? . map (| r | super :: windowFunctionCall { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowingClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OVER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowName (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowSpec (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowingClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowingClause > { global . tracer . print_trace_start (& state , "windowingClause") ; let result = (|| { let result = windowingClause_impl :: parse (state , global) ? . map (| r | super :: windowingClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod leadLagInfo_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulonglong_number (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARAM_MARKER (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_leadLagInfo < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , leadLagInfo > { global . tracer . print_trace_start (& state , "leadLagInfo") ; let result = (|| { let result = leadLagInfo_impl :: parse (state , global) ? . map (| r | super :: leadLagInfo { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod nullTreatment_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESPECT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULLS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_nullTreatment < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , nullTreatment > { global . tracer . print_trace_start (& state , "nullTreatment") ; let result = (|| { let result = nullTreatment_impl :: parse (state , global) ? . map (| r | super :: nullTreatment { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod jsonFunction_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JSON_ARRAYAGG_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JSON_OBJECTAGG_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_inSumExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_windowingClause (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_jsonFunction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , jsonFunction > { global . tracer . print_trace_start (& state , "jsonFunction") ; let result = (|| { let result = jsonFunction_impl :: parse (state , global) ? . map (| r | super :: jsonFunction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod inSumExpr_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALL_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_inSumExpr < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , inSumExpr > { global . tracer . print_trace_start (& state , "inSumExpr") ; let result = (|| { let result = inSumExpr_impl :: parse (state , global) ? . map (| r | super :: inSumExpr { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identListArg_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identList (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_identListArg < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identListArg > { global . tracer . print_trace_start (& state , "identListArg") ; let result = (|| { let result = identListArg_impl :: parse (state , global) ? . map (| r | super :: identListArg { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_identList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identList > { global . tracer . print_trace_start (& state , "identList") ; let result = (|| { let result = identList_impl :: parse (state , global) ? . map (| r | super :: identList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fulltextOptions_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BOOLEAN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MODE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_4 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUERY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPANSION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NATURAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LANGUAGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MODE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUERY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPANSION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_fulltextOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fulltextOptions > { global . tracer . print_trace_start (& state , "fulltextOptions") ; let result = (|| { let result = fulltextOptions_impl :: parse (state , global) ? . map (| r | super :: fulltextOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod runtimeFunctionCall_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURRENT_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parentheses (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOUR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSERT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTERVAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEFT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUTE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_9 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MONTH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RIGHT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECOND_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_12 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_13 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_15 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_16 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_17 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_YEAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_18 { use super :: * ; mod part_4 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTERVAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_interval (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADDDATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBDATE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_19 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURDATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parentheses (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_20 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURTIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_timeFunctionParameters (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_21 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATE_ADD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATE_SUB_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTERVAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_interval (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_22 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTRACT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_interval (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_23 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GET_FORMAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dateTimeTtype (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_24 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_timeFunctionParameters (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_25 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_POSITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_27 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SYSDATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_timeFunctionParameters (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_28 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_ADD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_DIFF_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_intervalTimeStamp (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_29 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UTC_DATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parentheses (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_30 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UTC_TIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_timeFunctionParameters (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_31 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UTC_TIMESTAMP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_timeFunctionParameters (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_32 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ASCII_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_33 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHARSET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_34 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COALESCE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_35 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLLATION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_36 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATABASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_37 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IF_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_38 { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FORMAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_5 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_39 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MICROSECOND_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_40 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MOD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_41 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OLD_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_42 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_43 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUARTER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_44 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPEAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_45 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_46 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REVERSE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_47 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_COUNT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_48 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRUNCATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_49 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WEEK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_50 { use super :: * ; mod part_3 { use super :: * ; mod choice_0 { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_wsNumCodepoints (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_weightStringLevels (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_wsNumCodepoints (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WEIGHT_STRING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | choice_9 :: parse (state , global)) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | choice_12 :: parse (state , global)) . choice (| state | choice_13 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_trimFunction (state , & mut * global) }) . discard_result ()) . choice (| state | choice_15 :: parse (state , global)) . choice (| state | choice_16 :: parse (state , global)) . choice (| state | choice_17 :: parse (state , global)) . choice (| state | choice_18 :: parse (state , global)) . choice (| state | choice_19 :: parse (state , global)) . choice (| state | choice_20 :: parse (state , global)) . choice (| state | choice_21 :: parse (state , global)) . choice (| state | choice_22 :: parse (state , global)) . choice (| state | choice_23 :: parse (state , global)) . choice (| state | choice_24 :: parse (state , global)) . choice (| state | choice_25 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_substringFunction (state , & mut * global) }) . discard_result ()) . choice (| state | choice_27 :: parse (state , global)) . choice (| state | choice_28 :: parse (state , global)) . choice (| state | choice_29 :: parse (state , global)) . choice (| state | choice_30 :: parse (state , global)) . choice (| state | choice_31 :: parse (state , global)) . choice (| state | choice_32 :: parse (state , global)) . choice (| state | choice_33 :: parse (state , global)) . choice (| state | choice_34 :: parse (state , global)) . choice (| state | choice_35 :: parse (state , global)) . choice (| state | choice_36 :: parse (state , global)) . choice (| state | choice_37 :: parse (state , global)) . choice (| state | choice_38 :: parse (state , global)) . choice (| state | choice_39 :: parse (state , global)) . choice (| state | choice_40 :: parse (state , global)) . choice (| state | choice_41 :: parse (state , global)) . choice (| state | choice_42 :: parse (state , global)) . choice (| state | choice_43 :: parse (state , global)) . choice (| state | choice_44 :: parse (state , global)) . choice (| state | choice_45 :: parse (state , global)) . choice (| state | choice_46 :: parse (state , global)) . choice (| state | choice_47 :: parse (state , global)) . choice (| state | choice_48 :: parse (state , global)) . choice (| state | choice_49 :: parse (state , global)) . choice (| state | choice_50 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_geometryFunction (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_runtimeFunctionCall < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , runtimeFunctionCall > { global . tracer . print_trace_start (& state , "runtimeFunctionCall") ; let result = (|| { let result = runtimeFunctionCall_impl :: parse (state , global) ? . map (| r | super :: runtimeFunctionCall { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod geometryFunction_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTAINS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GEOMETRYCOLLECTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINESTRING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTILINESTRING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTIPOINT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTIPOLYGON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_POINT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_POLYGON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_geometryFunction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , geometryFunction > { global . tracer . print_trace_start (& state , "geometryFunction") ; let result = (|| { let result = geometryFunction_impl :: parse (state , global) ? . map (| r | super :: geometryFunction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod timeFunctionParameters_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fractionalPrecision (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_timeFunctionParameters < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , timeFunctionParameters > { global . tracer . print_trace_start (& state , "timeFunctionParameters") ; let result = (|| { let result = timeFunctionParameters_impl :: parse (state , global) ? . map (| r | super :: timeFunctionParameters { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fractionalPrecision_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_fractionalPrecision < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fractionalPrecision > { global . tracer . print_trace_start (& state , "fractionalPrecision") ; let result = (|| { let result = fractionalPrecision_impl :: parse (state , global) ? . map (| r | super :: fractionalPrecision { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod weightStringLevels_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUS_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_weightStringLevelListItem (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_weightStringLevelListItem (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEVEL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_weightStringLevels < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , weightStringLevels > { global . tracer . print_trace_start (& state , "weightStringLevels") ; let result = (|| { let result = weightStringLevels_impl :: parse (state , global) ? . map (| r | super :: weightStringLevels { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod weightStringLevelListItem_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ASC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DESC_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REVERSE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REVERSE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_weightStringLevelListItem < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , weightStringLevelListItem > { global . tracer . print_trace_start (& state , "weightStringLevelListItem") ; let result = (|| { let result = weightStringLevelListItem_impl :: parse (state , global) ? . map (| r | super :: weightStringLevelListItem { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dateTimeTtype_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATETIME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_dateTimeTtype < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dateTimeTtype > { global . tracer . print_trace_start (& state , "dateTimeTtype") ; let result = (|| { let result = dateTimeTtype_impl :: parse (state , global) ? . map (| r | super :: dateTimeTtype { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod trimFunction_impl { use super :: * ; mod part_2 { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEADING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRAILING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BOTH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRIM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_trimFunction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , trimFunction > { global . tracer . print_trace_start (& state , "trimFunction") ; let result = (|| { let result = trimFunction_impl :: parse (state , global) ? . map (| r | super :: trimFunction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod substringFunction_impl { use super :: * ; mod part_3 { use super :: * ; mod choice_0 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBSTRING_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_substringFunction < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , substringFunction > { global . tracer . print_trace_start (& state , "substringFunction") ; let result = (|| { let result = substringFunction_impl :: parse (state , global) ? . map (| r | super :: substringFunction { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod functionCall_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_pureIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_udfExprList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_functionCall < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , functionCall > { global . tracer . print_trace_start (& state , "functionCall") ; let result = (|| { let result = functionCall_impl :: parse (state , global) ? . map (| r | super :: functionCall { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod udfExprList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_udfExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_udfExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_udfExprList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , udfExprList > { global . tracer . print_trace_start (& state , "udfExprList") ; let result = (|| { let result = udfExprList_impl :: parse (state , global) ? . map (| r | super :: udfExprList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod udfExpr_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectAlias (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_udfExpr < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , udfExpr > { global . tracer . print_trace_start (& state , "udfExpr") ; let result = (|| { let result = udfExpr_impl :: parse (state , global) ? . map (| r | super :: udfExpr { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod variable_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userVariable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_systemVariable (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_variable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , variable > { global . tracer . print_trace_start (& state , "variable") ; let result = (|| { let result = variable_impl :: parse (state , global) ? . map (| r | super :: variable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod userVariable_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_SIGN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_TEXT_SUFFIX (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_userVariable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , userVariable > { global . tracer . print_trace_start (& state , "userVariable") ; let result = (|| { let result = userVariable_impl :: parse (state , global) ? . map (| r | super :: userVariable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod systemVariable_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_AT_SIGN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_varIdentType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_systemVariable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , systemVariable > { global . tracer . print_trace_start (& state , "systemVariable") ; let result = (|| { let result = systemVariable_impl :: parse (state , global) ? . map (| r | super :: systemVariable { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod internalVariableName_impl { use super :: * ; mod choice_0 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lValueIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_internalVariableName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , internalVariableName > { global . tracer . print_trace_start (& state , "internalVariableName") ; let result = (|| { let result = internalVariableName_impl :: parse (state , global) ? . map (| r | super :: internalVariableName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod whenExpression_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WHEN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_whenExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , whenExpression > { global . tracer . print_trace_start (& state , "whenExpression") ; let result = (|| { let result = whenExpression_impl :: parse (state , global) ? . map (| r | super :: whenExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod thenExpression_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_THEN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_thenExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , thenExpression > { global . tracer . print_trace_start (& state , "thenExpression") ; let result = (|| { let result = thenExpression_impl :: parse (state , global) ? . map (| r | super :: thenExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod elseExpression_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ELSE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_elseExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , elseExpression > { global . tracer . print_trace_start (& state , "elseExpression") ; let result = (|| { let result = elseExpression_impl :: parse (state , global) ? . map (| r | super :: elseExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod castType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_nchar (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SIGNED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNSIGNED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_typeDatetimePrecision (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATETIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_typeDatetimePrecision (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECIMAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_floatOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FLOAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_standardFloatOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JSON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_realType (state , & mut * global) }) . discard_result ()) . choice (| state | choice_11 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_castType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , castType > { global . tracer . print_trace_start (& state , "castType") ; let result = (|| { let result = castType_impl :: parse (state , global) ? . map (| r | super :: castType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod exprList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_exprList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , exprList > { global . tracer . print_trace_start (& state , "exprList") ; let result = (|| { let result = exprList_impl :: parse (state , global) ? . map (| r | super :: exprList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod charset_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHARSET_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_charset < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , charset > { global . tracer . print_trace_start (& state , "charset") ; let result = (|| { let result = charset_impl :: parse (state , global) ? . map (| r | super :: charset { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod notRule_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT2_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_notRule < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , notRule > { global . tracer . print_trace_start (& state , "notRule") ; let result = (|| { let result = notRule_impl :: parse (state , global) ? . map (| r | super :: notRule { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod not2Rule_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGICAL_NOT_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT2_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_not2Rule < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , not2Rule > { global . tracer . print_trace_start (& state , "not2Rule") ; let result = (|| { let result = not2Rule_impl :: parse (state , global) ? . map (| r | super :: not2Rule { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod interval_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_intervalTimeStamp (state , & mut * global) }) . discard_result ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECOND_MICROSECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUTE_MICROSECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUTE_SECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOUR_MICROSECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOUR_SECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOUR_MINUTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_MICROSECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_SECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_MINUTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_YEAR_MONTH_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_interval < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , interval > { global . tracer . print_trace_start (& state , "interval") ; let result = (|| { let result = interval_impl :: parse (state , global) ? . map (| r | super :: interval { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod intervalTimeStamp_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MICROSECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WEEK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MONTH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUARTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_YEAR_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_intervalTimeStamp < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , intervalTimeStamp > { global . tracer . print_trace_start (& state , "intervalTimeStamp") ; let result = (|| { let result = intervalTimeStamp_impl :: parse (state , global) ? . map (| r | super :: intervalTimeStamp { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod exprListWithParentheses_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_exprListWithParentheses < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , exprListWithParentheses > { global . tracer . print_trace_start (& state , "exprListWithParentheses") ; let result = (|| { let result = exprListWithParentheses_impl :: parse (state , global) ? . map (| r | super :: exprListWithParentheses { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod exprWithParentheses_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_exprWithParentheses < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , exprWithParentheses > { global . tracer . print_trace_start (& state , "exprWithParentheses") ; let result = (|| { let result = exprWithParentheses_impl :: parse (state , global) ? . map (| r | super :: exprWithParentheses { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod simpleExprWithParentheses_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_simpleExprWithParentheses < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , simpleExprWithParentheses > { global . tracer . print_trace_start (& state , "simpleExprWithParentheses") ; let result = (|| { let result = simpleExprWithParentheses_impl :: parse (state , global) ? . map (| r | super :: simpleExprWithParentheses { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod orderList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderExpression (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_orderExpression (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_orderList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , orderList > { global . tracer . print_trace_start (& state , "orderList") ; let result = (|| { let result = orderList_impl :: parse (state , global) ? . map (| r | super :: orderList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod orderExpression_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_direction (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_orderExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , orderExpression > { global . tracer . print_trace_start (& state , "orderExpression") ; let result = (|| { let result = orderExpression_impl :: parse (state , global) ? . map (| r | super :: orderExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod groupList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_groupingExpression (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_groupingExpression (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_groupList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , groupList > { global . tracer . print_trace_start (& state , "groupList") ; let result = (|| { let result = groupList_impl :: parse (state , global) ? . map (| r | super :: groupList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod groupingExpression_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_groupingExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , groupingExpression > { global . tracer . print_trace_start (& state , "groupingExpression") ; let result = (|| { let result = groupingExpression_impl :: parse (state , global) ? . map (| r | super :: groupingExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod channel_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANNEL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringNoLinebreak (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_channel < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , channel > { global . tracer . print_trace_start (& state , "channel") ; let result = (|| { let result = channel_impl :: parse (state , global) ? . map (| r | super :: channel { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod compoundStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_simpleStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_returnStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_caseStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labeledBlock (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_unlabeledBlock (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labeledControl (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_unlabeledControl (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_leaveStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_iterateStatement (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_cursorOpen (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_cursorFetch (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_cursorClose (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_compoundStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , compoundStatement > { global . tracer . print_trace_start (& state , "compoundStatement") ; let result = (|| { let result = compoundStatement_impl :: parse (state , global) ? . map (| r | super :: compoundStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod returnStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETURN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_returnStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , returnStatement > { global . tracer . print_trace_start (& state , "returnStatement") ; let result = (|| { let result = returnStatement_impl :: parse (state , global) ? . map (| r | super :: returnStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ifStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IF_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifBody (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IF_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_ifStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ifStatement > { global . tracer . print_trace_start (& state , "ifStatement") ; let result = (|| { let result = ifStatement_impl :: parse (state , global) ? . map (| r | super :: ifStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ifBody_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ELSEIF_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ifBody (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ELSE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatementList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_thenStatement (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_ifBody < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ifBody > { global . tracer . print_trace_start (& state , "ifBody") ; let result = (|| { let result = ifBody_impl :: parse (state , global) ? . map (| r | super :: ifBody { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod thenStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_THEN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatementList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_thenStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , thenStatement > { global . tracer . print_trace_start (& state , "thenStatement") ; let result = (|| { let result = thenStatement_impl :: parse (state , global) ? . map (| r | super :: thenStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod compoundStatementList_impl { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatement (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SEMICOLON_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_compoundStatementList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , compoundStatementList > { global . tracer . print_trace_start (& state , "compoundStatementList") ; let result = (|| { let result = compoundStatementList_impl :: parse (state , global) ? . map (| r | super :: compoundStatementList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod caseStatement_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whenExpression (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_thenStatement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_elseStatement (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_caseStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , caseStatement > { global . tracer . print_trace_start (& state , "caseStatement") ; let result = (|| { let result = caseStatement_impl :: parse (state , global) ? . map (| r | super :: caseStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod elseStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ELSE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatementList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_elseStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , elseStatement > { global . tracer . print_trace_start (& state , "elseStatement") ; let result = (|| { let result = elseStatement_impl :: parse (state , global) ? . map (| r | super :: elseStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod labeledBlock_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_label (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_beginEndBlock (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labelRef (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_labeledBlock < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , labeledBlock > { global . tracer . print_trace_start (& state , "labeledBlock") ; let result = (|| { let result = labeledBlock_impl :: parse (state , global) ? . map (| r | super :: labeledBlock { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod unlabeledBlock_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_beginEndBlock (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_unlabeledBlock < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , unlabeledBlock > { global . tracer . print_trace_start (& state , "unlabeledBlock") ; let result = (|| { let result = unlabeledBlock_impl :: parse (state , global) ? . map (| r | super :: unlabeledBlock { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod label_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labelIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLON_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_label < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , label > { global . tracer . print_trace_start (& state , "label") ; let result = (|| { let result = label_impl :: parse (state , global) ? . map (| r | super :: label { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod beginEndBlock_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BEGIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_spDeclarations (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatementList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_beginEndBlock < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , beginEndBlock > { global . tracer . print_trace_start (& state , "beginEndBlock") ; let result = (|| { let result = beginEndBlock_impl :: parse (state , global) ? . map (| r | super :: beginEndBlock { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod labeledControl_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_label (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_unlabeledControl (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labelRef (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_labeledControl < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , labeledControl > { global . tracer . print_trace_start (& state , "labeledControl") ; let result = (|| { let result = labeledControl_impl :: parse (state , global) ? . map (| r | super :: labeledControl { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod unlabeledControl_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_loopBlock (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whileDoBlock (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_repeatUntilBlock (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_unlabeledControl < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , unlabeledControl > { global . tracer . print_trace_start (& state , "unlabeledControl") ; let result = (|| { let result = unlabeledControl_impl :: parse (state , global) ? . map (| r | super :: unlabeledControl { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod loopBlock_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOOP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatementList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOOP_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_loopBlock < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , loopBlock > { global . tracer . print_trace_start (& state , "loopBlock") ; let result = (|| { let result = loopBlock_impl :: parse (state , global) ? . map (| r | super :: loopBlock { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod whileDoBlock_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WHILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatementList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WHILE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_whileDoBlock < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , whileDoBlock > { global . tracer . print_trace_start (& state , "whileDoBlock") ; let result = (|| { let result = whileDoBlock_impl :: parse (state , global) ? . map (| r | super :: whileDoBlock { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod repeatUntilBlock_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPEAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatementList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNTIL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPEAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_repeatUntilBlock < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , repeatUntilBlock > { global . tracer . print_trace_start (& state , "repeatUntilBlock") ; let result = (|| { let result = repeatUntilBlock_impl :: parse (state , global) ? . map (| r | super :: repeatUntilBlock { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod spDeclarations_impl { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_spDeclaration (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SEMICOLON_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_spDeclarations < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , spDeclarations > { global . tracer . print_trace_start (& state , "spDeclarations") ; let result = (|| { let result = spDeclarations_impl :: parse (state , global) ? . map (| r | super :: spDeclarations { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod spDeclaration_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_variableDeclaration (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_conditionDeclaration (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_handlerDeclaration (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_cursorDeclaration (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_spDeclaration < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , spDeclaration > { global . tracer . print_trace_start (& state , "spDeclaration") ; let result = (|| { let result = spDeclaration_impl :: parse (state , global) ? . map (| r | super :: spDeclaration { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod variableDeclaration_impl { use super :: * ; mod part_4 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECLARE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dataType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_collate (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_variableDeclaration < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , variableDeclaration > { global . tracer . print_trace_start (& state , "variableDeclaration") ; let result = (|| { let result = variableDeclaration_impl :: parse (state , global) ? . map (| r | super :: variableDeclaration { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod conditionDeclaration_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECLARE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONDITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_spCondition (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_conditionDeclaration < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , conditionDeclaration > { global . tracer . print_trace_start (& state , "conditionDeclaration") ; let result = (|| { let result = conditionDeclaration_impl :: parse (state , global) ? . map (| r | super :: conditionDeclaration { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod spCondition_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sqlstate (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_spCondition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , spCondition > { global . tracer . print_trace_start (& state , "spCondition") ; let result = (|| { let result = spCondition_impl :: parse (state , global) ? . map (| r | super :: spCondition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod sqlstate_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQLSTATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_sqlstate < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , sqlstate > { global . tracer . print_trace_start (& state , "sqlstate") ; let result = (|| { let result = sqlstate_impl :: parse (state , global) ? . map (| r | super :: sqlstate { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod handlerDeclaration_impl { use super :: * ; mod part_5 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_handlerCondition (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECLARE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTINUE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDO_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HANDLER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_handlerCondition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_5 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_compoundStatement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_handlerDeclaration < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , handlerDeclaration > { global . tracer . print_trace_start (& state , "handlerDeclaration") ; let result = (|| { let result = handlerDeclaration_impl :: parse (state , global) ? . map (| r | super :: handlerDeclaration { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod handlerCondition_impl { use super :: * ; mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_notRule (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOUND_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_spCondition (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQLWARNING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQLEXCEPTION_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_handlerCondition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , handlerCondition > { global . tracer . print_trace_start (& state , "handlerCondition") ; let result = (|| { let result = handlerCondition_impl :: parse (state , global) ? . map (| r | super :: handlerCondition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod cursorDeclaration_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECLARE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURSOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_selectStatement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_cursorDeclaration < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , cursorDeclaration > { global . tracer . print_trace_start (& state , "cursorDeclaration") ; let result = (|| { let result = cursorDeclaration_impl :: parse (state , global) ? . map (| r | super :: cursorDeclaration { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod iterateStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ITERATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labelRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_iterateStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , iterateStatement > { global . tracer . print_trace_start (& state , "iterateStatement") ; let result = (|| { let result = iterateStatement_impl :: parse (state , global) ? . map (| r | super :: iterateStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod leaveStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEAVE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labelRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_leaveStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , leaveStatement > { global . tracer . print_trace_start (& state , "leaveStatement") ; let result = (|| { let result = leaveStatement_impl :: parse (state , global) ? . map (| r | super :: leaveStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod getDiagnostics_impl { use super :: * ; mod part_3 { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_statementInformationItem (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_statementInformationItem (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_conditionInformationItem (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONDITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signalAllowedExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_conditionInformationItem (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURRENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STACKED_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIAGNOSTICS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_getDiagnostics < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , getDiagnostics > { global . tracer . print_trace_start (& state , "getDiagnostics") ; let result = (|| { let result = getDiagnostics_impl :: parse (state , global) ? . map (| r | super :: getDiagnostics { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod signalAllowedExpr_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_literal (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_variable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_signalAllowedExpr < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , signalAllowedExpr > { global . tracer . print_trace_start (& state , "signalAllowedExpr") ; let result = (|| { let result = signalAllowedExpr_impl :: parse (state , global) ? . map (| r | super :: signalAllowedExpr { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod statementInformationItem_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_variable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NUMBER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_COUNT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_statementInformationItem < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , statementInformationItem > { global . tracer . print_trace_start (& state , "statementInformationItem") ; let result = (|| { let result = statementInformationItem_impl :: parse (state , global) ? . map (| r | super :: statementInformationItem { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod conditionInformationItem_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_variable (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signalInformationItemName (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETURNED_SQLSTATE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_conditionInformationItem < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , conditionInformationItem > { global . tracer . print_trace_start (& state , "conditionInformationItem") ; let result = (|| { let result = conditionInformationItem_impl :: parse (state , global) ? . map (| r | super :: conditionInformationItem { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod signalInformationItemName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLASS_ORIGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBCLASS_ORIGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_CATALOG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_SCHEMA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CATALOG_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SCHEMA_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURSOR_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MESSAGE_TEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MYSQL_ERRNO_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_signalInformationItemName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , signalInformationItemName > { global . tracer . print_trace_start (& state , "signalInformationItemName") ; let result = (|| { let result = signalInformationItemName_impl :: parse (state , global) ? . map (| r | super :: signalInformationItemName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod signalStatement_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signalInformationItem (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signalInformationItem (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SIGNAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sqlstate (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_signalStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , signalStatement > { global . tracer . print_trace_start (& state , "signalStatement") ; let result = (|| { let result = signalStatement_impl :: parse (state , global) ? . map (| r | super :: signalStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod resignalStatement_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signalInformationItem (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signalInformationItem (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESIGNAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_sqlstate (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_resignalStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , resignalStatement > { global . tracer . print_trace_start (& state , "resignalStatement") ; let result = (|| { let result = resignalStatement_impl :: parse (state , global) ? . map (| r | super :: resignalStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod signalInformationItem_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signalInformationItemName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signalAllowedExpr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_signalInformationItem < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , signalInformationItem > { global . tracer . print_trace_start (& state , "signalInformationItem") ; let result = (|| { let result = signalInformationItem_impl :: parse (state , global) ? . map (| r | super :: signalInformationItem { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod cursorOpen_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_cursorOpen < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , cursorOpen > { global . tracer . print_trace_start (& state , "cursorOpen") ; let result = (|| { let result = cursorOpen_impl :: parse (state , global) ? . map (| r | super :: cursorOpen { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod cursorClose_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_cursorClose < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , cursorClose > { global . tracer . print_trace_start (& state , "cursorClose") ; let result = (|| { let result = cursorClose_impl :: parse (state , global) ? . map (| r | super :: cursorClose { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod cursorFetch_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEXT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FROM_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FETCH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INTO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_cursorFetch < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , cursorFetch > { global . tracer . print_trace_start (& state , "cursorFetch") ; let result = (|| { let result = cursorFetch_impl :: parse (state , global) ? . map (| r | super :: cursorFetch { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod schedule_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STARTS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_4 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENDS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVERY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_interval (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_schedule < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , schedule > { global . tracer . print_trace_start (& state , "schedule") ; let result = (|| { let result = schedule_impl :: parse (state , global) ? . map (| r | super :: schedule { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod columnDefinition_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldDefinition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_checkOrReferences (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_columnDefinition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , columnDefinition > { global . tracer . print_trace_start (& state , "columnDefinition") ; let result = (|| { let result = columnDefinition_impl :: parse (state , global) ? . map (| r | super :: columnDefinition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod checkOrReferences_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_checkConstraint (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_references (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_checkOrReferences < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , checkOrReferences > { global . tracer . print_trace_start (& state , "checkOrReferences") ; let result = (|| { let result = checkOrReferences_impl :: parse (state , global) ? . map (| r | super :: checkOrReferences { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod checkConstraint_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECK_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_checkConstraint < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , checkConstraint > { global . tracer . print_trace_start (& state , "checkConstraint") ; let result = (|| { let result = checkConstraint_impl :: parse (state , global) ? . map (| r | super :: checkConstraint { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod constraintEnforcement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENFORCED_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_constraintEnforcement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , constraintEnforcement > { global . tracer . print_trace_start (& state , "constraintEnforcement") ; let result = (|| { let result = constraintEnforcement_impl :: parse (state , global) ? . map (| r | super :: constraintEnforcement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableConstraintDef_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexNameAndType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyListVariants (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_4 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fulltextIndexOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FULLTEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyOrIndex (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexName (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyListVariants (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_4 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_spatialIndexOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SPATIAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyOrIndex (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexName (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyListVariants (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; mod part_0 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIMARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNIQUE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyOrIndex (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } mod part_3 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexNameAndType (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyListVariants (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOREIGN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexName (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_references (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_checkConstraint (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_constraintEnforcement (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_constraintName (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableConstraintDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableConstraintDef > { global . tracer . print_trace_start (& state , "tableConstraintDef") ; let result = (|| { let result = tableConstraintDef_impl :: parse (state , global) ? . map (| r | super :: tableConstraintDef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod constraintName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_constraintName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , constraintName > { global . tracer . print_trace_start (& state , "constraintName") ; let result = (|| { let result = constraintName_impl :: parse (state , global) ? . map (| r | super :: constraintName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fieldDefinition_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnAttribute (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GENERATED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALWAYS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_5 { use super :: * ; mod choice_0 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_gcolAttribute (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnAttribute (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_collate (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VIRTUAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STORED_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dataType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_fieldDefinition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fieldDefinition > { global . tracer . print_trace_start (& state , "fieldDefinition") ; let result = (|| { let result = fieldDefinition_impl :: parse (state , global) ? . map (| r | super :: fieldDefinition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod columnAttribute_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_nullLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_1 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_timeFunctionParameters (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_signedLiteral (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPDATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOW_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_timeFunctionParameters (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERIAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIMARY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNIQUE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_FORMAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnFormat (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STORAGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_storageMedia (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_12 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SRID_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulonglong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_13 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_constraintName (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_checkConstraint (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AUTO_INCREMENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_collate (state , & mut * global) }) . discard_result ()) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | choice_12 :: parse (state , global)) . choice (| state | choice_13 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_constraintEnforcement (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_columnAttribute < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , columnAttribute > { global . tracer . print_trace_start (& state , "columnAttribute") ; let result = (|| { let result = columnAttribute_impl :: parse (state , global) ? . map (| r | super :: columnAttribute { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod columnFormat_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIXED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DYNAMIC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_columnFormat < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , columnFormat > { global . tracer . print_trace_start (& state , "columnFormat") ; let result = (|| { let result = columnFormat_impl :: parse (state , global) ? . map (| r | super :: columnFormat { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod storageMedia_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEMORY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_storageMedia < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , storageMedia > { global . tracer . print_trace_start (& state , "storageMedia") ; let result = (|| { let result = storageMedia_impl :: parse (state , global) ? . map (| r | super :: storageMedia { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod gcolAttribute_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNIQUE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_notRule (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULL_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIMARY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_gcolAttribute < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , gcolAttribute > { global . tracer . print_trace_start (& state , "gcolAttribute") ; let result = (|| { let result = gcolAttribute_impl :: parse (state , global) ? . map (| r | super :: gcolAttribute { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod references_impl { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MATCH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FULL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTIAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SIMPLE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_4 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELETE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_deleteOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPDATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_deleteOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPDATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_deleteOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ON_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELETE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_deleteOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REFERENCES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierListWithParentheses (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_references < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , references > { global . tracer . print_trace_start (& state , "references") ; let result = (|| { let result = references_impl :: parse (state , global) ? . map (| r | super :: references { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod deleteOption_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_nullLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESTRICT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASCADE_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_deleteOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , deleteOption > { global . tracer . print_trace_start (& state , "deleteOption") ; let result = (|| { let result = deleteOption_impl :: parse (state , global) ? . map (| r | super :: deleteOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyList_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyPart (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyPart (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyList > { global . tracer . print_trace_start (& state , "keyList") ; let result = (|| { let result = keyList_impl :: parse (state , global) ? . map (| r | super :: keyList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyPart_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_direction (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyPart < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyPart > { global . tracer . print_trace_start (& state , "keyPart") ; let result = (|| { let result = keyPart_impl :: parse (state , global) ? . map (| r | super :: keyPart { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyListWithExpression_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyPartOrExpression (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyPartOrExpression (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyListWithExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyListWithExpression > { global . tracer . print_trace_start (& state , "keyListWithExpression") ; let result = (|| { let result = keyListWithExpression_impl :: parse (state , global) ? . map (| r | super :: keyListWithExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyPartOrExpression_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_exprWithParentheses (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_direction (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyPart (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyPartOrExpression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyPartOrExpression > { global . tracer . print_trace_start (& state , "keyPartOrExpression") ; let result = (|| { let result = keyPartOrExpression_impl :: parse (state , global) ? . map (| r | super :: keyPartOrExpression { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod keyListVariants_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyListWithExpression (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_keyList (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_keyListVariants < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , keyListVariants > { global . tracer . print_trace_start (& state , "keyListVariants") ; let result = (|| { let result = keyListVariants_impl :: parse (state , global) ? . map (| r | super :: keyListVariants { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexType_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BTREE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RTREE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HASH_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexType > { global . tracer . print_trace_start (& state , "indexType") ; let result = (|| { let result = indexType_impl :: parse (state , global) ? . map (| r | super :: indexType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_commonIndexOption (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexTypeClause (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexOption > { global . tracer . print_trace_start (& state , "indexOption") ; let result = (|| { let result = indexOption_impl :: parse (state , global) ? . map (| r | super :: indexOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod commonIndexOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_BLOCK_SIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_visibility (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_commonIndexOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , commonIndexOption > { global . tracer . print_trace_start (& state , "commonIndexOption") ; let result = (|| { let result = commonIndexOption_impl :: parse (state , global) ? . map (| r | super :: commonIndexOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod visibility_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VISIBLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INVISIBLE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_visibility < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , visibility > { global . tracer . print_trace_start (& state , "visibility") ; let result = (|| { let result = visibility_impl :: parse (state , global) ? . map (| r | super :: visibility { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexTypeClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TYPE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_indexType (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexTypeClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexTypeClause > { global . tracer . print_trace_start (& state , "indexTypeClause") ; let result = (|| { let result = indexTypeClause_impl :: parse (state , global) ? . map (| r | super :: indexTypeClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fulltextIndexOption_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARSER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_commonIndexOption (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_fulltextIndexOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fulltextIndexOption > { global . tracer . print_trace_start (& state , "fulltextIndexOption") ; let result = (|| { let result = fulltextIndexOption_impl :: parse (state , global) ? . map (| r | super :: fulltextIndexOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod spatialIndexOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_commonIndexOption (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_spatialIndexOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , spatialIndexOption > { global . tracer . print_trace_start (& state , "spatialIndexOption") ; let result = (|| { let result = spatialIndexOption_impl :: parse (state , global) ? . map (| r | super :: spatialIndexOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dataTypeDefinition_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dataType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EOF (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dataTypeDefinition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dataTypeDefinition > { global . tracer . print_trace_start (& state , "dataTypeDefinition") ; let result = (|| { let result = dataTypeDefinition_impl :: parse (state , global) ? . map (| r | super :: dataTypeDefinition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dataType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TINYINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SMALLINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEDIUMINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BIGINT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_0 { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECISION_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_precision (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FLOAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECIMAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NUMERIC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIXED_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_floatOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BIT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_nchar (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; mod part_0 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARYING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARCHAR_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_9 { use super :: * ; mod part_0 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NATIONAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARCHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NCHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARCHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NATIONAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARYING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NCHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARYING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NVARCHAR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARBINARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_YEAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldOptions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_13 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_typeDatetimePrecision (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_14 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_typeDatetimePrecision (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_15 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATETIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_typeDatetimePrecision (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_17 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BLOB_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_19 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONG_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARBINARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_20 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARYING_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARCHAR_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONG_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_21 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TINYTEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_22 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_23 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEDIUMTEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_24 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONGTEXT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_25 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENUM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_stringList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_26 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SET_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_stringList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetWithOptBinary (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BOOL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BOOLEAN_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | choice_9 :: parse (state , global)) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_13 :: parse (state , global)) . choice (| state | choice_14 :: parse (state , global)) . choice (| state | choice_15 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TINYBLOB_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_17 :: parse (state , global)) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEDIUMBLOB_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONGBLOB_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | choice_19 :: parse (state , global)) . choice (| state | choice_20 :: parse (state , global)) . choice (| state | choice_21 :: parse (state , global)) . choice (| state | choice_22 :: parse (state , global)) . choice (| state | choice_23 :: parse (state , global)) . choice (| state | choice_24 :: parse (state , global)) . choice (| state | choice_25 :: parse (state , global)) . choice (| state | choice_26 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERIAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JSON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GEOMETRY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GEOMETRYCOLLECTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_POINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTIPOINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINESTRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTILINESTRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_POLYGON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTIPOLYGON_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_dataType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dataType > { global . tracer . print_trace_start (& state , "dataType") ; let result = (|| { let result = dataType_impl :: parse (state , global) ? . map (| r | super :: dataType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod nchar_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NATIONAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NCHAR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_nchar < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , nchar > { global . tracer . print_trace_start (& state , "nchar") ; let result = (|| { let result = nchar_impl :: parse (state , global) ? . map (| r | super :: nchar { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod realType_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECISION_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_realType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , realType > { global . tracer . print_trace_start (& state , "realType") ; let result = (|| { let result = realType_impl :: parse (state , global) ? . map (| r | super :: realType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fieldLength_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulonglong_number (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECIMAL_NUMBER (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_fieldLength < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fieldLength > { global . tracer . print_trace_start (& state , "fieldLength") ; let result = (|| { let result = fieldLength_impl :: parse (state , global) ? . map (| r | super :: fieldLength { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fieldOptions_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SIGNED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNSIGNED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ZEROFILL_SYMBOL (state , & mut * global) }) . discard_result ()) . end () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_fieldOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fieldOptions > { global . tracer . print_trace_start (& state , "fieldOptions") ; let result = (|| { let result = fieldOptions_impl :: parse (state , global) ? . map (| r | super :: fieldOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod charsetWithOptBinary_impl { use super :: * ; mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charset (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charset (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ascii (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_unicode (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BYTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_charsetWithOptBinary < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , charsetWithOptBinary > { global . tracer . print_trace_start (& state , "charsetWithOptBinary") ; let result = (|| { let result = charsetWithOptBinary_impl :: parse (state , global) ? . map (| r | super :: charsetWithOptBinary { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ascii_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ASCII_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ASCII_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ascii < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ascii > { global . tracer . print_trace_start (& state , "ascii") ; let result = (|| { let result = ascii_impl :: parse (state , global) ? . map (| r | super :: ascii { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod unicode_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNICODE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNICODE_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_unicode < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , unicode > { global . tracer . print_trace_start (& state , "unicode") ; let result = (|| { let result = unicode_impl :: parse (state , global) ? . map (| r | super :: unicode { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod wsNumCodepoints_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_wsNumCodepoints < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , wsNumCodepoints > { global . tracer . print_trace_start (& state , "wsNumCodepoints") ; let result = (|| { let result = wsNumCodepoints_impl :: parse (state , global) ? . map (| r | super :: wsNumCodepoints { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod typeDatetimePrecision_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_typeDatetimePrecision < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , typeDatetimePrecision > { global . tracer . print_trace_start (& state , "typeDatetimePrecision") ; let result = (|| { let result = typeDatetimePrecision_impl :: parse (state , global) ? . map (| r | super :: typeDatetimePrecision { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod charsetName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_charsetName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , charsetName > { global . tracer . print_trace_start (& state , "charsetName") ; let result = (|| { let result = charsetName_impl :: parse (state , global) ? . map (| r | super :: charsetName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod collationName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINARY_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_collationName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , collationName > { global . tracer . print_trace_start (& state , "collationName") ; let result = (|| { let result = collationName_impl :: parse (state , global) ? . map (| r | super :: collationName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createTableOptions_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createTableOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createTableOption (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createTableOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createTableOptions > { global . tracer . print_trace_start (& state , "createTableOptions") ; let result = (|| { let result = createTableOptions_impl :: parse (state , global) ? . map (| r | super :: createTableOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createTableOptionsSpaceSeparated_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createTableOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createTableOptionsSpaceSeparated < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createTableOptionsSpaceSeparated > { global . tracer . print_trace_start (& state , "createTableOptionsSpaceSeparated") ; let result = (|| { let result = createTableOptionsSpaceSeparated_impl :: parse (state , global) ? . map (| r | super :: createTableOptionsSpaceSeparated { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createTableOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_engineRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_ENGINE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_equal (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_ROWS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulonglong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MIN_ROWS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulonglong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AVG_ROW_LENGTH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_6 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_7 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPRESSION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_8 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENCRYPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_9 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AUTO_INCREMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulonglong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_10 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PACK_KEYS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ternaryOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_11 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATS_AUTO_RECALC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATS_PERSISTENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATS_SAMPLE_PAGES_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ternaryOption (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_12 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECKSUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_CHECKSUM_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_13 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELAY_KEY_WRITE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_14 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_FORMAT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DYNAMIC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIXED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPRESSED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REDUNDANT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPACT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_15 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRefList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_18 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSERT_METHOD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIRST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LAST_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_19 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIRECTORY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_20 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIRECTORY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_21 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_22 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STORAGE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEMORY_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_23 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONNECTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_24 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_BLOCK_SIZE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . choice (| state | choice_6 :: parse (state , global)) . choice (| state | choice_7 :: parse (state , global)) . choice (| state | choice_8 :: parse (state , global)) . choice (| state | choice_9 :: parse (state , global)) . choice (| state | choice_10 :: parse (state , global)) . choice (| state | choice_11 :: parse (state , global)) . choice (| state | choice_12 :: parse (state , global)) . choice (| state | choice_13 :: parse (state , global)) . choice (| state | choice_14 :: parse (state , global)) . choice (| state | choice_15 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_defaultCharset (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_defaultCollation (state , & mut * global) }) . discard_result ()) . choice (| state | choice_18 :: parse (state , global)) . choice (| state | choice_19 :: parse (state , global)) . choice (| state | choice_20 :: parse (state , global)) . choice (| state | choice_21 :: parse (state , global)) . choice (| state | choice_22 :: parse (state , global)) . choice (| state | choice_23 :: parse (state , global)) . choice (| state | choice_24 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_createTableOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createTableOption > { global . tracer . print_trace_start (& state , "createTableOption") ; let result = (|| { let result = createTableOption_impl :: parse (state , global) ? . map (| r | super :: createTableOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ternaryOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ternaryOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ternaryOption > { global . tracer . print_trace_start (& state , "ternaryOption") ; let result = (|| { let result = ternaryOption_impl :: parse (state , global) ? . map (| r | super :: ternaryOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod defaultCollation_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLLATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_collationName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_defaultCollation < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , defaultCollation > { global . tracer . print_trace_start (& state , "defaultCollation") ; let result = (|| { let result = defaultCollation_impl :: parse (state , global) ? . map (| r | super :: defaultCollation { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod defaultEncryption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENCRYPTION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_defaultEncryption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , defaultEncryption > { global . tracer . print_trace_start (& state , "defaultEncryption") ; let result = (|| { let result = defaultEncryption_impl :: parse (state , global) ? . map (| r | super :: defaultEncryption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod defaultCharset_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charset (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_defaultCharset < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , defaultCharset > { global . tracer . print_trace_start (& state , "defaultCharset") ; let result = (|| { let result = defaultCharset_impl :: parse (state , global) ? . map (| r | super :: defaultCharset { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionClause_impl { use super :: * ; mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITIONS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionTypeDef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_subPartitions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionDefinitions (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionClause > { global . tracer . print_trace_start (& state , "partitionClause") ; let result = (|| { let result = partitionClause_impl :: parse (state , global) ? . map (| r | super :: partitionClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionTypeDef_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINEAR_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionKeyAlgorithm (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINEAR_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HASH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMNS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RANGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIST_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionTypeDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionTypeDef > { global . tracer . print_trace_start (& state , "partitionTypeDef") ; let result = (|| { let result = partitionTypeDef_impl :: parse (state , global) ? . map (| r | super :: partitionTypeDef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod subPartitions_impl { use super :: * ; mod part_3 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HASH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionKeyAlgorithm (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } mod part_4 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBPARTITIONS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBPARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINEAR_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_subPartitions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , subPartitions > { global . tracer . print_trace_start (& state , "subPartitions") ; let result = (|| { let result = subPartitions_impl :: parse (state , global) ? . map (| r | super :: subPartitions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionKeyAlgorithm_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALGORITHM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionKeyAlgorithm < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionKeyAlgorithm > { global . tracer . print_trace_start (& state , "partitionKeyAlgorithm") ; let result = (|| { let result = partitionKeyAlgorithm_impl :: parse (state , global) ? . map (| r | super :: partitionKeyAlgorithm { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionDefinitions_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionDefinition (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionDefinition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionDefinitions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionDefinitions > { global . tracer . print_trace_start (& state , "partitionDefinitions") ; let result = (|| { let result = partitionDefinitions_impl :: parse (state , global) ? . map (| r | super :: partitionDefinitions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionDefinition_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LESS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_THAN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionValueItemListParen (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAXVALUE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionValuesIn (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_3 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod part_4 { use super :: * ; mod optional { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_subpartitionDefinition (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_subpartitionDefinition (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionDefinition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionDefinition > { global . tracer . print_trace_start (& state , "partitionDefinition") ; let result = (|| { let result = partitionDefinition_impl :: parse (state , global) ? . map (| r | super :: partitionDefinition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionValuesIn_impl { use super :: * ; mod choice_1 { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionValueItemListParen (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionValueItemListParen (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionValueItemListParen (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionValuesIn < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionValuesIn > { global . tracer . print_trace_start (& state , "partitionValuesIn") ; let result = (|| { let result = partitionValuesIn_impl :: parse (state , global) ? . map (| r | super :: partitionValuesIn { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionOption_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STORAGE_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_engineRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NODEGROUP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MIN_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEX_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIRECTORY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . choice (| state | choice_5 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionOption > { global . tracer . print_trace_start (& state , "partitionOption") ; let result = (|| { let result = partitionOption_impl :: parse (state , global) ? . map (| r | super :: partitionOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod subpartitionDefinition_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionOption (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBPARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_subpartitionDefinition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , subpartitionDefinition > { global . tracer . print_trace_start (& state , "subpartitionDefinition") ; let result = (|| { let result = subpartitionDefinition_impl :: parse (state , global) ? . map (| r | super :: subpartitionDefinition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionValueItemListParen_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionValueItem (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_partitionValueItem (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionValueItemListParen < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionValueItemListParen > { global . tracer . print_trace_start (& state , "partitionValueItemListParen") ; let result = (|| { let result = partitionValueItemListParen_impl :: parse (state , global) ? . map (| r | super :: partitionValueItemListParen { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod partitionValueItem_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_bitExpr (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAXVALUE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_partitionValueItem < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , partitionValueItem > { global . tracer . print_trace_start (& state , "partitionValueItem") ; let result = (|| { let result = partitionValueItem_impl :: parse (state , global) ? . map (| r | super :: partitionValueItem { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod definerClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFINER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_definerClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , definerClause > { global . tracer . print_trace_start (& state , "definerClause") ; let result = (|| { let result = definerClause_impl :: parse (state , global) ? . map (| r | super :: definerClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ifExists_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IF_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXISTS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_ifExists < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ifExists > { global . tracer . print_trace_start (& state , "ifExists") ; let result = (|| { let result = ifExists_impl :: parse (state , global) ? . map (| r | super :: ifExists { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ifNotExists_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IF_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_notRule (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXISTS_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_ifNotExists < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ifNotExists > { global . tracer . print_trace_start (& state , "ifNotExists") ; let result = (|| { let result = ifNotExists_impl :: parse (state , global) ? . map (| r | super :: ifNotExists { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod procedureParameter_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OUT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INOUT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_functionParameter (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_procedureParameter < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , procedureParameter > { global . tracer . print_trace_start (& state , "procedureParameter") ; let result = (|| { let result = procedureParameter_impl :: parse (state , global) ? . map (| r | super :: procedureParameter { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod functionParameter_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parameterName (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_typeWithOptCollate (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_functionParameter < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , functionParameter > { global . tracer . print_trace_start (& state , "functionParameter") ; let result = (|| { let result = functionParameter_impl :: parse (state , global) ? . map (| r | super :: functionParameter { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod collate_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLLATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_collationName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_collate < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , collate > { global . tracer . print_trace_start (& state , "collate") ; let result = (|| { let result = collate_impl :: parse (state , global) ? . map (| r | super :: collate { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod typeWithOptCollate_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dataType (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_collate (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_typeWithOptCollate < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , typeWithOptCollate > { global . tracer . print_trace_start (& state , "typeWithOptCollate") ; let result = (|| { let result = typeWithOptCollate_impl :: parse (state , global) ? . map (| r | super :: typeWithOptCollate { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod schemaIdentifierPair_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_schemaIdentifierPair < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , schemaIdentifierPair > { global . tracer . print_trace_start (& state , "schemaIdentifierPair") ; let result = (|| { let result = schemaIdentifierPair_impl :: parse (state , global) ? . map (| r | super :: schemaIdentifierPair { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod viewRefList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_viewRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_viewRefList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , viewRefList > { global . tracer . print_trace_start (& state , "viewRefList") ; let result = (|| { let result = viewRefList_impl :: parse (state , global) ? . map (| r | super :: viewRefList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod updateList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_updateElement (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_updateElement (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_updateList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , updateList > { global . tracer . print_trace_start (& state , "updateList") ; let result = (|| { let result = updateList_impl :: parse (state , global) ? . map (| r | super :: updateList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod updateElement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_expr (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_updateElement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , updateElement > { global . tracer . print_trace_start (& state , "updateElement") ; let result = (|| { let result = updateElement_impl :: parse (state , global) ? . map (| r | super :: updateElement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod charsetClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charset (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_charsetName (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_charsetClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , charsetClause > { global . tracer . print_trace_start (& state , "charsetClause") ; let result = (|| { let result = charsetClause_impl :: parse (state , global) ? . map (| r | super :: charsetClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fieldsClause_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldTerm (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMNS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_fieldsClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fieldsClause > { global . tracer . print_trace_start (& state , "fieldsClause") ; let result = (|| { let result = fieldsClause_impl :: parse (state , global) ? . map (| r | super :: fieldsClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fieldTerm_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TERMINATED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIONALLY_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENCLOSED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ESCAPED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_fieldTerm < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fieldTerm > { global . tracer . print_trace_start (& state , "fieldTerm") ; let result = (|| { let result = fieldTerm_impl :: parse (state , global) ? . map (| r | super :: fieldTerm { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod linesClause_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lineTerm (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINES_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_linesClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , linesClause > { global . tracer . print_trace_start (& state , "linesClause") ; let result = (|| { let result = linesClause_impl :: parse (state , global) ? . map (| r | super :: linesClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lineTerm_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TERMINATED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STARTING_SYMBOL (state , & mut * global) }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_lineTerm < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lineTerm > { global . tracer . print_trace_start (& state , "lineTerm") ; let result = (|| { let result = lineTerm_impl :: parse (state , global) ? . map (| r | super :: lineTerm { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod userList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_userList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , userList > { global . tracer . print_trace_start (& state , "userList") ; let result = (|| { let result = userList_impl :: parse (state , global) ? . map (| r | super :: userList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createUserList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUserEntry (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_createUserEntry (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createUserList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createUserList > { global . tracer . print_trace_start (& state , "createUserList") ; let result = (|| { let result = createUserList_impl :: parse (state , global) ? . map (| r | super :: createUserList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterUserList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterUserEntry (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_alterUserEntry (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterUserList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterUserList > { global . tracer . print_trace_start (& state , "alterUserList") ; let result = (|| { let result = alterUserList_impl :: parse (state , global) ? . map (| r | super :: alterUserList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod createUserEntry_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringHash (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RANDOM_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_createUserEntry < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , createUserEntry > { global . tracer . print_trace_start (& state , "createUserEntry") ; let result = (|| { let result = createUserEntry_impl :: parse (state , global) ? . map (| r | super :: createUserEntry { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod alterUserEntry_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } mod part_3 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_retainCurrentPassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AS_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringHash (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_retainCurrentPassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITH_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIED_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_discardOldPassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_discardOldPassword (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , }))) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_user (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_alterUserEntry < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , alterUserEntry > { global . tracer . print_trace_start (& state , "alterUserEntry") ; let result = (|| { let result = alterUserEntry_impl :: parse (state , global) ? . map (| r | super :: alterUserEntry { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod retainCurrentPassword_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETAIN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURRENT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_retainCurrentPassword < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , retainCurrentPassword > { global . tracer . print_trace_start (& state , "retainCurrentPassword") ; let result = (|| { let result = retainCurrentPassword_impl :: parse (state , global) ? . map (| r | super :: retainCurrentPassword { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod discardOldPassword_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISCARD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OLD_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_discardOldPassword < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , discardOldPassword > { global . tracer . print_trace_start (& state , "discardOldPassword") ; let result = (|| { let result = discardOldPassword_impl :: parse (state , global) ? . map (| r | super :: discardOldPassword { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod replacePassword_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLACE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_replacePassword < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , replacePassword > { global . tracer . print_trace_start (& state , "replacePassword") ; let result = (|| { let result = replacePassword_impl :: parse (state , global) ? . map (| r | super :: replacePassword { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod userIdentifierOrText_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_SIGN_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_TEXT_SUFFIX (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_userIdentifierOrText < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , userIdentifierOrText > { global . tracer . print_trace_start (& state , "userIdentifierOrText") ; let result = (|| { let result = userIdentifierOrText_impl :: parse (state , global) ? . map (| r | super :: userIdentifierOrText { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod user_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURRENT_USER_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_parentheses (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_userIdentifierOrText (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_user < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , user > { global . tracer . print_trace_start (& state , "user") ; let result = (|| { let result = user_impl :: parse (state , global) ? . map (| r | super :: user { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod likeClause_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIKE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_likeClause < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , likeClause > { global . tracer . print_trace_start (& state , "likeClause") ; let result = (|| { let result = likeClause_impl :: parse (state , global) ? . map (| r | super :: likeClause { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod likeOrWhere_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_likeClause (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_whereClause (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_likeOrWhere < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , likeOrWhere > { global . tracer . print_trace_start (& state , "likeOrWhere") ; let result = (|| { let result = likeOrWhere_impl :: parse (state , global) ? . map (| r | super :: likeOrWhere { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod onlineOption_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ONLINE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OFFLINE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_onlineOption < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , onlineOption > { global . tracer . print_trace_start (& state , "onlineOption") ; let result = (|| { let result = onlineOption_impl :: parse (state , global) ? . map (| r | super :: onlineOption { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod noWriteToBinLog_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_WRITE_TO_BINLOG_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_noWriteToBinLog < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , noWriteToBinLog > { global . tracer . print_trace_start (& state , "noWriteToBinLog") ; let result = (|| { let result = noWriteToBinLog_impl :: parse (state , global) ? . map (| r | super :: noWriteToBinLog { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod usePartition_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierListWithParentheses (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_usePartition < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , usePartition > { global . tracer . print_trace_start (& state , "usePartition") ; let result = (|| { let result = usePartition_impl :: parse (state , global) ? . map (| r | super :: usePartition { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod fieldIdentifier_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_fieldIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , fieldIdentifier > { global . tracer . print_trace_start (& state , "fieldIdentifier") ; let result = (|| { let result = fieldIdentifier_impl :: parse (state , global) ? . map (| r | super :: fieldIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod columnName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldIdentifier (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_columnName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , columnName > { global . tracer . print_trace_start (& state , "columnName") ; let result = (|| { let result = columnName_impl :: parse (state , global) ? . map (| r | super :: columnName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod columnInternalRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_columnInternalRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , columnInternalRef > { global . tracer . print_trace_start (& state , "columnInternalRef") ; let result = (|| { let result = columnInternalRef_impl :: parse (state , global) ? . map (| r | super :: columnInternalRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod columnInternalRefList_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnInternalRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_columnInternalRefList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , columnInternalRefList > { global . tracer . print_trace_start (& state , "columnInternalRefList") ; let result = (|| { let result = columnInternalRefList_impl :: parse (state , global) ? . map (| r | super :: columnInternalRefList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod columnRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_columnRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , columnRef > { global . tracer . print_trace_start (& state , "columnRef") ; let result = (|| { let result = columnRef_impl :: parse (state , global) ? . map (| r | super :: columnRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod insertIdentifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_columnRef (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableWild (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_insertIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , insertIdentifier > { global . tracer . print_trace_start (& state , "insertIdentifier") ; let result = (|| { let result = insertIdentifier_impl :: parse (state , global) ? . map (| r | super :: insertIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexName > { global . tracer . print_trace_start (& state , "indexName") ; let result = (|| { let result = indexName_impl :: parse (state , global) ? . map (| r | super :: indexName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod indexRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_indexRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , indexRef > { global . tracer . print_trace_start (& state , "indexRef") ; let result = (|| { let result = indexRef_impl :: parse (state , global) ? . map (| r | super :: indexRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableWild_impl { use super :: * ; mod part_2 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableWild < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableWild > { global . tracer . print_trace_start (& state , "tableWild") ; let result = (|| { let result = tableWild_impl :: parse (state , global) ? . map (| r | super :: tableWild { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod schemaName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_schemaName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , schemaName > { global . tracer . print_trace_start (& state , "schemaName") ; let result = (|| { let result = schemaName_impl :: parse (state , global) ? . map (| r | super :: schemaName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod schemaRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_schemaRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , schemaRef > { global . tracer . print_trace_start (& state , "schemaRef") ; let result = (|| { let result = schemaRef_impl :: parse (state , global) ? . map (| r | super :: schemaRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod procedureName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_procedureName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , procedureName > { global . tracer . print_trace_start (& state , "procedureName") ; let result = (|| { let result = procedureName_impl :: parse (state , global) ? . map (| r | super :: procedureName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod procedureRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_procedureRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , procedureRef > { global . tracer . print_trace_start (& state , "procedureRef") ; let result = (|| { let result = procedureRef_impl :: parse (state , global) ? . map (| r | super :: procedureRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod functionName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_functionName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , functionName > { global . tracer . print_trace_start (& state , "functionName") ; let result = (|| { let result = functionName_impl :: parse (state , global) ? . map (| r | super :: functionName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod functionRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_functionRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , functionRef > { global . tracer . print_trace_start (& state , "functionRef") ; let result = (|| { let result = functionRef_impl :: parse (state , global) ? . map (| r | super :: functionRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod triggerName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_triggerName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , triggerName > { global . tracer . print_trace_start (& state , "triggerName") ; let result = (|| { let result = triggerName_impl :: parse (state , global) ? . map (| r | super :: triggerName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod triggerRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_triggerRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , triggerRef > { global . tracer . print_trace_start (& state , "triggerRef") ; let result = (|| { let result = triggerRef_impl :: parse (state , global) ? . map (| r | super :: triggerRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod viewName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_viewName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , viewName > { global . tracer . print_trace_start (& state , "viewName") ; let result = (|| { let result = viewName_impl :: parse (state , global) ? . map (| r | super :: viewName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod viewRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_viewRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , viewRef > { global . tracer . print_trace_start (& state , "viewRef") ; let result = (|| { let result = viewRef_impl :: parse (state , global) ? . map (| r | super :: viewRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tablespaceName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tablespaceName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tablespaceName > { global . tracer . print_trace_start (& state , "tablespaceName") ; let result = (|| { let result = tablespaceName_impl :: parse (state , global) ? . map (| r | super :: tablespaceName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tablespaceRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tablespaceRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tablespaceRef > { global . tracer . print_trace_start (& state , "tablespaceRef") ; let result = (|| { let result = tablespaceRef_impl :: parse (state , global) ? . map (| r | super :: tablespaceRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod logfileGroupName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_logfileGroupName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , logfileGroupName > { global . tracer . print_trace_start (& state , "logfileGroupName") ; let result = (|| { let result = logfileGroupName_impl :: parse (state , global) ? . map (| r | super :: logfileGroupName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod logfileGroupRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_logfileGroupRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , logfileGroupRef > { global . tracer . print_trace_start (& state , "logfileGroupRef") ; let result = (|| { let result = logfileGroupRef_impl :: parse (state , global) ? . map (| r | super :: logfileGroupRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod eventName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_eventName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , eventName > { global . tracer . print_trace_start (& state , "eventName") ; let result = (|| { let result = eventName_impl :: parse (state , global) ? . map (| r | super :: eventName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod eventRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_eventRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , eventRef > { global . tracer . print_trace_start (& state , "eventRef") ; let result = (|| { let result = eventRef_impl :: parse (state , global) ? . map (| r | super :: eventRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod udfName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_udfName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , udfName > { global . tracer . print_trace_start (& state , "udfName") ; let result = (|| { let result = udfName_impl :: parse (state , global) ? . map (| r | super :: udfName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod serverName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_serverName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , serverName > { global . tracer . print_trace_start (& state , "serverName") ; let result = (|| { let result = serverName_impl :: parse (state , global) ? . map (| r | super :: serverName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod serverRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_serverRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , serverRef > { global . tracer . print_trace_start (& state , "serverRef") ; let result = (|| { let result = serverRef_impl :: parse (state , global) ? . map (| r | super :: serverRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod engineRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textOrIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_engineRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , engineRef > { global . tracer . print_trace_start (& state , "engineRef") ; let result = (|| { let result = engineRef_impl :: parse (state , global) ? . map (| r | super :: engineRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableName > { global . tracer . print_trace_start (& state , "tableName") ; let result = (|| { let result = tableName_impl :: parse (state , global) ? . map (| r | super :: tableName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod filterTableRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_schemaRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_filterTableRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , filterTableRef > { global . tracer . print_trace_start (& state , "filterTableRef") ; let result = (|| { let result = filterTableRef_impl :: parse (state , global) ? . map (| r | super :: filterTableRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableRefWithWildcard_impl { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULT_OPERATOR (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableRefWithWildcard < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableRefWithWildcard > { global . tracer . print_trace_start (& state , "tableRefWithWildcard") ; let result = (|| { let result = tableRefWithWildcard_impl :: parse (state , global) ? . map (| r | super :: tableRefWithWildcard { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_qualifiedIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableRef > { global . tracer . print_trace_start (& state , "tableRef") ; let result = (|| { let result = tableRef_impl :: parse (state , global) ? . map (| r | super :: tableRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableRefList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRef (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableRefList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableRefList > { global . tracer . print_trace_start (& state , "tableRefList") ; let result = (|| { let result = tableRefList_impl :: parse (state , global) ? . map (| r | super :: tableRefList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod tableAliasRefList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRefWithWildcard (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_tableRefWithWildcard (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_tableAliasRefList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , tableAliasRefList > { global . tracer . print_trace_start (& state , "tableAliasRefList") ; let result = (|| { let result = tableAliasRefList_impl :: parse (state , global) ? . map (| r | super :: tableAliasRefList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod parameterName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_parameterName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , parameterName > { global . tracer . print_trace_start (& state , "parameterName") ; let result = (|| { let result = parameterName_impl :: parse (state , global) ? . map (| r | super :: parameterName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod labelIdentifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_pureIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labelKeyword (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_labelIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , labelIdentifier > { global . tracer . print_trace_start (& state , "labelIdentifier") ; let result = (|| { let result = labelIdentifier_impl :: parse (state , global) ? . map (| r | super :: labelIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod labelRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labelIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_labelRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , labelRef > { global . tracer . print_trace_start (& state , "labelRef") ; let result = (|| { let result = labelRef_impl :: parse (state , global) ? . map (| r | super :: labelRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod roleIdentifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_pureIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleKeyword (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_roleIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , roleIdentifier > { global . tracer . print_trace_start (& state , "roleIdentifier") ; let result = (|| { let result = roleIdentifier_impl :: parse (state , global) ? . map (| r | super :: roleIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod roleRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleIdentifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_roleRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , roleRef > { global . tracer . print_trace_start (& state , "roleRef") ; let result = (|| { let result = roleRef_impl :: parse (state , global) ? . map (| r | super :: roleRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod pluginRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_pluginRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , pluginRef > { global . tracer . print_trace_start (& state , "pluginRef") ; let result = (|| { let result = pluginRef_impl :: parse (state , global) ? . map (| r | super :: pluginRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod componentRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_componentRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , componentRef > { global . tracer . print_trace_start (& state , "componentRef") ; let result = (|| { let result = componentRef_impl :: parse (state , global) ? . map (| r | super :: componentRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod resourceGroupRef_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_resourceGroupRef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , resourceGroupRef > { global . tracer . print_trace_start (& state , "resourceGroupRef") ; let result = (|| { let result = resourceGroupRef_impl :: parse (state , global) ? . map (| r | super :: resourceGroupRef { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod windowName_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_windowName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , windowName > { global . tracer . print_trace_start (& state , "windowName") ; let result = (|| { let result = windowName_impl :: parse (state , global) ? . map (| r | super :: windowName { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod pureIdentifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BACK_TICK_QUOTED_ID (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_QUOTED_TEXT (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_pureIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , pureIdentifier > { global . tracer . print_trace_start (& state , "pureIdentifier") ; let result = (|| { let result = pureIdentifier_impl :: parse (state , global) ? . map (| r | super :: pureIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_pureIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeyword (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_identifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identifier > { global . tracer . print_trace_start (& state , "identifier") ; let result = (|| { let result = identifier_impl :: parse (state , global) ? . map (| r | super :: identifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identifierList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_identifierList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identifierList > { global . tracer . print_trace_start (& state , "identifierList") ; let result = (|| { let result = identifierList_impl :: parse (state , global) ? . map (| r | super :: identifierList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identifierListWithParentheses_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierList (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_identifierListWithParentheses < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identifierListWithParentheses > { global . tracer . print_trace_start (& state , "identifierListWithParentheses") ; let result = (|| { let result = identifierListWithParentheses_impl :: parse (state , global) ? . map (| r | super :: identifierListWithParentheses { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod qualifiedIdentifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_qualifiedIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , qualifiedIdentifier > { global . tracer . print_trace_start (& state , "qualifiedIdentifier") ; let result = (|| { let result = qualifiedIdentifier_impl :: parse (state , global) ? . map (| r | super :: qualifiedIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod simpleIdentifier_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_dotIdentifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_simpleIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , simpleIdentifier > { global . tracer . print_trace_start (& state , "simpleIdentifier") ; let result = (|| { let result = simpleIdentifier_impl :: parse (state , global) ? . map (| r | super :: simpleIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod dotIdentifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_dotIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , dotIdentifier > { global . tracer . print_trace_start (& state , "dotIdentifier") ; let result = (|| { let result = dotIdentifier_impl :: parse (state , global) ? . map (| r | super :: dotIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ulong_number_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HEX_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ULONGLONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECIMAL_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FLOAT_NUMBER (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ulong_number < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ulong_number > { global . tracer . print_trace_start (& state , "ulong_number") ; let result = (|| { let result = ulong_number_impl :: parse (state , global) ? . map (| r | super :: ulong_number { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod real_ulong_number_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HEX_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ULONGLONG_NUMBER (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_real_ulong_number < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , real_ulong_number > { global . tracer . print_trace_start (& state , "real_ulong_number") ; let result = (|| { let result = real_ulong_number_impl :: parse (state , global) ? . map (| r | super :: real_ulong_number { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ulonglong_number_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ULONGLONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECIMAL_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FLOAT_NUMBER (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ulonglong_number < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ulonglong_number > { global . tracer . print_trace_start (& state , "ulonglong_number") ; let result = (|| { let result = ulonglong_number_impl :: parse (state , global) ? . map (| r | super :: ulonglong_number { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod real_ulonglong_number_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HEX_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ULONGLONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONG_NUMBER (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_real_ulonglong_number < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , real_ulonglong_number > { global . tracer . print_trace_start (& state , "real_ulonglong_number") ; let result = (|| { let result = real_ulonglong_number_impl :: parse (state , global) ? . map (| r | super :: real_ulonglong_number { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod literal_impl { use super :: * ; mod choice_5 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDERSCORE_CHARSET (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HEX_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BIN_NUMBER (state , & mut * global) }) . discard_result ()) . end () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textLiteral (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_numLiteral (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_temporalLiteral (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_nullLiteral (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_boolLiteral (state , & mut * global) }) . discard_result ()) . choice (| state | choice_5 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_literal < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , literal > { global . tracer . print_trace_start (& state , "literal") ; let result = (|| { let result = literal_impl :: parse (state , global) ? . map (| r | super :: literal { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod signedLiteral_impl { use super :: * ; mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUS_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUS_OPERATOR (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ulong_number (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_literal (state , & mut * global) }) . discard_result ()) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_signedLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , signedLiteral > { global . tracer . print_trace_start (& state , "signedLiteral") ; let result = (|| { let result = signedLiteral_impl :: parse (state , global) ? . map (| r | super :: signedLiteral { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod stringList_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textString (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_stringList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , stringList > { global . tracer . print_trace_start (& state , "stringList") ; let result = (|| { let result = stringList_impl :: parse (state , global) ? . map (| r | super :: stringList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod textStringLiteral_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTED_TEXT (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_QUOTED_TEXT (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_textStringLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , textStringLiteral > { global . tracer . print_trace_start (& state , "textStringLiteral") ; let result = (|| { let result = textStringLiteral_impl :: parse (state , global) ? . map (| r | super :: textStringLiteral { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod textString_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HEX_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BIN_NUMBER (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_textString < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , textString > { global . tracer . print_trace_start (& state , "textString") ; let result = (|| { let result = textString_impl :: parse (state , global) ? . map (| r | super :: textString { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod textStringHash_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HEX_NUMBER (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_textStringHash < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , textStringHash > { global . tracer . print_trace_start (& state , "textStringHash") ; let result = (|| { let result = textStringHash_impl :: parse (state , global) ? . map (| r | super :: textStringHash { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod textLiteral_impl { use super :: * ; mod part_0 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDERSCORE_CHARSET (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NCHAR_TEXT (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_textLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , textLiteral > { global . tracer . print_trace_start (& state , "textLiteral") ; let result = (|| { let result = textLiteral_impl :: parse (state , global) ? . map (| r | super :: textLiteral { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod textStringNoLinebreak_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_textStringNoLinebreak < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , textStringNoLinebreak > { global . tracer . print_trace_start (& state , "textStringNoLinebreak") ; let result = (|| { let result = textStringNoLinebreak_impl :: parse (state , global) ? . map (| r | super :: textStringNoLinebreak { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod textStringLiteralList_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_textStringLiteralList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , textStringLiteralList > { global . tracer . print_trace_start (& state , "textStringLiteralList") ; let result = (|| { let result = textStringLiteralList_impl :: parse (state , global) ? . map (| r | super :: textStringLiteralList { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod numLiteral_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ULONGLONG_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DECIMAL_NUMBER (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FLOAT_NUMBER (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_numLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , numLiteral > { global . tracer . print_trace_start (& state , "numLiteral") ; let result = (|| { let result = numLiteral_impl :: parse (state , global) ? . map (| r | super :: numLiteral { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod boolLiteral_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRUE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FALSE_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_boolLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , boolLiteral > { global . tracer . print_trace_start (& state , "boolLiteral") ; let result = (|| { let result = boolLiteral_impl :: parse (state , global) ? . map (| r | super :: boolLiteral { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod nullLiteral_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULL2_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_nullLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , nullLiteral > { global . tracer . print_trace_start (& state , "nullLiteral") ; let result = (|| { let result = nullLiteral_impl :: parse (state , global) ? . map (| r | super :: nullLiteral { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod temporalLiteral_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATE_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTED_TEXT (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIME_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTED_TEXT (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTED_TEXT (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_temporalLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , temporalLiteral > { global . tracer . print_trace_start (& state , "temporalLiteral") ; let result = (|| { let result = temporalLiteral_impl :: parse (state , global) ? . map (| r | super :: temporalLiteral { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod floatOptions_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_fieldLength (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_precision (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_floatOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , floatOptions > { global . tracer . print_trace_start (& state , "floatOptions") ; let result = (|| { let result = floatOptions_impl :: parse (state , global) ? . map (| r | super :: floatOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod standardFloatOptions_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_precision (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_standardFloatOptions < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , standardFloatOptions > { global . tracer . print_trace_start (& state , "standardFloatOptions") ; let result = (|| { let result = standardFloatOptions_impl :: parse (state , global) ? . map (| r | super :: standardFloatOptions { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod precision_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMA_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_precision < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , precision > { global . tracer . print_trace_start (& state , "precision") ; let result = (|| { let result = precision_impl :: parse (state , global) ? . map (| r | super :: precision { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod textOrIdentifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_textOrIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , textOrIdentifier > { global . tracer . print_trace_start (& state , "textOrIdentifier") ; let result = (|| { let result = textOrIdentifier_impl :: parse (state , global) ? . map (| r | super :: textOrIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lValueIdentifier_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_pureIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_lValueKeyword (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_lValueIdentifier < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lValueIdentifier > { global . tracer . print_trace_start (& state , "lValueIdentifier") ; let result = (|| { let result = lValueIdentifier_impl :: parse (state , global) ? . map (| r | super :: lValueIdentifier { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod roleIdentifierOrText_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleIdentifier (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_textStringLiteral (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_roleIdentifierOrText < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , roleIdentifierOrText > { global . tracer . print_trace_start (& state , "roleIdentifierOrText") ; let result = (|| { let result = roleIdentifierOrText_impl :: parse (state , global) ? . map (| r | super :: roleIdentifierOrText { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod sizeNumber_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_real_ulonglong_number (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_pureIdentifier (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_sizeNumber < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , sizeNumber > { global . tracer . print_trace_start (& state , "sizeNumber") ; let result = (|| { let result = sizeNumber_impl :: parse (state , global) ? . map (| r | super :: sizeNumber { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod parentheses_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_PAR_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_parentheses < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , parentheses > { global . tracer . print_trace_start (& state , "parentheses") ; let result = (|| { let result = parentheses_impl :: parse (state , global) ? . map (| r | super :: parentheses { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod equal_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EQUAL_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ASSIGN_OPERATOR (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_equal < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , equal > { global . tracer . print_trace_start (& state , "equal") ; let result = (|| { let result = equal_impl :: parse (state , global) ? . map (| r | super :: equal { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod optionType_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PERSIST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PERSIST_ONLY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GLOBAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SESSION_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_optionType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , optionType > { global . tracer . print_trace_start (& state , "optionType") ; let result = (|| { let result = optionType_impl :: parse (state , global) ? . map (| r | super :: optionType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod varIdentType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GLOBAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SESSION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_varIdentType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , varIdentType > { global . tracer . print_trace_start (& state , "varIdentType") ; let result = (|| { let result = varIdentType_impl :: parse (state , global) ? . map (| r | super :: varIdentType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod setVarIdentType_impl { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PERSIST_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PERSIST_ONLY_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GLOBAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_3 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_4 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SESSION_SYMBOL (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOT_SYMBOL (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . choice (| state | choice_3 :: parse (state , global)) . choice (| state | choice_4 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_setVarIdentType < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , setVarIdentType > { global . tracer . print_trace_start (& state , "setVarIdentType") ; let result = (|| { let result = setVarIdentType_impl :: parse (state , global) ? . map (| r | super :: setVarIdentType { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identifierKeyword_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_labelKeyword (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrIdentifierKeyword (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXECUTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHUTDOWN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESTART_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsUnambiguous (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous1RolesAndLabels (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous2Labels (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous3Roles (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous4SystemVariables (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_identifierKeyword < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identifierKeyword > { global . tracer . print_trace_start (& state , "identifierKeyword") ; let result = (|| { let result = identifierKeyword_impl :: parse (state , global) ? . map (| r | super :: identifierKeyword { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identifierKeywordsAmbiguous1RolesAndLabels_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXECUTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESTART_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHUTDOWN_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_identifierKeywordsAmbiguous1RolesAndLabels < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identifierKeywordsAmbiguous1RolesAndLabels > { global . tracer . print_trace_start (& state , "identifierKeywordsAmbiguous1RolesAndLabels") ; let result = (|| { let result = identifierKeywordsAmbiguous1RolesAndLabels_impl :: parse (state , global) ? . map (| r | super :: identifierKeywordsAmbiguous1RolesAndLabels { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identifierKeywordsAmbiguous2Labels_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ASCII_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BEGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BYTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CACHE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHARSET_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECKSUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTAINS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEALLOCATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FLUSH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOLLOWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HANDLER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HELP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IMPORT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LANGUAGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECEDES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PREPARE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPAIR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESET_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLLBACK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SAVEPOINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SIGNED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLAVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_START_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STOP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRUNCATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNICODE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNINSTALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XA_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_identifierKeywordsAmbiguous2Labels < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identifierKeywordsAmbiguous2Labels > { global . tracer . print_trace_start (& state , "identifierKeywordsAmbiguous2Labels") ; let result = (|| { let result = identifierKeywordsAmbiguous2Labels_impl :: parse (state , global) ? . map (| r | super :: identifierKeywordsAmbiguous2Labels { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod labelKeyword_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrLabelKeyword (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCESS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROXY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELOAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESOURCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUPER_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsUnambiguous (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous3Roles (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous4SystemVariables (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_labelKeyword < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , labelKeyword > { global . tracer . print_trace_start (& state , "labelKeyword") ; let result = (|| { let result = labelKeyword_impl :: parse (state , global) ? . map (| r | super :: labelKeyword { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identifierKeywordsAmbiguous3Roles_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCESS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROXY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELOAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESOURCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUPER_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_identifierKeywordsAmbiguous3Roles < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identifierKeywordsAmbiguous3Roles > { global . tracer . print_trace_start (& state , "identifierKeywordsAmbiguous3Roles") ; let result = (|| { let result = identifierKeywordsAmbiguous3Roles_impl :: parse (state , global) ? . map (| r | super :: identifierKeywordsAmbiguous3Roles { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identifierKeywordsUnambiguous_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACCOUNT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACTIVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADDDATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADMIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AFTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AGAINST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AGGREGATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALGORITHM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALWAYS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AUTOEXTEND_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AUTO_INCREMENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AVG_ROW_LENGTH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AVG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BACKUP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINLOG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BLOCK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BOOLEAN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BOOL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BTREE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BUCKETS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASCADED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CATALOG_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANGED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANNEL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CIPHER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLASS_ORIGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLIENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COALESCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CODE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLLATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMNS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_FORMAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMITTED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPACT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPLETION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPONENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPRESSED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPRESSION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONCURRENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONNECTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSISTENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_CATALOG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_SCHEMA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CPU_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURRENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURSOR_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATAFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATETIME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_AUTH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFINER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFINITION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELAY_KEY_WRITE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DESCRIPTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIAGNOSTICS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIRECTORY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISCARD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DUMPFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DUPLICATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DYNAMIC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENCRYPTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENFORCED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ERRORS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ERROR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ESCAPE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVERY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXCHANGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXCLUDE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPANSION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPIRE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPORT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENDED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENT_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FAST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FAULTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FILE_BLOCK_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FILTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIRST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIXED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOLLOWING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FORMAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOUND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FULL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GENERAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GEOMETRYCOLLECTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GEOMETRY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GET_FORMAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GET_MASTER_PUBLIC_KEY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_REPLICATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HASH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HISTOGRAM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HISTORY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOSTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SERVER_IDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INACTIVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEXES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INITIAL_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSERT_METHOD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTANCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INVISIBLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INVOKER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IPC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ISOLATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ISSUER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JSON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_BLOCK_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LAST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEAVES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LESS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEVEL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINESTRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCKED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCKS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_AUTO_POSITION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_COMPRESSION_ALGORITHM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_CONNECT_RETRY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_DELAY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_HEARTBEAT_PERIOD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_HOST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NETWORK_NAMESPACE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_LOG_FILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_LOG_POS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_PORT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_PUBLIC_KEY_PATH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_RETRY_COUNT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SERVER_ID_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CAPATH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CERT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CIPHER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CRLPATH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CRL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_KEY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_TLS_CIPHERSUITES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_TLS_VERSION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_USER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_CONNECTIONS_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_QUERIES_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_UPDATES_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_USER_CONNECTIONS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEDIUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEMORY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MERGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MESSAGE_TEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MICROSECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MIGRATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MIN_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MODE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MODIFY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MONTH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTILINESTRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTIPOINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTIPOLYGON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MUTEX_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MYSQL_ERRNO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NAMES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NATIONAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NCHAR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NDBCLUSTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NESTED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEVER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEW_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NODEGROUP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOWAIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_WAIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULLS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NUMBER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NVARCHAR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OFFSET_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OJ_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OLD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ONLY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIONAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIONS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ORDINALITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ORGANIZATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OTHERS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OWNER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PACK_KEYS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PAGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARSER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTIAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITIONING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITIONS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PATH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PHASE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGINS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGIN_DIR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_POINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_POLYGON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PORT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECEDING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRESERVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PREV_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIVILEGES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIVILEGE_CHECKS_USER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCESSLIST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROFILES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUARTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUERY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUICK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_ONLY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REBUILD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RECOVER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REDO_BUFFER_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REDUNDANT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REFERENCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAYLOG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_LOG_FILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_LOG_POS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_THREAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REMOVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REORGANIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPEATABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_DO_DB_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_DO_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_IGNORE_DB_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_IGNORE_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_REWRITE_DB_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_WILD_DO_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_WILD_IGNORE_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_RESOURCES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESPECT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESTORE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESUME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETAIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETURNED_SQLSTATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETURNS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REUSE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REVERSE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLLUP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROTATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROUTINE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_COUNT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_FORMAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RTREE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SCHEDULE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SCHEMA_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_ENGINE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_LOAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_UNLOAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECURITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERIALIZABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERIAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERVER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHARE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SIMPLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SKIP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLOW_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SNAPSHOT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SOCKET_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SONAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SOUNDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SOURCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_AFTER_GTIDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_AFTER_MTS_GAPS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_BEFORE_GTIDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_BUFFER_RESULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_NO_CACHE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_THREAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SRID_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STACKED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STARTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATS_AUTO_RECALC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATS_PERSISTENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATS_SAMPLE_PAGES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STORAGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBCLASS_ORIGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBDATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBJECT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBPARTITIONS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBPARTITION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUSPEND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SWAPS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SWITCHES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_CHECKSUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEMPORARY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEMPTABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_THAN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_THREAD_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_ADD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_DIFF_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRANSACTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRIGGERS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TYPES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TYPE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNBOUNDED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNCOMMITTED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDEFINED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDOFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDO_BUFFER_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNKNOWN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNTIL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPGRADE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USE_FRM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALIDATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARIABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VCPU_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VIEW_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VISIBLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WAIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WARNINGS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WEEK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WEIGHT_STRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITHOUT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WORK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WRAPPER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_X509_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XID_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XML_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_YEAR_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ARRAY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FAILED_LOGIN_ATTEMPTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_COMPRESSION_ALGORITHM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_TLS_CIPHERSUITES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEMBER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OFF_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_LOCK_TIME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIVILEGE_CHECKS_USER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RANDOM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REQUIRE_ROW_FORMAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STREAM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIME_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_identifierKeywordsUnambiguous < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identifierKeywordsUnambiguous > { global . tracer . print_trace_start (& state , "identifierKeywordsUnambiguous") ; let result = (|| { let result = identifierKeywordsUnambiguous_impl :: parse (state , global) ? . map (| r | super :: identifierKeywordsUnambiguous { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod roleKeyword_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrLabelKeyword (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_roleOrIdentifierKeyword (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsUnambiguous (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous2Labels (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous4SystemVariables (state , & mut * global) }) . discard_result ()) . end ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_roleKeyword < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , roleKeyword > { global . tracer . print_trace_start (& state , "roleKeyword") ; let result = (|| { let result = roleKeyword_impl :: parse (state , global) ? . map (| r | super :: roleKeyword { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod lValueKeyword_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsUnambiguous (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous1RolesAndLabels (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous2Labels (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_identifierKeywordsAmbiguous3Roles (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_lValueKeyword < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , lValueKeyword > { global . tracer . print_trace_start (& state , "lValueKeyword") ; let result = (|| { let result = lValueKeyword_impl :: parse (state , global) ? . map (| r | super :: lValueKeyword { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod identifierKeywordsAmbiguous4SystemVariables_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GLOBAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PERSIST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PERSIST_ONLY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SESSION_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_identifierKeywordsAmbiguous4SystemVariables < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , identifierKeywordsAmbiguous4SystemVariables > { global . tracer . print_trace_start (& state , "identifierKeywordsAmbiguous4SystemVariables") ; let result = (|| { let result = identifierKeywordsAmbiguous4SystemVariables_impl :: parse (state , global) ? . map (| r | super :: identifierKeywordsAmbiguous4SystemVariables { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod roleOrIdentifierKeyword_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACCOUNT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ASCII_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALWAYS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BACKUP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BEGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BYTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CACHE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHARSET_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHECKSUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLOSE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTAINS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEALLOCATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_END_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FLUSH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOLLOWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FORMAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GROUP_REPLICATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HANDLER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HELP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INVISIBLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LANGUAGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPEN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIONS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OWNER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARSER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PORT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECEDES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PREPARE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REMOVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPAIR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESET_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESTORE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLLBACK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SAVEPOINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_ENGINE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_LOAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECONDARY_UNLOAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECURITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERVER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SIGNED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SOCKET_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLAVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SONAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_START_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STOP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRUNCATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNICODE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNINSTALL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UPGRADE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VISIBLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WRAPPER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XA_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHUTDOWN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IMPORT_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_roleOrIdentifierKeyword < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , roleOrIdentifierKeyword > { global . tracer . print_trace_start (& state , "roleOrIdentifierKeyword") ; let result = (|| { let result = roleOrIdentifierKeyword_impl :: parse (state , global) ? . map (| r | super :: roleOrIdentifierKeyword { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod roleOrLabelKeyword_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ACTIVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADDDATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AFTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AGAINST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AGGREGATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ALGORITHM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANALYSE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AUTHORS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AUTO_INCREMENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AUTOEXTEND_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AVG_ROW_LENGTH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_AVG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BINLOG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BLOCK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BOOL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BOOLEAN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BTREE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BUCKETS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CASCADED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CATALOG_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHAIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANGED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CHANNEL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CIPHER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLIENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CLASS_ORIGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COALESCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CODE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLLATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMN_FORMAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COLUMNS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMMITTED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPACT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPLETION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPONENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPRESSED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_COMPRESSION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONCURRENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONNECTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSISTENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_CATALOG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_SCHEMA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONSTRAINT_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CONTRIBUTORS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CPU_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURRENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CURSOR_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATAFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATETIME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DAY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFAULT_AUTH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DEFINER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DELAY_KEY_WRITE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DES_KEY_FILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DESCRIPTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIAGNOSTICS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIRECTORY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISCARD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DISK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DUMPFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DUPLICATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DYNAMIC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENCRYPTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENGINES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ERROR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ERRORS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ESCAPE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVENTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EVERY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXCLUDE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPANSION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPORT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENDED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXTENT_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FAULTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FAST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOLLOWING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FOUND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ENABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FULL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FILE_BLOCK_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FILTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIRST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FIXED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GENERAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GEOMETRY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GEOMETRYCOLLECTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GET_FORMAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GRANTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_GLOBAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HASH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HISTOGRAM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HISTORY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOSTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IDENTIFIED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IGNORE_SERVER_IDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INVOKER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INDEXES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INITIAL_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSTANCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INACTIVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IPC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ISOLATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ISSUER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INSERT_METHOD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_JSON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KEY_BLOCK_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LAST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEAVES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LESS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LEVEL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINESTRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LIST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCKED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOCKS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_HEARTBEAT_PERIOD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_HOST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_PORT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_LOG_FILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_LOG_POS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_USER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_PUBLIC_KEY_PATH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SERVER_ID_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_CONNECT_RETRY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_RETRY_COUNT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_DELAY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CA_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CAPATH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_TLS_VERSION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CERT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CIPHER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CRL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_CRLPATH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_SSL_KEY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MASTER_AUTO_POSITION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_CONNECTIONS_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_QUERIES_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_STATEMENT_TIME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_UPDATES_PER_HOUR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MAX_USER_CONNECTIONS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEDIUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MEMORY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MERGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MESSAGE_TEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MICROSECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MIGRATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MIN_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MODIFY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MODE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MONTH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTILINESTRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTIPOINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MULTIPOLYGON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MUTEX_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MYSQL_ERRNO_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NAMES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NATIONAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NCHAR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NDBCLUSTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NESTED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEVER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NEW_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NO_WAIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NODEGROUP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NULLS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOWAIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NUMBER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NVARCHAR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OFFSET_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OLD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OLD_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ONE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OPTIONAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ORDINALITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ORGANIZATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_OTHERS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PACK_KEYS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PAGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTIAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITIONING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PARTITIONS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PASSWORD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PATH_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PHASE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGIN_DIR_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUGINS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_POINT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_POLYGON_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRECEDING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRESERVE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PREV_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_THREAD_PRIORITY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PRIVILEGES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROCESSLIST_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PROFILES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUARTER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUERY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_QUICK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_READ_ONLY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REBUILD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RECOVER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REDO_BUFFER_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REDOFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REDUNDANT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAYLOG_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_LOG_FILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_LOG_POS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RELAY_THREAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REMOTE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REORGANIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPEATABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_DO_DB_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_IGNORE_DB_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_DO_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_IGNORE_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_WILD_DO_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_WILD_IGNORE_TABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REPLICATE_REWRITE_DB_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_RESOURCES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESPECT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RESUME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETAIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETURNED_SQLSTATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RETURNS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REUSE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_REVERSE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROLLUP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROTATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROUTINE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_COUNT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_FORMAT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_RTREE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SCHEDULE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SCHEMA_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SECOND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERIAL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SERIALIZABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SESSION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHARE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SIMPLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SKIP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SLOW_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SNAPSHOT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SOUNDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SOURCE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_AFTER_GTIDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_AFTER_MTS_GAPS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_BEFORE_GTIDS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_CACHE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_BUFFER_RESULT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_NO_CACHE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SQL_THREAD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SRID_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STACKED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STARTS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATS_AUTO_RECALC_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATS_PERSISTENT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATS_SAMPLE_PAGES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STATUS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STORAGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_STRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBCLASS_ORIGIN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBDATE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBJECT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBPARTITION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUBPARTITIONS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUPER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUSPEND_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SWAPS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SWITCHES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_NAME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLE_CHECKSUM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TABLESPACE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEMPORARY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEMPTABLE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TEXT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_THAN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRANSACTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TRIGGERS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_ADD_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIMESTAMP_DIFF_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TIME_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TYPES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_TYPE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UDF_RETURNS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNBOUNDED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNCOMMITTED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDEFINED_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDO_BUFFER_SIZE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNDOFILE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNKNOWN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_UNTIL_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_USE_FRM_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VARIABLES_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VCPU_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VIEW_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALUE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WARNINGS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WAIT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WEEK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WORK_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WEIGHT_STRING_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_X509_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XID_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_XML_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_YEAR_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SHUTDOWN_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_CUBE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IMPORT_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FUNCTION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROWS_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ROW_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXCHANGE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EXPIRE_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ONLY_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SUPER_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VALIDATION_SYMBOL (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_WITHOUT_SYMBOL (state , & mut * global) }) . discard_result ()) . end ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ADMIN_SYMBOL (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_roleOrLabelKeyword < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , roleOrLabelKeyword > { global . tracer . print_trace_start (& state , "roleOrLabelKeyword") ; let result = (|| { let result = roleOrLabelKeyword_impl :: parse (state , global) ? . map (| r | super :: roleOrLabelKeyword { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EQUAL_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '=') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EQUAL_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EQUAL_OPERATOR > { global . tracer . print_trace_start (& state , "EQUAL_OPERATOR") ; let result = (|| { let result = EQUAL_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: EQUAL_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ASSIGN_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , ":=") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ASSIGN_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ASSIGN_OPERATOR > { global . tracer . print_trace_start (& state , "ASSIGN_OPERATOR") ; let result = (|| { let result = ASSIGN_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: ASSIGN_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NULL_SAFE_EQUAL_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "<=>") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NULL_SAFE_EQUAL_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NULL_SAFE_EQUAL_OPERATOR > { global . tracer . print_trace_start (& state , "NULL_SAFE_EQUAL_OPERATOR") ; let result = (|| { let result = NULL_SAFE_EQUAL_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: NULL_SAFE_EQUAL_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GREATER_OR_EQUAL_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , ">=") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GREATER_OR_EQUAL_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GREATER_OR_EQUAL_OPERATOR > { global . tracer . print_trace_start (& state , "GREATER_OR_EQUAL_OPERATOR") ; let result = (|| { let result = GREATER_OR_EQUAL_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: GREATER_OR_EQUAL_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GREATER_THAN_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '>') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GREATER_THAN_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GREATER_THAN_OPERATOR > { global . tracer . print_trace_start (& state , "GREATER_THAN_OPERATOR") ; let result = (|| { let result = GREATER_THAN_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: GREATER_THAN_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LESS_OR_EQUAL_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "<=") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LESS_OR_EQUAL_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LESS_OR_EQUAL_OPERATOR > { global . tracer . print_trace_start (& state , "LESS_OR_EQUAL_OPERATOR") ; let result = (|| { let result = LESS_OR_EQUAL_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: LESS_OR_EQUAL_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LESS_THAN_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '<') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LESS_THAN_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LESS_THAN_OPERATOR > { global . tracer . print_trace_start (& state , "LESS_THAN_OPERATOR") ; let result = (|| { let result = LESS_THAN_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: LESS_THAN_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NOT_EQUAL_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "!=") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NOT_EQUAL_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NOT_EQUAL_OPERATOR > { global . tracer . print_trace_start (& state , "NOT_EQUAL_OPERATOR") ; let result = (|| { let result = NOT_EQUAL_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: NOT_EQUAL_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NOT_EQUAL2_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "<>") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NOT_EQUAL2_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NOT_EQUAL2_OPERATOR > { global . tracer . print_trace_start (& state , "NOT_EQUAL2_OPERATOR") ; let result = (|| { let result = NOT_EQUAL2_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: NOT_EQUAL2_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PLUS_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '+') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PLUS_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PLUS_OPERATOR > { global . tracer . print_trace_start (& state , "PLUS_OPERATOR") ; let result = (|| { let result = PLUS_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: PLUS_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MINUS_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '-') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MINUS_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MINUS_OPERATOR > { global . tracer . print_trace_start (& state , "MINUS_OPERATOR") ; let result = (|| { let result = MINUS_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: MINUS_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MULT_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '*') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MULT_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MULT_OPERATOR > { global . tracer . print_trace_start (& state , "MULT_OPERATOR") ; let result = (|| { let result = MULT_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: MULT_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DIV_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '/') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DIV_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DIV_OPERATOR > { global . tracer . print_trace_start (& state , "DIV_OPERATOR") ; let result = (|| { let result = DIV_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: DIV_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MOD_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '%') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MOD_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MOD_OPERATOR > { global . tracer . print_trace_start (& state , "MOD_OPERATOR") ; let result = (|| { let result = MOD_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: MOD_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOGICAL_NOT_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '!') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOGICAL_NOT_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOGICAL_NOT_OPERATOR > { global . tracer . print_trace_start (& state , "LOGICAL_NOT_OPERATOR") ; let result = (|| { let result = LOGICAL_NOT_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: LOGICAL_NOT_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BITWISE_NOT_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '~') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BITWISE_NOT_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BITWISE_NOT_OPERATOR > { global . tracer . print_trace_start (& state , "BITWISE_NOT_OPERATOR") ; let result = (|| { let result = BITWISE_NOT_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: BITWISE_NOT_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SHIFT_LEFT_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "<<") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SHIFT_LEFT_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SHIFT_LEFT_OPERATOR > { global . tracer . print_trace_start (& state , "SHIFT_LEFT_OPERATOR") ; let result = (|| { let result = SHIFT_LEFT_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: SHIFT_LEFT_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SHIFT_RIGHT_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , ">>") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SHIFT_RIGHT_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SHIFT_RIGHT_OPERATOR > { global . tracer . print_trace_start (& state , "SHIFT_RIGHT_OPERATOR") ; let result = (|| { let result = SHIFT_RIGHT_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: SHIFT_RIGHT_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOGICAL_AND_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "&&") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOGICAL_AND_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOGICAL_AND_OPERATOR > { global . tracer . print_trace_start (& state , "LOGICAL_AND_OPERATOR") ; let result = (|| { let result = LOGICAL_AND_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: LOGICAL_AND_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BITWISE_AND_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BITWISE_AND_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BITWISE_AND_OPERATOR > { global . tracer . print_trace_start (& state , "BITWISE_AND_OPERATOR") ; let result = (|| { let result = BITWISE_AND_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: BITWISE_AND_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BITWISE_XOR_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '^') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BITWISE_XOR_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BITWISE_XOR_OPERATOR > { global . tracer . print_trace_start (& state , "BITWISE_XOR_OPERATOR") ; let result = (|| { let result = BITWISE_XOR_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: BITWISE_XOR_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOGICAL_OR_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "||") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOGICAL_OR_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOGICAL_OR_OPERATOR > { global . tracer . print_trace_start (& state , "LOGICAL_OR_OPERATOR") ; let result = (|| { let result = LOGICAL_OR_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: LOGICAL_OR_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BITWISE_OR_OPERATOR_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '|') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BITWISE_OR_OPERATOR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BITWISE_OR_OPERATOR > { global . tracer . print_trace_start (& state , "BITWISE_OR_OPERATOR") ; let result = (|| { let result = BITWISE_OR_OPERATOR_impl :: parse (state , global) ? . map (| r | super :: BITWISE_OR_OPERATOR { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DOT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '.') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DOT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DOT_SYMBOL > { global . tracer . print_trace_start (& state , "DOT_SYMBOL") ; let result = (|| { let result = DOT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DOT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COMMA_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COMMA_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COMMA_SYMBOL > { global . tracer . print_trace_start (& state , "COMMA_SYMBOL") ; let result = (|| { let result = COMMA_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COMMA_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SEMICOLON_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ';') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SEMICOLON_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SEMICOLON_SYMBOL > { global . tracer . print_trace_start (& state , "SEMICOLON_SYMBOL") ; let result = (|| { let result = SEMICOLON_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SEMICOLON_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COLON_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COLON_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COLON_SYMBOL > { global . tracer . print_trace_start (& state , "COLON_SYMBOL") ; let result = (|| { let result = COLON_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COLON_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OPEN_PAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OPEN_PAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OPEN_PAR_SYMBOL > { global . tracer . print_trace_start (& state , "OPEN_PAR_SYMBOL") ; let result = (|| { let result = OPEN_PAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OPEN_PAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CLOSE_PAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CLOSE_PAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CLOSE_PAR_SYMBOL > { global . tracer . print_trace_start (& state , "CLOSE_PAR_SYMBOL") ; let result = (|| { let result = CLOSE_PAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CLOSE_PAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OPEN_CURLY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '{') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OPEN_CURLY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OPEN_CURLY_SYMBOL > { global . tracer . print_trace_start (& state , "OPEN_CURLY_SYMBOL") ; let result = (|| { let result = OPEN_CURLY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OPEN_CURLY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CLOSE_CURLY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '}') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CLOSE_CURLY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CLOSE_CURLY_SYMBOL > { global . tracer . print_trace_start (& state , "CLOSE_CURLY_SYMBOL") ; let result = (|| { let result = CLOSE_CURLY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CLOSE_CURLY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNDERLINE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '_') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNDERLINE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNDERLINE_SYMBOL > { global . tracer . print_trace_start (& state , "UNDERLINE_SYMBOL") ; let result = (|| { let result = UNDERLINE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNDERLINE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod JSON_SEPARATOR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "->") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_JSON_SEPARATOR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , JSON_SEPARATOR_SYMBOL > { global . tracer . print_trace_start (& state , "JSON_SEPARATOR_SYMBOL") ; let result = (|| { let result = JSON_SEPARATOR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: JSON_SEPARATOR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod JSON_UNQUOTED_SEPARATOR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "->>") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_JSON_UNQUOTED_SEPARATOR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , JSON_UNQUOTED_SEPARATOR_SYMBOL > { global . tracer . print_trace_start (& state , "JSON_UNQUOTED_SEPARATOR_SYMBOL") ; let result = (|| { let result = JSON_UNQUOTED_SEPARATOR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: JSON_UNQUOTED_SEPARATOR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AT_SIGN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '@') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AT_SIGN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AT_SIGN_SYMBOL > { global . tracer . print_trace_start (& state , "AT_SIGN_SYMBOL") ; let result = (|| { let result = AT_SIGN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AT_SIGN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AT_TEXT_SUFFIX_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '@') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SIMPLE_IDENTIFIER (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_AT_TEXT_SUFFIX < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AT_TEXT_SUFFIX > { global . tracer . print_trace_start (& state , "AT_TEXT_SUFFIX") ; let result = (|| { let result = AT_TEXT_SUFFIX_impl :: parse (state , global) ? . map (| r | super :: AT_TEXT_SUFFIX { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AT_AT_SIGN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "@@") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AT_AT_SIGN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AT_AT_SIGN_SYMBOL > { global . tracer . print_trace_start (& state , "AT_AT_SIGN_SYMBOL") ; let result = (|| { let result = AT_AT_SIGN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AT_AT_SIGN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NULL2_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "\\N") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NULL2_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NULL2_SYMBOL > { global . tracer . print_trace_start (& state , "NULL2_SYMBOL") ; let result = (|| { let result = NULL2_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NULL2_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PARAM_MARKER_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '?') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PARAM_MARKER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PARAM_MARKER > { global . tracer . print_trace_start (& state , "PARAM_MARKER") ; let result = (|| { let result = PARAM_MARKER_impl :: parse (state , global) ? . map (| r | super :: PARAM_MARKER { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod A_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'a') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'A') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_A < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , A > { global . tracer . print_trace_start (& state , "A") ; let result = (|| { let result = A_impl :: parse (state , global) ? . map (| r | super :: A { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod B_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'b') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'B') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_B < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , B > { global . tracer . print_trace_start (& state , "B") ; let result = (|| { let result = B_impl :: parse (state , global) ? . map (| r | super :: B { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod C_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'c') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'C') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_C < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , C > { global . tracer . print_trace_start (& state , "C") ; let result = (|| { let result = C_impl :: parse (state , global) ? . map (| r | super :: C { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod D_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'd') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'D') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_D < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , D > { global . tracer . print_trace_start (& state , "D") ; let result = (|| { let result = D_impl :: parse (state , global) ? . map (| r | super :: D { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod E_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'e') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'E') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_E < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , E > { global . tracer . print_trace_start (& state , "E") ; let result = (|| { let result = E_impl :: parse (state , global) ? . map (| r | super :: E { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod F_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'f') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'F') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_F < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , F > { global . tracer . print_trace_start (& state , "F") ; let result = (|| { let result = F_impl :: parse (state , global) ? . map (| r | super :: F { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod G_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'g') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'G') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_G < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , G > { global . tracer . print_trace_start (& state , "G") ; let result = (|| { let result = G_impl :: parse (state , global) ? . map (| r | super :: G { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod H_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'h') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'H') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_H < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , H > { global . tracer . print_trace_start (& state , "H") ; let result = (|| { let result = H_impl :: parse (state , global) ? . map (| r | super :: H { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod I_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'i') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'I') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_I < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , I > { global . tracer . print_trace_start (& state , "I") ; let result = (|| { let result = I_impl :: parse (state , global) ? . map (| r | super :: I { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod J_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'j') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'J') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_J < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , J > { global . tracer . print_trace_start (& state , "J") ; let result = (|| { let result = J_impl :: parse (state , global) ? . map (| r | super :: J { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod K_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'k') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'K') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_K < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , K > { global . tracer . print_trace_start (& state , "K") ; let result = (|| { let result = K_impl :: parse (state , global) ? . map (| r | super :: K { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod L_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'l') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'L') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_L < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , L > { global . tracer . print_trace_start (& state , "L") ; let result = (|| { let result = L_impl :: parse (state , global) ? . map (| r | super :: L { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod M_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'm') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'M') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_M < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , M > { global . tracer . print_trace_start (& state , "M") ; let result = (|| { let result = M_impl :: parse (state , global) ? . map (| r | super :: M { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod N_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'n') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'N') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_N < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , N > { global . tracer . print_trace_start (& state , "N") ; let result = (|| { let result = N_impl :: parse (state , global) ? . map (| r | super :: N { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod O_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'o') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'O') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_O < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , O > { global . tracer . print_trace_start (& state , "O") ; let result = (|| { let result = O_impl :: parse (state , global) ? . map (| r | super :: O { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod P_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'p') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'P') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_P < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , P > { global . tracer . print_trace_start (& state , "P") ; let result = (|| { let result = P_impl :: parse (state , global) ? . map (| r | super :: P { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Q_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'q') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'Q') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_Q < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Q > { global . tracer . print_trace_start (& state , "Q") ; let result = (|| { let result = Q_impl :: parse (state , global) ? . map (| r | super :: Q { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod R_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'r') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'R') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_R < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , R > { global . tracer . print_trace_start (& state , "R") ; let result = (|| { let result = R_impl :: parse (state , global) ? . map (| r | super :: R { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod S_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 's') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'S') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_S < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , S > { global . tracer . print_trace_start (& state , "S") ; let result = (|| { let result = S_impl :: parse (state , global) ? . map (| r | super :: S { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod T_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 't') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'T') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_T < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , T > { global . tracer . print_trace_start (& state , "T") ; let result = (|| { let result = T_impl :: parse (state , global) ? . map (| r | super :: T { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod U_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'u') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'U') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_U < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , U > { global . tracer . print_trace_start (& state , "U") ; let result = (|| { let result = U_impl :: parse (state , global) ? . map (| r | super :: U { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod V_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'v') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'V') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_V < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , V > { global . tracer . print_trace_start (& state , "V") ; let result = (|| { let result = V_impl :: parse (state , global) ? . map (| r | super :: V { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod W_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'w') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'W') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_W < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , W > { global . tracer . print_trace_start (& state , "W") ; let result = (|| { let result = W_impl :: parse (state , global) ? . map (| r | super :: W { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod X_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'x') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'X') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_X < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , X > { global . tracer . print_trace_start (& state , "X") ; let result = (|| { let result = X_impl :: parse (state , global) ? . map (| r | super :: X { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Y_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'y') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'Y') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_Y < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Y > { global . tracer . print_trace_start (& state , "Y") ; let result = (|| { let result = Y_impl :: parse (state , global) ? . map (| r | super :: Y { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Z_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'z') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , 'Z') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_Z < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Z > { global . tracer . print_trace_start (& state , "Z") ; let result = (|| { let result = Z_impl :: parse (state , global) ? . map (| r | super :: Z { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } # [inline] pub (super) fn parse_DIGIT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DIGIT > { if let Ok (result) = parse_character_range (state . clone () , '0' , '9') { return Ok (result) } Err (state . report_error (ParseErrorSpecifics :: ExpectedCharacterClass { name : "DIGIT" })) } mod DIGITS_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGIT (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_DIGITS < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DIGITS > { global . tracer . print_trace_start (& state , "DIGITS") ; let result = (|| { let result = DIGITS_impl :: parse (state , global) ? . map (| r | super :: DIGITS { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } # [inline] pub (super) fn parse_HEXDIGIT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HEXDIGIT > { if let Ok (result) = parse_character_range (state . clone () , 'a' , 'f') { return Ok (result) } if let Ok (result) = parse_character_range (state . clone () , 'A' , 'F') { return Ok (result) } if let Ok (result) = parse_character_range (state . clone () , '0' , '9') { return Ok (result) } Err (state . report_error (ParseErrorSpecifics :: ExpectedCharacterClass { name : "HEXDIGIT" })) } mod HEX_NUMBER_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HEXDIGIT (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "0x") }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_HEXDIGIT (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "x'") }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\'') }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HEX_NUMBER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HEX_NUMBER > { global . tracer . print_trace_start (& state , "HEX_NUMBER") ; let result = (|| { let result = HEX_NUMBER_impl :: parse (state , global) ? . map (| r | super :: HEX_NUMBER { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BIN_NUMBER_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '0') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '1') }) . discard_result ()) . end () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "0b") }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '0') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '1') }) . discard_result ()) . end () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "b'") }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\'') }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BIN_NUMBER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BIN_NUMBER > { global . tracer . print_trace_start (& state , "BIN_NUMBER") ; let result = (|| { let result = BIN_NUMBER_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INT_NUMBER_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGITS (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INT_NUMBER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INT_NUMBER > { global . tracer . print_trace_start (& state , "INT_NUMBER") ; let result = (|| { let result = INT_NUMBER_impl :: parse (state , global) ? . map (| r | super :: INT_NUMBER { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LONG_NUMBER_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LONG_NUMBER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LONG_NUMBER > { global . tracer . print_trace_start (& state , "LONG_NUMBER") ; let result = (|| { let result = LONG_NUMBER_impl :: parse (state , global) ? . map (| r | super :: LONG_NUMBER { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ULONGLONG_NUMBER_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_INT_NUMBER (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ULONGLONG_NUMBER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ULONGLONG_NUMBER > { global . tracer . print_trace_start (& state , "ULONGLONG_NUMBER") ; let result = (|| { let result = ULONGLONG_NUMBER_impl :: parse (state , global) ? . map (| r | super :: ULONGLONG_NUMBER { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DECIMAL_NUMBER_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGITS (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '.') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGITS (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_DECIMAL_NUMBER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DECIMAL_NUMBER > { global . tracer . print_trace_start (& state , "DECIMAL_NUMBER") ; let result = (|| { let result = DECIMAL_NUMBER_impl :: parse (state , global) ? . map (| r | super :: DECIMAL_NUMBER { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FLOAT_NUMBER_impl { use super :: * ; mod part_0 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGITS (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '.') }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGITS (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_E (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MINUS_OPERATOR (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PLUS_OPERATOR (state , & mut * global) }) . discard_result ()) . end () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGITS (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_FLOAT_NUMBER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FLOAT_NUMBER > { global . tracer . print_trace_start (& state , "FLOAT_NUMBER") ; let result = (|| { let result = FLOAT_NUMBER_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DOT_IDENTIFIER_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LETTER_WHEN_UNQUOTED (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '.') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LETTER_WHEN_UNQUOTED_NO_DIGIT (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_DOT_IDENTIFIER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DOT_IDENTIFIER > { global . tracer . print_trace_start (& state , "DOT_IDENTIFIER") ; let result = (|| { let result = DOT_IDENTIFIER_impl :: parse (state , global) ? . map (| r | super :: DOT_IDENTIFIER { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNDERSCORE_CHARSET_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , 'a' , 'z') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , '0' , '9') }) . discard_result ()) . end () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '_') }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNDERSCORE_CHARSET < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNDERSCORE_CHARSET > { global . tracer . print_trace_start (& state , "UNDERSCORE_CHARSET") ; let result = (|| { let result = UNDERSCORE_CHARSET_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IDENTIFIER_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_0 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGITS (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod part_2 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LETTER_WHEN_UNQUOTED (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LETTER_WHEN_UNQUOTED_NO_DIGIT (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_E (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_1 { use super :: * ; mod part_0 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGITS (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod part_2 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LETTER_WHEN_UNQUOTED (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LETTER_WITHOUT_FLOAT_PART (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod choice_2 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LETTER_WHEN_UNQUOTED (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LETTER_WHEN_UNQUOTED_NO_DIGIT (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | choice_2 :: parse (state , global)) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IDENTIFIER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IDENTIFIER > { global . tracer . print_trace_start (& state , "IDENTIFIER") ; let result = (|| { let result = IDENTIFIER_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NCHAR_TEXT_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_N (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTED_TEXT (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_NCHAR_TEXT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NCHAR_TEXT > { global . tracer . print_trace_start (& state , "NCHAR_TEXT") ; let result = (|| { let result = NCHAR_TEXT_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BACK_TICK_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '`') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BACK_TICK < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BACK_TICK > { global . tracer . print_trace_start (& state , "BACK_TICK") ; let result = (|| { let result = BACK_TICK_impl :: parse (state , global) ? . map (| r | super :: BACK_TICK { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SINGLE_QUOTE_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\'') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SINGLE_QUOTE < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SINGLE_QUOTE > { global . tracer . print_trace_start (& state , "SINGLE_QUOTE") ; let result = (|| { let result = SINGLE_QUOTE_impl :: parse (state , global) ? . map (| r | super :: SINGLE_QUOTE { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DOUBLE_QUOTE_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '"') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DOUBLE_QUOTE < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DOUBLE_QUOTE > { global . tracer . print_trace_start (& state , "DOUBLE_QUOTE") ; let result = (|| { let result = DOUBLE_QUOTE_impl :: parse (state , global) ? . map (| r | super :: DOUBLE_QUOTE { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BACK_TICK_QUOTED_ID_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BACK_TICK_ESCAPE (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BACK_TICK_CONTENT (state , & mut * global) }) . discard_result ()) . end () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BACK_TICK (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_BACK_TICK (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_BACK_TICK_QUOTED_ID < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BACK_TICK_QUOTED_ID > { global . tracer . print_trace_start (& state , "BACK_TICK_QUOTED_ID") ; let result = (|| { let result = BACK_TICK_QUOTED_ID_impl :: parse (state , global) ? . map (| r | super :: BACK_TICK_QUOTED_ID { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BACK_TICK_ESCAPE_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\\') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_BACK_TICK_ESCAPE < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BACK_TICK_ESCAPE > { global . tracer . print_trace_start (& state , "BACK_TICK_ESCAPE") ; let result = (|| { let result = BACK_TICK_ESCAPE_impl :: parse (state , global) ? . map (| r | super :: BACK_TICK_ESCAPE { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } # [inline] pub (super) fn parse_ANY < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ANY > { if let Ok (result) = parse_char (state . clone () , global) { return Ok (result) } Err (state . report_error (ParseErrorSpecifics :: ExpectedCharacterClass { name : "ANY" })) } mod BACK_TICK_CONTENT_impl { use super :: * ; mod part_0 { use super :: * ; mod negative_lookahead { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '`') }) . discard_result () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { match negative_lookahead :: parse (state . clone () , global) { Ok (_) => Err (state . report_error (ParseErrorSpecifics :: NegativeLookaheadFailed)) , Err (_) => Ok (ParseOk { result : () , state }) , } } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_BACK_TICK_CONTENT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BACK_TICK_CONTENT > { global . tracer . print_trace_start (& state , "BACK_TICK_CONTENT") ; let result = (|| { let result = BACK_TICK_CONTENT_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DOUBLE_QUOTED_TEXT_impl { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_QUOTE (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_QUOTED_CONTENT (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_QUOTE (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_DOUBLE_QUOTED_TEXT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DOUBLE_QUOTED_TEXT > { global . tracer . print_trace_start (& state , "DOUBLE_QUOTED_TEXT") ; let result = (|| { let result = DOUBLE_QUOTED_TEXT_impl :: parse (state , global) ? . map (| r | super :: DOUBLE_QUOTED_TEXT { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DOUBLE_QUOTED_CONTENT_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_QUOTE_ESCAPE (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_QUOTE_CHAR (state , & mut * global) }) . discard_result ()) . end () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_DOUBLE_QUOTED_CONTENT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DOUBLE_QUOTED_CONTENT > { global . tracer . print_trace_start (& state , "DOUBLE_QUOTED_CONTENT") ; let result = (|| { let result = DOUBLE_QUOTED_CONTENT_impl :: parse (state , global) ? . map (| r | super :: DOUBLE_QUOTED_CONTENT { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DOUBLE_QUOTE_ESCAPE_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\\') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_DOUBLE_QUOTE_ESCAPE < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DOUBLE_QUOTE_ESCAPE > { global . tracer . print_trace_start (& state , "DOUBLE_QUOTE_ESCAPE") ; let result = (|| { let result = DOUBLE_QUOTE_ESCAPE_impl :: parse (state , global) ? . map (| r | super :: DOUBLE_QUOTE_ESCAPE { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DOUBLE_QUOTE_CHAR_impl { use super :: * ; mod part_0 { use super :: * ; mod negative_lookahead { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '`') }) . discard_result () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { match negative_lookahead :: parse (state . clone () , global) { Ok (_) => Err (state . report_error (ParseErrorSpecifics :: NegativeLookaheadFailed)) , Err (_) => Ok (ParseOk { result : () , state }) , } } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_DOUBLE_QUOTE_CHAR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DOUBLE_QUOTE_CHAR > { global . tracer . print_trace_start (& state , "DOUBLE_QUOTE_CHAR") ; let result = (|| { let result = DOUBLE_QUOTE_CHAR_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SINGLE_QUOTED_TEXT_impl { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTE (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTED_CONTENT (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTE (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_SINGLE_QUOTED_TEXT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SINGLE_QUOTED_TEXT > { global . tracer . print_trace_start (& state , "SINGLE_QUOTED_TEXT") ; let result = (|| { let result = SINGLE_QUOTED_TEXT_impl :: parse (state , global) ? . map (| r | super :: SINGLE_QUOTED_TEXT { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SINGLE_QUOTED_CONTENT_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTE_ESCAPE (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SINGLE_QUOTE_CHAR (state , & mut * global) }) . discard_result ()) . end () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_SINGLE_QUOTED_CONTENT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SINGLE_QUOTED_CONTENT > { global . tracer . print_trace_start (& state , "SINGLE_QUOTED_CONTENT") ; let result = (|| { let result = SINGLE_QUOTED_CONTENT_impl :: parse (state , global) ? . map (| r | super :: SINGLE_QUOTED_CONTENT { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SINGLE_QUOTE_ESCAPE_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\\') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_SINGLE_QUOTE_ESCAPE < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SINGLE_QUOTE_ESCAPE > { global . tracer . print_trace_start (& state , "SINGLE_QUOTE_ESCAPE") ; let result = (|| { let result = SINGLE_QUOTE_ESCAPE_impl :: parse (state , global) ? . map (| r | super :: SINGLE_QUOTE_ESCAPE { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SINGLE_QUOTE_CHAR_impl { use super :: * ; mod part_0 { use super :: * ; mod negative_lookahead { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '`') }) . discard_result () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { match negative_lookahead :: parse (state . clone () , global) { Ok (_) => Err (state . report_error (ParseErrorSpecifics :: NegativeLookaheadFailed)) , Err (_) => Ok (ParseOk { result : () , state }) , } } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY (state , & mut * global) }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_SINGLE_QUOTE_CHAR < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SINGLE_QUOTE_CHAR > { global . tracer . print_trace_start (& state , "SINGLE_QUOTE_CHAR") ; let result = (|| { let result = SINGLE_QUOTE_CHAR_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VERSION_COMMENT_impl { use super :: * ; mod part_2 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "/*!") }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGITS (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_2 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "*/") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_VERSION_COMMENT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VERSION_COMMENT > { global . tracer . print_trace_start (& state , "VERSION_COMMENT") ; let result = (|| { let result = VERSION_COMMENT_impl :: parse (state , global) ? . map (| r | super :: VERSION_COMMENT { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MYSQL_COMMENT_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "/*!") }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "*/") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MYSQL_COMMENT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MYSQL_COMMENT > { global . tracer . print_trace_start (& state , "MYSQL_COMMENT") ; let result = (|| { let result = MYSQL_COMMENT_impl :: parse (state , global) ? . map (| r | super :: MYSQL_COMMENT { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BLOCK_COMMENT_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ANY (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "/*") }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "*/") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_BLOCK_COMMENT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BLOCK_COMMENT > { global . tracer . print_trace_start (& state , "BLOCK_COMMENT") ; let result = (|| { let result = BLOCK_COMMENT_impl :: parse (state , global) ? . map (| r | super :: BLOCK_COMMENT { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod POUND_COMMENT_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; mod negative_lookahead { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\n') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\r') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { match negative_lookahead :: parse (state . clone () , global) { Ok (_) => Err (state . report_error (ParseErrorSpecifics :: NegativeLookaheadFailed)) , Err (_) => Ok (ParseOk { result : () , state }) , } } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '#') }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_POUND_COMMENT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , POUND_COMMENT > { global . tracer . print_trace_start (& state , "POUND_COMMENT") ; let result = (|| { let result = POUND_COMMENT_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DASHDASH_COMMENT_impl { use super :: * ; mod part_1 { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; mod negative_lookahead { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\n') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\r') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { match negative_lookahead :: parse (state . clone () , global) { Ok (_) => Err (state . report_error (ParseErrorSpecifics :: NegativeLookaheadFailed)) , Err (_) => Ok (ParseOk { result : () , state }) , } } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ' ') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\t') }) . discard_result ()) . end () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LINEBREAK (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DOUBLE_DASH (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_DASHDASH_COMMENT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DASHDASH_COMMENT > { global . tracer . print_trace_start (& state , "DASHDASH_COMMENT") ; let result = (|| { let result = DASHDASH_COMMENT_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DOUBLE_DASH_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "--") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DOUBLE_DASH < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DOUBLE_DASH > { global . tracer . print_trace_start (& state , "DOUBLE_DASH") ; let result = (|| { let result = DOUBLE_DASH_impl :: parse (state , global) ? . map (| r | super :: DOUBLE_DASH { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } # [inline] pub (super) fn parse_LINEBREAK < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LINEBREAK > { if let Ok (result) = parse_character_literal (state . clone () , '\n') { return Ok (result) } if let Ok (result) = parse_character_literal (state . clone () , '\r') { return Ok (result) } Err (state . report_error (ParseErrorSpecifics :: ExpectedCharacterClass { name : "LINEBREAK" })) } mod SIMPLE_IDENTIFIER_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGIT (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , 'a' , 'z') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , 'A' , 'Z') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '$') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '.') }) . discard_result ()) . end () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_SIMPLE_IDENTIFIER < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SIMPLE_IDENTIFIER > { global . tracer . print_trace_start (& state , "SIMPLE_IDENTIFIER") ; let result = (|| { let result = SIMPLE_IDENTIFIER_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ML_COMMENT_HEAD_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "/*") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ML_COMMENT_HEAD < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ML_COMMENT_HEAD > { global . tracer . print_trace_start (& state , "ML_COMMENT_HEAD") ; let result = (|| { let result = ML_COMMENT_HEAD_impl :: parse (state , global) ? . map (| r | super :: ML_COMMENT_HEAD { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ML_COMMENT_END_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "*/") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ML_COMMENT_END < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ML_COMMENT_END > { global . tracer . print_trace_start (& state , "ML_COMMENT_END") ; let result = (|| { let result = ML_COMMENT_END_impl :: parse (state , global) ? . map (| r | super :: ML_COMMENT_END { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LETTER_WHEN_UNQUOTED_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_DIGIT (state , & mut * global) }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LETTER_WHEN_UNQUOTED_NO_DIGIT (state , & mut * global) }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LETTER_WHEN_UNQUOTED < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LETTER_WHEN_UNQUOTED > { global . tracer . print_trace_start (& state , "LETTER_WHEN_UNQUOTED") ; let result = (|| { let result = LETTER_WHEN_UNQUOTED_impl :: parse (state , global) ? . map (| r | super :: LETTER_WHEN_UNQUOTED { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LETTER_WHEN_UNQUOTED_NO_DIGIT_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , 'a' , 'z') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , 'A' , 'Z') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '$') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LETTER_WHEN_UNQUOTED_NO_DIGIT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LETTER_WHEN_UNQUOTED_NO_DIGIT > { global . tracer . print_trace_start (& state , "LETTER_WHEN_UNQUOTED_NO_DIGIT") ; let result = (|| { let result = LETTER_WHEN_UNQUOTED_NO_DIGIT_impl :: parse (state , global) ? . map (| r | super :: LETTER_WHEN_UNQUOTED_NO_DIGIT { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LETTER_WITHOUT_FLOAT_PART_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , 'a' , 'z') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , 'A' , 'Z') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '$') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LETTER_WITHOUT_FLOAT_PART < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LETTER_WITHOUT_FLOAT_PART > { global . tracer . print_trace_start (& state , "LETTER_WITHOUT_FLOAT_PART") ; let result = (|| { let result = LETTER_WITHOUT_FLOAT_PART_impl :: parse (state , global) ? . map (| r | super :: LETTER_WITHOUT_FLOAT_PART { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ACCESSIBLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ACCESSIBLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ACCESSIBLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ACCESSIBLE_SYMBOL > { global . tracer . print_trace_start (& state , "ACCESSIBLE_SYMBOL") ; let result = (|| { let result = ACCESSIBLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ACCESSIBLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ACCOUNT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ACCOUNT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ACCOUNT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ACCOUNT_SYMBOL > { global . tracer . print_trace_start (& state , "ACCOUNT_SYMBOL") ; let result = (|| { let result = ACCOUNT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ACCOUNT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ACTION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ACTION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ACTION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ACTION_SYMBOL > { global . tracer . print_trace_start (& state , "ACTION_SYMBOL") ; let result = (|| { let result = ACTION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ACTION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ADD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ADD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ADD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ADD_SYMBOL > { global . tracer . print_trace_start (& state , "ADD_SYMBOL") ; let result = (|| { let result = ADD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ADD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ADDDATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ADDDATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ADDDATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ADDDATE_SYMBOL > { global . tracer . print_trace_start (& state , "ADDDATE_SYMBOL") ; let result = (|| { let result = ADDDATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ADDDATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AFTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AFTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AFTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AFTER_SYMBOL > { global . tracer . print_trace_start (& state , "AFTER_SYMBOL") ; let result = (|| { let result = AFTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AFTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AGAINST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AGAINST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AGAINST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AGAINST_SYMBOL > { global . tracer . print_trace_start (& state , "AGAINST_SYMBOL") ; let result = (|| { let result = AGAINST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AGAINST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AGGREGATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AGGREGATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AGGREGATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AGGREGATE_SYMBOL > { global . tracer . print_trace_start (& state , "AGGREGATE_SYMBOL") ; let result = (|| { let result = AGGREGATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AGGREGATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ALGORITHM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ALGORITHM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ALGORITHM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ALGORITHM_SYMBOL > { global . tracer . print_trace_start (& state , "ALGORITHM_SYMBOL") ; let result = (|| { let result = ALGORITHM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ALGORITHM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ALL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ALL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ALL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ALL_SYMBOL > { global . tracer . print_trace_start (& state , "ALL_SYMBOL") ; let result = (|| { let result = ALL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ALL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ALTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ALTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ALTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ALTER_SYMBOL > { global . tracer . print_trace_start (& state , "ALTER_SYMBOL") ; let result = (|| { let result = ALTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ALTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ALWAYS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ALWAYS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ALWAYS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ALWAYS_SYMBOL > { global . tracer . print_trace_start (& state , "ALWAYS_SYMBOL") ; let result = (|| { let result = ALWAYS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ALWAYS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ANALYSE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ANALYSE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ANALYSE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ANALYSE_SYMBOL > { global . tracer . print_trace_start (& state , "ANALYSE_SYMBOL") ; let result = (|| { let result = ANALYSE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ANALYSE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ANALYZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ANALYZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ANALYZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ANALYZE_SYMBOL > { global . tracer . print_trace_start (& state , "ANALYZE_SYMBOL") ; let result = (|| { let result = ANALYZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ANALYZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AND_SYMBOL > { global . tracer . print_trace_start (& state , "AND_SYMBOL") ; let result = (|| { let result = AND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ANY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ANY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ANY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ANY_SYMBOL > { global . tracer . print_trace_start (& state , "ANY_SYMBOL") ; let result = (|| { let result = ANY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ANY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AS_SYMBOL > { global . tracer . print_trace_start (& state , "AS_SYMBOL") ; let result = (|| { let result = AS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ASC_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ASC") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ASC_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ASC_SYMBOL > { global . tracer . print_trace_start (& state , "ASC_SYMBOL") ; let result = (|| { let result = ASC_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ASC_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ASCII_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ASCII") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ASCII_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ASCII_SYMBOL > { global . tracer . print_trace_start (& state , "ASCII_SYMBOL") ; let result = (|| { let result = ASCII_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ASCII_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ASENSITIVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ASENSITIVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ASENSITIVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ASENSITIVE_SYMBOL > { global . tracer . print_trace_start (& state , "ASENSITIVE_SYMBOL") ; let result = (|| { let result = ASENSITIVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ASENSITIVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AT_SYMBOL > { global . tracer . print_trace_start (& state , "AT_SYMBOL") ; let result = (|| { let result = AT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AUTHORS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AUTHORS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AUTHORS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AUTHORS_SYMBOL > { global . tracer . print_trace_start (& state , "AUTHORS_SYMBOL") ; let result = (|| { let result = AUTHORS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AUTHORS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AUTOEXTEND_SIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AUTOEXTEND_SIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AUTOEXTEND_SIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AUTOEXTEND_SIZE_SYMBOL > { global . tracer . print_trace_start (& state , "AUTOEXTEND_SIZE_SYMBOL") ; let result = (|| { let result = AUTOEXTEND_SIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AUTOEXTEND_SIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AUTO_INCREMENT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AUTO_INCREMENT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AUTO_INCREMENT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AUTO_INCREMENT_SYMBOL > { global . tracer . print_trace_start (& state , "AUTO_INCREMENT_SYMBOL") ; let result = (|| { let result = AUTO_INCREMENT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AUTO_INCREMENT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AVG_ROW_LENGTH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AVG_ROW_LENGTH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AVG_ROW_LENGTH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AVG_ROW_LENGTH_SYMBOL > { global . tracer . print_trace_start (& state , "AVG_ROW_LENGTH_SYMBOL") ; let result = (|| { let result = AVG_ROW_LENGTH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AVG_ROW_LENGTH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod AVG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "AVG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_AVG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , AVG_SYMBOL > { global . tracer . print_trace_start (& state , "AVG_SYMBOL") ; let result = (|| { let result = AVG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: AVG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BACKUP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BACKUP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BACKUP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BACKUP_SYMBOL > { global . tracer . print_trace_start (& state , "BACKUP_SYMBOL") ; let result = (|| { let result = BACKUP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BACKUP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BEFORE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BEFORE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BEFORE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BEFORE_SYMBOL > { global . tracer . print_trace_start (& state , "BEFORE_SYMBOL") ; let result = (|| { let result = BEFORE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BEFORE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BEGIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BEGIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BEGIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BEGIN_SYMBOL > { global . tracer . print_trace_start (& state , "BEGIN_SYMBOL") ; let result = (|| { let result = BEGIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BEGIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BETWEEN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BETWEEN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BETWEEN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BETWEEN_SYMBOL > { global . tracer . print_trace_start (& state , "BETWEEN_SYMBOL") ; let result = (|| { let result = BETWEEN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BETWEEN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BIGINT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BIGINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BIGINT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BIGINT_SYMBOL > { global . tracer . print_trace_start (& state , "BIGINT_SYMBOL") ; let result = (|| { let result = BIGINT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BIGINT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BINARY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BINARY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BINARY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BINARY_SYMBOL > { global . tracer . print_trace_start (& state , "BINARY_SYMBOL") ; let result = (|| { let result = BINARY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BINARY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BINLOG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BINLOG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BINLOG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BINLOG_SYMBOL > { global . tracer . print_trace_start (& state , "BINLOG_SYMBOL") ; let result = (|| { let result = BINLOG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BINLOG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BIN_NUM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BIN_NUM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BIN_NUM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BIN_NUM_SYMBOL > { global . tracer . print_trace_start (& state , "BIN_NUM_SYMBOL") ; let result = (|| { let result = BIN_NUM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BIN_NUM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BIT_AND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BIT_AND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BIT_AND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BIT_AND_SYMBOL > { global . tracer . print_trace_start (& state , "BIT_AND_SYMBOL") ; let result = (|| { let result = BIT_AND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BIT_AND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BIT_OR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BIT_OR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BIT_OR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BIT_OR_SYMBOL > { global . tracer . print_trace_start (& state , "BIT_OR_SYMBOL") ; let result = (|| { let result = BIT_OR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BIT_OR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BIT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BIT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BIT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BIT_SYMBOL > { global . tracer . print_trace_start (& state , "BIT_SYMBOL") ; let result = (|| { let result = BIT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BIT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BIT_XOR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BIT_XOR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BIT_XOR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BIT_XOR_SYMBOL > { global . tracer . print_trace_start (& state , "BIT_XOR_SYMBOL") ; let result = (|| { let result = BIT_XOR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BIT_XOR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BLOB_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BLOB") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BLOB_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BLOB_SYMBOL > { global . tracer . print_trace_start (& state , "BLOB_SYMBOL") ; let result = (|| { let result = BLOB_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BLOB_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BLOCK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BLOCK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BLOCK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BLOCK_SYMBOL > { global . tracer . print_trace_start (& state , "BLOCK_SYMBOL") ; let result = (|| { let result = BLOCK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BLOCK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BOOLEAN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BOOLEAN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BOOLEAN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BOOLEAN_SYMBOL > { global . tracer . print_trace_start (& state , "BOOLEAN_SYMBOL") ; let result = (|| { let result = BOOLEAN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BOOLEAN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BOOL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BOOL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BOOL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BOOL_SYMBOL > { global . tracer . print_trace_start (& state , "BOOL_SYMBOL") ; let result = (|| { let result = BOOL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BOOL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BOTH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BOTH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BOTH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BOTH_SYMBOL > { global . tracer . print_trace_start (& state , "BOTH_SYMBOL") ; let result = (|| { let result = BOTH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BOTH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BTREE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BTREE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BTREE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BTREE_SYMBOL > { global . tracer . print_trace_start (& state , "BTREE_SYMBOL") ; let result = (|| { let result = BTREE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BTREE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BY_SYMBOL > { global . tracer . print_trace_start (& state , "BY_SYMBOL") ; let result = (|| { let result = BY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BYTE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BYTE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BYTE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BYTE_SYMBOL > { global . tracer . print_trace_start (& state , "BYTE_SYMBOL") ; let result = (|| { let result = BYTE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BYTE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CACHE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CACHE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CACHE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CACHE_SYMBOL > { global . tracer . print_trace_start (& state , "CACHE_SYMBOL") ; let result = (|| { let result = CACHE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CACHE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CALL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CALL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CALL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CALL_SYMBOL > { global . tracer . print_trace_start (& state , "CALL_SYMBOL") ; let result = (|| { let result = CALL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CALL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CASCADE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CASCADE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CASCADE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CASCADE_SYMBOL > { global . tracer . print_trace_start (& state , "CASCADE_SYMBOL") ; let result = (|| { let result = CASCADE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CASCADE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CASCADED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CASCADED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CASCADED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CASCADED_SYMBOL > { global . tracer . print_trace_start (& state , "CASCADED_SYMBOL") ; let result = (|| { let result = CASCADED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CASCADED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CASE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CASE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CASE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CASE_SYMBOL > { global . tracer . print_trace_start (& state , "CASE_SYMBOL") ; let result = (|| { let result = CASE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CASE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CAST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CAST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CAST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CAST_SYMBOL > { global . tracer . print_trace_start (& state , "CAST_SYMBOL") ; let result = (|| { let result = CAST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CAST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CATALOG_NAME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CATALOG_NAME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CATALOG_NAME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CATALOG_NAME_SYMBOL > { global . tracer . print_trace_start (& state , "CATALOG_NAME_SYMBOL") ; let result = (|| { let result = CATALOG_NAME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CATALOG_NAME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CHAIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CHAIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CHAIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CHAIN_SYMBOL > { global . tracer . print_trace_start (& state , "CHAIN_SYMBOL") ; let result = (|| { let result = CHAIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CHAIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CHANGE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CHANGE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CHANGE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CHANGE_SYMBOL > { global . tracer . print_trace_start (& state , "CHANGE_SYMBOL") ; let result = (|| { let result = CHANGE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CHANGE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CHANGED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CHANGED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CHANGED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CHANGED_SYMBOL > { global . tracer . print_trace_start (& state , "CHANGED_SYMBOL") ; let result = (|| { let result = CHANGED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CHANGED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CHANNEL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CHANNEL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CHANNEL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CHANNEL_SYMBOL > { global . tracer . print_trace_start (& state , "CHANNEL_SYMBOL") ; let result = (|| { let result = CHANNEL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CHANNEL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CHARSET_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CHARSET") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CHARSET_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CHARSET_SYMBOL > { global . tracer . print_trace_start (& state , "CHARSET_SYMBOL") ; let result = (|| { let result = CHARSET_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CHARSET_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CHARACTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CHARACTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CHARACTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CHARACTER_SYMBOL > { global . tracer . print_trace_start (& state , "CHARACTER_SYMBOL") ; let result = (|| { let result = CHARACTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CHARACTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CHAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CHAR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CHAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CHAR_SYMBOL > { global . tracer . print_trace_start (& state , "CHAR_SYMBOL") ; let result = (|| { let result = CHAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CHAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CHECKSUM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CHECKSUM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CHECKSUM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CHECKSUM_SYMBOL > { global . tracer . print_trace_start (& state , "CHECKSUM_SYMBOL") ; let result = (|| { let result = CHECKSUM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CHECKSUM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CHECK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CHECK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CHECK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CHECK_SYMBOL > { global . tracer . print_trace_start (& state , "CHECK_SYMBOL") ; let result = (|| { let result = CHECK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CHECK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CIPHER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CIPHER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CIPHER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CIPHER_SYMBOL > { global . tracer . print_trace_start (& state , "CIPHER_SYMBOL") ; let result = (|| { let result = CIPHER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CIPHER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CLASS_ORIGIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CLASS_ORIGIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CLASS_ORIGIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CLASS_ORIGIN_SYMBOL > { global . tracer . print_trace_start (& state , "CLASS_ORIGIN_SYMBOL") ; let result = (|| { let result = CLASS_ORIGIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CLASS_ORIGIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CLIENT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CLIENT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CLIENT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CLIENT_SYMBOL > { global . tracer . print_trace_start (& state , "CLIENT_SYMBOL") ; let result = (|| { let result = CLIENT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CLIENT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CLOSE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CLOSE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CLOSE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CLOSE_SYMBOL > { global . tracer . print_trace_start (& state , "CLOSE_SYMBOL") ; let result = (|| { let result = CLOSE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CLOSE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COALESCE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COALESCE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COALESCE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COALESCE_SYMBOL > { global . tracer . print_trace_start (& state , "COALESCE_SYMBOL") ; let result = (|| { let result = COALESCE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COALESCE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CODE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CODE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CODE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CODE_SYMBOL > { global . tracer . print_trace_start (& state , "CODE_SYMBOL") ; let result = (|| { let result = CODE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CODE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COLLATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COLLATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COLLATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COLLATE_SYMBOL > { global . tracer . print_trace_start (& state , "COLLATE_SYMBOL") ; let result = (|| { let result = COLLATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COLLATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COLLATION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COLLATION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COLLATION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COLLATION_SYMBOL > { global . tracer . print_trace_start (& state , "COLLATION_SYMBOL") ; let result = (|| { let result = COLLATION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COLLATION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COLUMNS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COLUMNS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COLUMNS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COLUMNS_SYMBOL > { global . tracer . print_trace_start (& state , "COLUMNS_SYMBOL") ; let result = (|| { let result = COLUMNS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COLUMNS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COLUMN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COLUMN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COLUMN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COLUMN_SYMBOL > { global . tracer . print_trace_start (& state , "COLUMN_SYMBOL") ; let result = (|| { let result = COLUMN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COLUMN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COLUMN_NAME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COLUMN_NAME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COLUMN_NAME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COLUMN_NAME_SYMBOL > { global . tracer . print_trace_start (& state , "COLUMN_NAME_SYMBOL") ; let result = (|| { let result = COLUMN_NAME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COLUMN_NAME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COLUMN_FORMAT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COLUMN_FORMAT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COLUMN_FORMAT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COLUMN_FORMAT_SYMBOL > { global . tracer . print_trace_start (& state , "COLUMN_FORMAT_SYMBOL") ; let result = (|| { let result = COLUMN_FORMAT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COLUMN_FORMAT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COMMENT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COMMENT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COMMENT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COMMENT_SYMBOL > { global . tracer . print_trace_start (& state , "COMMENT_SYMBOL") ; let result = (|| { let result = COMMENT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COMMENT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COMMITTED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COMMITTED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COMMITTED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COMMITTED_SYMBOL > { global . tracer . print_trace_start (& state , "COMMITTED_SYMBOL") ; let result = (|| { let result = COMMITTED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COMMITTED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COMMIT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COMMIT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COMMIT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COMMIT_SYMBOL > { global . tracer . print_trace_start (& state , "COMMIT_SYMBOL") ; let result = (|| { let result = COMMIT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COMMIT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COMPACT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COMPACT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COMPACT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COMPACT_SYMBOL > { global . tracer . print_trace_start (& state , "COMPACT_SYMBOL") ; let result = (|| { let result = COMPACT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COMPACT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COMPLETION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COMPLETION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COMPLETION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COMPLETION_SYMBOL > { global . tracer . print_trace_start (& state , "COMPLETION_SYMBOL") ; let result = (|| { let result = COMPLETION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COMPLETION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COMPRESSED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COMPRESSED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COMPRESSED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COMPRESSED_SYMBOL > { global . tracer . print_trace_start (& state , "COMPRESSED_SYMBOL") ; let result = (|| { let result = COMPRESSED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COMPRESSED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COMPRESSION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COMPRESSION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COMPRESSION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COMPRESSION_SYMBOL > { global . tracer . print_trace_start (& state , "COMPRESSION_SYMBOL") ; let result = (|| { let result = COMPRESSION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COMPRESSION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONCURRENT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONCURRENT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONCURRENT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONCURRENT_SYMBOL > { global . tracer . print_trace_start (& state , "CONCURRENT_SYMBOL") ; let result = (|| { let result = CONCURRENT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONCURRENT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONDITION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONDITION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONDITION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONDITION_SYMBOL > { global . tracer . print_trace_start (& state , "CONDITION_SYMBOL") ; let result = (|| { let result = CONDITION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONDITION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONNECTION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONNECTION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONNECTION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONNECTION_SYMBOL > { global . tracer . print_trace_start (& state , "CONNECTION_SYMBOL") ; let result = (|| { let result = CONNECTION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONNECTION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONSISTENT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONSISTENT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONSISTENT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONSISTENT_SYMBOL > { global . tracer . print_trace_start (& state , "CONSISTENT_SYMBOL") ; let result = (|| { let result = CONSISTENT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONSISTENT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONSTRAINT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONSTRAINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONSTRAINT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONSTRAINT_SYMBOL > { global . tracer . print_trace_start (& state , "CONSTRAINT_SYMBOL") ; let result = (|| { let result = CONSTRAINT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONSTRAINT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONSTRAINT_CATALOG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONSTRAINT_CATALOG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONSTRAINT_CATALOG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONSTRAINT_CATALOG_SYMBOL > { global . tracer . print_trace_start (& state , "CONSTRAINT_CATALOG_SYMBOL") ; let result = (|| { let result = CONSTRAINT_CATALOG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONSTRAINT_CATALOG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONSTRAINT_NAME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONSTRAINT_NAME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONSTRAINT_NAME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONSTRAINT_NAME_SYMBOL > { global . tracer . print_trace_start (& state , "CONSTRAINT_NAME_SYMBOL") ; let result = (|| { let result = CONSTRAINT_NAME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONSTRAINT_NAME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONSTRAINT_SCHEMA_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONSTRAINT_SCHEMA") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONSTRAINT_SCHEMA_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONSTRAINT_SCHEMA_SYMBOL > { global . tracer . print_trace_start (& state , "CONSTRAINT_SCHEMA_SYMBOL") ; let result = (|| { let result = CONSTRAINT_SCHEMA_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONSTRAINT_SCHEMA_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONTAINS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONTAINS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONTAINS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONTAINS_SYMBOL > { global . tracer . print_trace_start (& state , "CONTAINS_SYMBOL") ; let result = (|| { let result = CONTAINS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONTAINS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONTEXT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONTEXT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONTEXT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONTEXT_SYMBOL > { global . tracer . print_trace_start (& state , "CONTEXT_SYMBOL") ; let result = (|| { let result = CONTEXT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONTEXT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONTINUE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONTINUE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONTINUE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONTINUE_SYMBOL > { global . tracer . print_trace_start (& state , "CONTINUE_SYMBOL") ; let result = (|| { let result = CONTINUE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONTINUE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONTRIBUTORS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONTRIBUTORS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONTRIBUTORS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONTRIBUTORS_SYMBOL > { global . tracer . print_trace_start (& state , "CONTRIBUTORS_SYMBOL") ; let result = (|| { let result = CONTRIBUTORS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONTRIBUTORS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONVERT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CONVERT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONVERT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONVERT_SYMBOL > { global . tracer . print_trace_start (& state , "CONVERT_SYMBOL") ; let result = (|| { let result = CONVERT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONVERT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COUNT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COUNT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COUNT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COUNT_SYMBOL > { global . tracer . print_trace_start (& state , "COUNT_SYMBOL") ; let result = (|| { let result = COUNT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COUNT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CPU_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CPU") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CPU_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CPU_SYMBOL > { global . tracer . print_trace_start (& state , "CPU_SYMBOL") ; let result = (|| { let result = CPU_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CPU_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CREATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CREATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CREATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CREATE_SYMBOL > { global . tracer . print_trace_start (& state , "CREATE_SYMBOL") ; let result = (|| { let result = CREATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CREATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CROSS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CROSS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CROSS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CROSS_SYMBOL > { global . tracer . print_trace_start (& state , "CROSS_SYMBOL") ; let result = (|| { let result = CROSS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CROSS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CUBE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CUBE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CUBE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CUBE_SYMBOL > { global . tracer . print_trace_start (& state , "CUBE_SYMBOL") ; let result = (|| { let result = CUBE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CUBE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CURDATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CURDATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CURDATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CURDATE_SYMBOL > { global . tracer . print_trace_start (& state , "CURDATE_SYMBOL") ; let result = (|| { let result = CURDATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CURDATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CURRENT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CURRENT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CURRENT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CURRENT_SYMBOL > { global . tracer . print_trace_start (& state , "CURRENT_SYMBOL") ; let result = (|| { let result = CURRENT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CURRENT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CURRENT_DATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CURRENT_DATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CURRENT_DATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CURRENT_DATE_SYMBOL > { global . tracer . print_trace_start (& state , "CURRENT_DATE_SYMBOL") ; let result = (|| { let result = CURRENT_DATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CURRENT_DATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CURRENT_TIME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CURRENT_TIME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CURRENT_TIME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CURRENT_TIME_SYMBOL > { global . tracer . print_trace_start (& state , "CURRENT_TIME_SYMBOL") ; let result = (|| { let result = CURRENT_TIME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CURRENT_TIME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CURRENT_TIMESTAMP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CURRENT_TIMESTAMP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CURRENT_TIMESTAMP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CURRENT_TIMESTAMP_SYMBOL > { global . tracer . print_trace_start (& state , "CURRENT_TIMESTAMP_SYMBOL") ; let result = (|| { let result = CURRENT_TIMESTAMP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CURRENT_TIMESTAMP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CURRENT_USER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CURRENT_USER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CURRENT_USER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CURRENT_USER_SYMBOL > { global . tracer . print_trace_start (& state , "CURRENT_USER_SYMBOL") ; let result = (|| { let result = CURRENT_USER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CURRENT_USER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CURSOR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CURSOR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CURSOR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CURSOR_SYMBOL > { global . tracer . print_trace_start (& state , "CURSOR_SYMBOL") ; let result = (|| { let result = CURSOR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CURSOR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CURSOR_NAME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CURSOR_NAME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CURSOR_NAME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CURSOR_NAME_SYMBOL > { global . tracer . print_trace_start (& state , "CURSOR_NAME_SYMBOL") ; let result = (|| { let result = CURSOR_NAME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CURSOR_NAME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CURTIME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CURTIME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CURTIME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CURTIME_SYMBOL > { global . tracer . print_trace_start (& state , "CURTIME_SYMBOL") ; let result = (|| { let result = CURTIME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CURTIME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DATABASE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DATABASE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DATABASE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DATABASE_SYMBOL > { global . tracer . print_trace_start (& state , "DATABASE_SYMBOL") ; let result = (|| { let result = DATABASE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DATABASE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DATABASES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DATABASES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DATABASES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DATABASES_SYMBOL > { global . tracer . print_trace_start (& state , "DATABASES_SYMBOL") ; let result = (|| { let result = DATABASES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DATABASES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DATAFILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DATAFILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DATAFILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DATAFILE_SYMBOL > { global . tracer . print_trace_start (& state , "DATAFILE_SYMBOL") ; let result = (|| { let result = DATAFILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DATAFILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DATA_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DATA") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DATA_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DATA_SYMBOL > { global . tracer . print_trace_start (& state , "DATA_SYMBOL") ; let result = (|| { let result = DATA_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DATA_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DATETIME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DATETIME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DATETIME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DATETIME_SYMBOL > { global . tracer . print_trace_start (& state , "DATETIME_SYMBOL") ; let result = (|| { let result = DATETIME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DATETIME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DATE_ADD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DATE_ADD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DATE_ADD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DATE_ADD_SYMBOL > { global . tracer . print_trace_start (& state , "DATE_ADD_SYMBOL") ; let result = (|| { let result = DATE_ADD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DATE_ADD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DATE_SUB_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DATE_SUB") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DATE_SUB_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DATE_SUB_SYMBOL > { global . tracer . print_trace_start (& state , "DATE_SUB_SYMBOL") ; let result = (|| { let result = DATE_SUB_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DATE_SUB_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DATE_SYMBOL > { global . tracer . print_trace_start (& state , "DATE_SYMBOL") ; let result = (|| { let result = DATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DAYOFMONTH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DAYOFMONTH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DAYOFMONTH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DAYOFMONTH_SYMBOL > { global . tracer . print_trace_start (& state , "DAYOFMONTH_SYMBOL") ; let result = (|| { let result = DAYOFMONTH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DAYOFMONTH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DAY_HOUR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DAY_HOUR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DAY_HOUR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DAY_HOUR_SYMBOL > { global . tracer . print_trace_start (& state , "DAY_HOUR_SYMBOL") ; let result = (|| { let result = DAY_HOUR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DAY_HOUR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DAY_MICROSECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DAY_MICROSECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DAY_MICROSECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DAY_MICROSECOND_SYMBOL > { global . tracer . print_trace_start (& state , "DAY_MICROSECOND_SYMBOL") ; let result = (|| { let result = DAY_MICROSECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DAY_MICROSECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DAY_MINUTE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DAY_MINUTE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DAY_MINUTE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DAY_MINUTE_SYMBOL > { global . tracer . print_trace_start (& state , "DAY_MINUTE_SYMBOL") ; let result = (|| { let result = DAY_MINUTE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DAY_MINUTE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DAY_SECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DAY_SECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DAY_SECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DAY_SECOND_SYMBOL > { global . tracer . print_trace_start (& state , "DAY_SECOND_SYMBOL") ; let result = (|| { let result = DAY_SECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DAY_SECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DAY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DAY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DAY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DAY_SYMBOL > { global . tracer . print_trace_start (& state , "DAY_SYMBOL") ; let result = (|| { let result = DAY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DAY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DEALLOCATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DEALLOCATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DEALLOCATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DEALLOCATE_SYMBOL > { global . tracer . print_trace_start (& state , "DEALLOCATE_SYMBOL") ; let result = (|| { let result = DEALLOCATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DEALLOCATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DEC_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DEC") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DEC_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DEC_SYMBOL > { global . tracer . print_trace_start (& state , "DEC_SYMBOL") ; let result = (|| { let result = DEC_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DEC_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DECIMAL_NUM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DECIMAL_NUM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DECIMAL_NUM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DECIMAL_NUM_SYMBOL > { global . tracer . print_trace_start (& state , "DECIMAL_NUM_SYMBOL") ; let result = (|| { let result = DECIMAL_NUM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DECIMAL_NUM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DECIMAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DECIMAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DECIMAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DECIMAL_SYMBOL > { global . tracer . print_trace_start (& state , "DECIMAL_SYMBOL") ; let result = (|| { let result = DECIMAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DECIMAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DECLARE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DECLARE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DECLARE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DECLARE_SYMBOL > { global . tracer . print_trace_start (& state , "DECLARE_SYMBOL") ; let result = (|| { let result = DECLARE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DECLARE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DEFAULT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DEFAULT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DEFAULT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DEFAULT_SYMBOL > { global . tracer . print_trace_start (& state , "DEFAULT_SYMBOL") ; let result = (|| { let result = DEFAULT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DEFAULT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DEFAULT_AUTH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DEFAULT_AUTH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DEFAULT_AUTH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DEFAULT_AUTH_SYMBOL > { global . tracer . print_trace_start (& state , "DEFAULT_AUTH_SYMBOL") ; let result = (|| { let result = DEFAULT_AUTH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DEFAULT_AUTH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DEFINER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DEFINER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DEFINER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DEFINER_SYMBOL > { global . tracer . print_trace_start (& state , "DEFINER_SYMBOL") ; let result = (|| { let result = DEFINER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DEFINER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DELAYED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DELAYED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DELAYED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DELAYED_SYMBOL > { global . tracer . print_trace_start (& state , "DELAYED_SYMBOL") ; let result = (|| { let result = DELAYED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DELAYED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DELAY_KEY_WRITE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DELAY_KEY_WRITE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DELAY_KEY_WRITE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DELAY_KEY_WRITE_SYMBOL > { global . tracer . print_trace_start (& state , "DELAY_KEY_WRITE_SYMBOL") ; let result = (|| { let result = DELAY_KEY_WRITE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DELAY_KEY_WRITE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DELETE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DELETE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DELETE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DELETE_SYMBOL > { global . tracer . print_trace_start (& state , "DELETE_SYMBOL") ; let result = (|| { let result = DELETE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DELETE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DESC_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DESC") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DESC_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DESC_SYMBOL > { global . tracer . print_trace_start (& state , "DESC_SYMBOL") ; let result = (|| { let result = DESC_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DESC_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DESCRIBE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DESCRIBE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DESCRIBE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DESCRIBE_SYMBOL > { global . tracer . print_trace_start (& state , "DESCRIBE_SYMBOL") ; let result = (|| { let result = DESCRIBE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DESCRIBE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DES_KEY_FILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DES_KEY_FILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DES_KEY_FILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DES_KEY_FILE_SYMBOL > { global . tracer . print_trace_start (& state , "DES_KEY_FILE_SYMBOL") ; let result = (|| { let result = DES_KEY_FILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DES_KEY_FILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DETERMINISTIC_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DETERMINISTIC") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DETERMINISTIC_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DETERMINISTIC_SYMBOL > { global . tracer . print_trace_start (& state , "DETERMINISTIC_SYMBOL") ; let result = (|| { let result = DETERMINISTIC_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DETERMINISTIC_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DIAGNOSTICS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DIAGNOSTICS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DIAGNOSTICS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DIAGNOSTICS_SYMBOL > { global . tracer . print_trace_start (& state , "DIAGNOSTICS_SYMBOL") ; let result = (|| { let result = DIAGNOSTICS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DIAGNOSTICS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DIRECTORY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DIRECTORY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DIRECTORY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DIRECTORY_SYMBOL > { global . tracer . print_trace_start (& state , "DIRECTORY_SYMBOL") ; let result = (|| { let result = DIRECTORY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DIRECTORY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DISABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DISABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DISABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DISABLE_SYMBOL > { global . tracer . print_trace_start (& state , "DISABLE_SYMBOL") ; let result = (|| { let result = DISABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DISABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DISCARD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DISCARD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DISCARD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DISCARD_SYMBOL > { global . tracer . print_trace_start (& state , "DISCARD_SYMBOL") ; let result = (|| { let result = DISCARD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DISCARD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DISK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DISK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DISK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DISK_SYMBOL > { global . tracer . print_trace_start (& state , "DISK_SYMBOL") ; let result = (|| { let result = DISK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DISK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DISTINCT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DISTINCT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DISTINCT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DISTINCT_SYMBOL > { global . tracer . print_trace_start (& state , "DISTINCT_SYMBOL") ; let result = (|| { let result = DISTINCT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DISTINCT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DISTINCTROW_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DISTINCTROW") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DISTINCTROW_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DISTINCTROW_SYMBOL > { global . tracer . print_trace_start (& state , "DISTINCTROW_SYMBOL") ; let result = (|| { let result = DISTINCTROW_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DISTINCTROW_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DIV_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DIV") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DIV_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DIV_SYMBOL > { global . tracer . print_trace_start (& state , "DIV_SYMBOL") ; let result = (|| { let result = DIV_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DIV_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DOUBLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DOUBLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DOUBLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DOUBLE_SYMBOL > { global . tracer . print_trace_start (& state , "DOUBLE_SYMBOL") ; let result = (|| { let result = DOUBLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DOUBLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DO_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DO") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DO_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DO_SYMBOL > { global . tracer . print_trace_start (& state , "DO_SYMBOL") ; let result = (|| { let result = DO_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DO_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DROP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DROP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DROP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DROP_SYMBOL > { global . tracer . print_trace_start (& state , "DROP_SYMBOL") ; let result = (|| { let result = DROP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DROP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DUAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DUAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DUAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DUAL_SYMBOL > { global . tracer . print_trace_start (& state , "DUAL_SYMBOL") ; let result = (|| { let result = DUAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DUAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DUMPFILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DUMPFILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DUMPFILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DUMPFILE_SYMBOL > { global . tracer . print_trace_start (& state , "DUMPFILE_SYMBOL") ; let result = (|| { let result = DUMPFILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DUMPFILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DUPLICATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DUPLICATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DUPLICATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DUPLICATE_SYMBOL > { global . tracer . print_trace_start (& state , "DUPLICATE_SYMBOL") ; let result = (|| { let result = DUPLICATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DUPLICATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DYNAMIC_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DYNAMIC") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DYNAMIC_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DYNAMIC_SYMBOL > { global . tracer . print_trace_start (& state , "DYNAMIC_SYMBOL") ; let result = (|| { let result = DYNAMIC_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DYNAMIC_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EACH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EACH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EACH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EACH_SYMBOL > { global . tracer . print_trace_start (& state , "EACH_SYMBOL") ; let result = (|| { let result = EACH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EACH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ELSE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ELSE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ELSE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ELSE_SYMBOL > { global . tracer . print_trace_start (& state , "ELSE_SYMBOL") ; let result = (|| { let result = ELSE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ELSE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ELSEIF_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ELSEIF") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ELSEIF_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ELSEIF_SYMBOL > { global . tracer . print_trace_start (& state , "ELSEIF_SYMBOL") ; let result = (|| { let result = ELSEIF_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ELSEIF_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ENABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ENABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ENABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ENABLE_SYMBOL > { global . tracer . print_trace_start (& state , "ENABLE_SYMBOL") ; let result = (|| { let result = ENABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ENABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ENCLOSED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ENCLOSED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ENCLOSED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ENCLOSED_SYMBOL > { global . tracer . print_trace_start (& state , "ENCLOSED_SYMBOL") ; let result = (|| { let result = ENCLOSED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ENCLOSED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ENCRYPTION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ENCRYPTION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ENCRYPTION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ENCRYPTION_SYMBOL > { global . tracer . print_trace_start (& state , "ENCRYPTION_SYMBOL") ; let result = (|| { let result = ENCRYPTION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ENCRYPTION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod END_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "END") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_END_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , END_SYMBOL > { global . tracer . print_trace_start (& state , "END_SYMBOL") ; let result = (|| { let result = END_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: END_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ENDS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ENDS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ENDS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ENDS_SYMBOL > { global . tracer . print_trace_start (& state , "ENDS_SYMBOL") ; let result = (|| { let result = ENDS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ENDS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod END_OF_INPUT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "END_OF_INPUT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_END_OF_INPUT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , END_OF_INPUT_SYMBOL > { global . tracer . print_trace_start (& state , "END_OF_INPUT_SYMBOL") ; let result = (|| { let result = END_OF_INPUT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: END_OF_INPUT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ENGINES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ENGINES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ENGINES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ENGINES_SYMBOL > { global . tracer . print_trace_start (& state , "ENGINES_SYMBOL") ; let result = (|| { let result = ENGINES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ENGINES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ENGINE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ENGINE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ENGINE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ENGINE_SYMBOL > { global . tracer . print_trace_start (& state , "ENGINE_SYMBOL") ; let result = (|| { let result = ENGINE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ENGINE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ENUM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ENUM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ENUM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ENUM_SYMBOL > { global . tracer . print_trace_start (& state , "ENUM_SYMBOL") ; let result = (|| { let result = ENUM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ENUM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ERROR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ERROR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ERROR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ERROR_SYMBOL > { global . tracer . print_trace_start (& state , "ERROR_SYMBOL") ; let result = (|| { let result = ERROR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ERROR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ERRORS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ERRORS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ERRORS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ERRORS_SYMBOL > { global . tracer . print_trace_start (& state , "ERRORS_SYMBOL") ; let result = (|| { let result = ERRORS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ERRORS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ESCAPED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ESCAPED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ESCAPED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ESCAPED_SYMBOL > { global . tracer . print_trace_start (& state , "ESCAPED_SYMBOL") ; let result = (|| { let result = ESCAPED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ESCAPED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ESCAPE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ESCAPE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ESCAPE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ESCAPE_SYMBOL > { global . tracer . print_trace_start (& state , "ESCAPE_SYMBOL") ; let result = (|| { let result = ESCAPE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ESCAPE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EVENTS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EVENTS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EVENTS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EVENTS_SYMBOL > { global . tracer . print_trace_start (& state , "EVENTS_SYMBOL") ; let result = (|| { let result = EVENTS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EVENTS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EVENT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EVENT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EVENT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EVENT_SYMBOL > { global . tracer . print_trace_start (& state , "EVENT_SYMBOL") ; let result = (|| { let result = EVENT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EVENT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EVERY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EVERY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EVERY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EVERY_SYMBOL > { global . tracer . print_trace_start (& state , "EVERY_SYMBOL") ; let result = (|| { let result = EVERY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EVERY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXCHANGE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXCHANGE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXCHANGE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXCHANGE_SYMBOL > { global . tracer . print_trace_start (& state , "EXCHANGE_SYMBOL") ; let result = (|| { let result = EXCHANGE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXCHANGE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXECUTE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXECUTE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXECUTE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXECUTE_SYMBOL > { global . tracer . print_trace_start (& state , "EXECUTE_SYMBOL") ; let result = (|| { let result = EXECUTE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXECUTE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXISTS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXISTS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXISTS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXISTS_SYMBOL > { global . tracer . print_trace_start (& state , "EXISTS_SYMBOL") ; let result = (|| { let result = EXISTS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXISTS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXIT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXIT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXIT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXIT_SYMBOL > { global . tracer . print_trace_start (& state , "EXIT_SYMBOL") ; let result = (|| { let result = EXIT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXIT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXPANSION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXPANSION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXPANSION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXPANSION_SYMBOL > { global . tracer . print_trace_start (& state , "EXPANSION_SYMBOL") ; let result = (|| { let result = EXPANSION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXPANSION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXPIRE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXPIRE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXPIRE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXPIRE_SYMBOL > { global . tracer . print_trace_start (& state , "EXPIRE_SYMBOL") ; let result = (|| { let result = EXPIRE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXPIRE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXPLAIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXPLAIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXPLAIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXPLAIN_SYMBOL > { global . tracer . print_trace_start (& state , "EXPLAIN_SYMBOL") ; let result = (|| { let result = EXPLAIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXPLAIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXPORT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXPORT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXPORT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXPORT_SYMBOL > { global . tracer . print_trace_start (& state , "EXPORT_SYMBOL") ; let result = (|| { let result = EXPORT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXPORT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXTENDED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXTENDED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXTENDED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXTENDED_SYMBOL > { global . tracer . print_trace_start (& state , "EXTENDED_SYMBOL") ; let result = (|| { let result = EXTENDED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXTENDED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXTENT_SIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXTENT_SIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXTENT_SIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXTENT_SIZE_SYMBOL > { global . tracer . print_trace_start (& state , "EXTENT_SIZE_SYMBOL") ; let result = (|| { let result = EXTENT_SIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXTENT_SIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXTRACT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXTRACT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXTRACT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXTRACT_SYMBOL > { global . tracer . print_trace_start (& state , "EXTRACT_SYMBOL") ; let result = (|| { let result = EXTRACT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXTRACT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FALSE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FALSE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FALSE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FALSE_SYMBOL > { global . tracer . print_trace_start (& state , "FALSE_SYMBOL") ; let result = (|| { let result = FALSE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FALSE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FAST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FAST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FAST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FAST_SYMBOL > { global . tracer . print_trace_start (& state , "FAST_SYMBOL") ; let result = (|| { let result = FAST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FAST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FAULTS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FAULTS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FAULTS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FAULTS_SYMBOL > { global . tracer . print_trace_start (& state , "FAULTS_SYMBOL") ; let result = (|| { let result = FAULTS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FAULTS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FETCH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FETCH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FETCH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FETCH_SYMBOL > { global . tracer . print_trace_start (& state , "FETCH_SYMBOL") ; let result = (|| { let result = FETCH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FETCH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FIELDS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FIELDS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FIELDS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FIELDS_SYMBOL > { global . tracer . print_trace_start (& state , "FIELDS_SYMBOL") ; let result = (|| { let result = FIELDS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FIELDS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FILE_SYMBOL > { global . tracer . print_trace_start (& state , "FILE_SYMBOL") ; let result = (|| { let result = FILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FILE_BLOCK_SIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FILE_BLOCK_SIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FILE_BLOCK_SIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FILE_BLOCK_SIZE_SYMBOL > { global . tracer . print_trace_start (& state , "FILE_BLOCK_SIZE_SYMBOL") ; let result = (|| { let result = FILE_BLOCK_SIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FILE_BLOCK_SIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FILTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FILTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FILTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FILTER_SYMBOL > { global . tracer . print_trace_start (& state , "FILTER_SYMBOL") ; let result = (|| { let result = FILTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FILTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FIRST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FIRST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FIRST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FIRST_SYMBOL > { global . tracer . print_trace_start (& state , "FIRST_SYMBOL") ; let result = (|| { let result = FIRST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FIRST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FIXED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FIXED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FIXED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FIXED_SYMBOL > { global . tracer . print_trace_start (& state , "FIXED_SYMBOL") ; let result = (|| { let result = FIXED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FIXED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FLOAT4_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FLOAT4") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FLOAT4_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FLOAT4_SYMBOL > { global . tracer . print_trace_start (& state , "FLOAT4_SYMBOL") ; let result = (|| { let result = FLOAT4_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FLOAT4_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FLOAT8_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FLOAT8") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FLOAT8_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FLOAT8_SYMBOL > { global . tracer . print_trace_start (& state , "FLOAT8_SYMBOL") ; let result = (|| { let result = FLOAT8_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FLOAT8_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FLOAT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FLOAT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FLOAT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FLOAT_SYMBOL > { global . tracer . print_trace_start (& state , "FLOAT_SYMBOL") ; let result = (|| { let result = FLOAT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FLOAT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FLUSH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FLUSH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FLUSH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FLUSH_SYMBOL > { global . tracer . print_trace_start (& state , "FLUSH_SYMBOL") ; let result = (|| { let result = FLUSH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FLUSH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FOLLOWS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FOLLOWS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FOLLOWS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FOLLOWS_SYMBOL > { global . tracer . print_trace_start (& state , "FOLLOWS_SYMBOL") ; let result = (|| { let result = FOLLOWS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FOLLOWS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FORCE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FORCE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FORCE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FORCE_SYMBOL > { global . tracer . print_trace_start (& state , "FORCE_SYMBOL") ; let result = (|| { let result = FORCE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FORCE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FOREIGN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FOREIGN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FOREIGN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FOREIGN_SYMBOL > { global . tracer . print_trace_start (& state , "FOREIGN_SYMBOL") ; let result = (|| { let result = FOREIGN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FOREIGN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FOR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FOR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FOR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FOR_SYMBOL > { global . tracer . print_trace_start (& state , "FOR_SYMBOL") ; let result = (|| { let result = FOR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FOR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FORMAT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FORMAT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FORMAT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FORMAT_SYMBOL > { global . tracer . print_trace_start (& state , "FORMAT_SYMBOL") ; let result = (|| { let result = FORMAT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FORMAT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FOUND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FOUND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FOUND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FOUND_SYMBOL > { global . tracer . print_trace_start (& state , "FOUND_SYMBOL") ; let result = (|| { let result = FOUND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FOUND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FROM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FROM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FROM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FROM_SYMBOL > { global . tracer . print_trace_start (& state , "FROM_SYMBOL") ; let result = (|| { let result = FROM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FROM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FULL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FULL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FULL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FULL_SYMBOL > { global . tracer . print_trace_start (& state , "FULL_SYMBOL") ; let result = (|| { let result = FULL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FULL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FULLTEXT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FULLTEXT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FULLTEXT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FULLTEXT_SYMBOL > { global . tracer . print_trace_start (& state , "FULLTEXT_SYMBOL") ; let result = (|| { let result = FULLTEXT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FULLTEXT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FUNCTION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FUNCTION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FUNCTION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FUNCTION_SYMBOL > { global . tracer . print_trace_start (& state , "FUNCTION_SYMBOL") ; let result = (|| { let result = FUNCTION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FUNCTION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GET_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GET") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GET_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GET_SYMBOL > { global . tracer . print_trace_start (& state , "GET_SYMBOL") ; let result = (|| { let result = GET_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GET_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GENERAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GENERAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GENERAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GENERAL_SYMBOL > { global . tracer . print_trace_start (& state , "GENERAL_SYMBOL") ; let result = (|| { let result = GENERAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GENERAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GENERATED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GENERATED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GENERATED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GENERATED_SYMBOL > { global . tracer . print_trace_start (& state , "GENERATED_SYMBOL") ; let result = (|| { let result = GENERATED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GENERATED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GROUP_REPLICATION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GROUP_REPLICATION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GROUP_REPLICATION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GROUP_REPLICATION_SYMBOL > { global . tracer . print_trace_start (& state , "GROUP_REPLICATION_SYMBOL") ; let result = (|| { let result = GROUP_REPLICATION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GROUP_REPLICATION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GEOMETRYCOLLECTION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GEOMETRYCOLLECTION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GEOMETRYCOLLECTION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GEOMETRYCOLLECTION_SYMBOL > { global . tracer . print_trace_start (& state , "GEOMETRYCOLLECTION_SYMBOL") ; let result = (|| { let result = GEOMETRYCOLLECTION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GEOMETRYCOLLECTION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GEOMETRY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GEOMETRY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GEOMETRY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GEOMETRY_SYMBOL > { global . tracer . print_trace_start (& state , "GEOMETRY_SYMBOL") ; let result = (|| { let result = GEOMETRY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GEOMETRY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GET_FORMAT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GET_FORMAT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GET_FORMAT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GET_FORMAT_SYMBOL > { global . tracer . print_trace_start (& state , "GET_FORMAT_SYMBOL") ; let result = (|| { let result = GET_FORMAT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GET_FORMAT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GLOBAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GLOBAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GLOBAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GLOBAL_SYMBOL > { global . tracer . print_trace_start (& state , "GLOBAL_SYMBOL") ; let result = (|| { let result = GLOBAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GLOBAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GRANT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GRANT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GRANT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GRANT_SYMBOL > { global . tracer . print_trace_start (& state , "GRANT_SYMBOL") ; let result = (|| { let result = GRANT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GRANT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GRANTS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GRANTS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GRANTS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GRANTS_SYMBOL > { global . tracer . print_trace_start (& state , "GRANTS_SYMBOL") ; let result = (|| { let result = GRANTS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GRANTS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GROUP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GROUP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GROUP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GROUP_SYMBOL > { global . tracer . print_trace_start (& state , "GROUP_SYMBOL") ; let result = (|| { let result = GROUP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GROUP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GROUP_CONCAT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GROUP_CONCAT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GROUP_CONCAT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GROUP_CONCAT_SYMBOL > { global . tracer . print_trace_start (& state , "GROUP_CONCAT_SYMBOL") ; let result = (|| { let result = GROUP_CONCAT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GROUP_CONCAT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HANDLER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HANDLER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HANDLER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HANDLER_SYMBOL > { global . tracer . print_trace_start (& state , "HANDLER_SYMBOL") ; let result = (|| { let result = HANDLER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HANDLER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HASH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HASH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HASH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HASH_SYMBOL > { global . tracer . print_trace_start (& state , "HASH_SYMBOL") ; let result = (|| { let result = HASH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HASH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HAVING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HAVING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HAVING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HAVING_SYMBOL > { global . tracer . print_trace_start (& state , "HAVING_SYMBOL") ; let result = (|| { let result = HAVING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HAVING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HELP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HELP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HELP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HELP_SYMBOL > { global . tracer . print_trace_start (& state , "HELP_SYMBOL") ; let result = (|| { let result = HELP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HELP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HIGH_PRIORITY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HIGH_PRIORITY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HIGH_PRIORITY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HIGH_PRIORITY_SYMBOL > { global . tracer . print_trace_start (& state , "HIGH_PRIORITY_SYMBOL") ; let result = (|| { let result = HIGH_PRIORITY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HIGH_PRIORITY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HOST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HOST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HOST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HOST_SYMBOL > { global . tracer . print_trace_start (& state , "HOST_SYMBOL") ; let result = (|| { let result = HOST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HOST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HOSTS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HOSTS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HOSTS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HOSTS_SYMBOL > { global . tracer . print_trace_start (& state , "HOSTS_SYMBOL") ; let result = (|| { let result = HOSTS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HOSTS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HOUR_MICROSECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HOUR_MICROSECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HOUR_MICROSECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HOUR_MICROSECOND_SYMBOL > { global . tracer . print_trace_start (& state , "HOUR_MICROSECOND_SYMBOL") ; let result = (|| { let result = HOUR_MICROSECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HOUR_MICROSECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HOUR_MINUTE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HOUR_MINUTE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HOUR_MINUTE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HOUR_MINUTE_SYMBOL > { global . tracer . print_trace_start (& state , "HOUR_MINUTE_SYMBOL") ; let result = (|| { let result = HOUR_MINUTE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HOUR_MINUTE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HOUR_SECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HOUR_SECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HOUR_SECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HOUR_SECOND_SYMBOL > { global . tracer . print_trace_start (& state , "HOUR_SECOND_SYMBOL") ; let result = (|| { let result = HOUR_SECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HOUR_SECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HOUR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HOUR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HOUR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HOUR_SYMBOL > { global . tracer . print_trace_start (& state , "HOUR_SYMBOL") ; let result = (|| { let result = HOUR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HOUR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IDENTIFIED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IDENTIFIED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IDENTIFIED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IDENTIFIED_SYMBOL > { global . tracer . print_trace_start (& state , "IDENTIFIED_SYMBOL") ; let result = (|| { let result = IDENTIFIED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IDENTIFIED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IF_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IF") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IF_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IF_SYMBOL > { global . tracer . print_trace_start (& state , "IF_SYMBOL") ; let result = (|| { let result = IF_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IF_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IGNORE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IGNORE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IGNORE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IGNORE_SYMBOL > { global . tracer . print_trace_start (& state , "IGNORE_SYMBOL") ; let result = (|| { let result = IGNORE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IGNORE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IGNORE_SERVER_IDS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IGNORE_SERVER_IDS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IGNORE_SERVER_IDS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IGNORE_SERVER_IDS_SYMBOL > { global . tracer . print_trace_start (& state , "IGNORE_SERVER_IDS_SYMBOL") ; let result = (|| { let result = IGNORE_SERVER_IDS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IGNORE_SERVER_IDS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IMPORT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IMPORT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IMPORT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IMPORT_SYMBOL > { global . tracer . print_trace_start (& state , "IMPORT_SYMBOL") ; let result = (|| { let result = IMPORT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IMPORT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INDEXES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INDEXES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INDEXES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INDEXES_SYMBOL > { global . tracer . print_trace_start (& state , "INDEXES_SYMBOL") ; let result = (|| { let result = INDEXES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INDEXES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INDEX_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INDEX") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INDEX_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INDEX_SYMBOL > { global . tracer . print_trace_start (& state , "INDEX_SYMBOL") ; let result = (|| { let result = INDEX_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INDEX_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INFILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INFILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INFILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INFILE_SYMBOL > { global . tracer . print_trace_start (& state , "INFILE_SYMBOL") ; let result = (|| { let result = INFILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INFILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INITIAL_SIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INITIAL_SIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INITIAL_SIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INITIAL_SIZE_SYMBOL > { global . tracer . print_trace_start (& state , "INITIAL_SIZE_SYMBOL") ; let result = (|| { let result = INITIAL_SIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INITIAL_SIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INNER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INNER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INNER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INNER_SYMBOL > { global . tracer . print_trace_start (& state , "INNER_SYMBOL") ; let result = (|| { let result = INNER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INNER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INOUT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INOUT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INOUT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INOUT_SYMBOL > { global . tracer . print_trace_start (& state , "INOUT_SYMBOL") ; let result = (|| { let result = INOUT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INOUT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INSENSITIVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INSENSITIVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INSENSITIVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INSENSITIVE_SYMBOL > { global . tracer . print_trace_start (& state , "INSENSITIVE_SYMBOL") ; let result = (|| { let result = INSENSITIVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INSENSITIVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INSERT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INSERT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INSERT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INSERT_SYMBOL > { global . tracer . print_trace_start (& state , "INSERT_SYMBOL") ; let result = (|| { let result = INSERT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INSERT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INSERT_METHOD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INSERT_METHOD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INSERT_METHOD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INSERT_METHOD_SYMBOL > { global . tracer . print_trace_start (& state , "INSERT_METHOD_SYMBOL") ; let result = (|| { let result = INSERT_METHOD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INSERT_METHOD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INSTANCE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INSTANCE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INSTANCE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INSTANCE_SYMBOL > { global . tracer . print_trace_start (& state , "INSTANCE_SYMBOL") ; let result = (|| { let result = INSTANCE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INSTANCE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INSTALL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INSTALL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INSTALL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INSTALL_SYMBOL > { global . tracer . print_trace_start (& state , "INSTALL_SYMBOL") ; let result = (|| { let result = INSTALL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INSTALL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INTEGER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INTEGER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INTEGER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INTEGER_SYMBOL > { global . tracer . print_trace_start (& state , "INTEGER_SYMBOL") ; let result = (|| { let result = INTEGER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INTEGER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INTERVAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INTERVAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INTERVAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INTERVAL_SYMBOL > { global . tracer . print_trace_start (& state , "INTERVAL_SYMBOL") ; let result = (|| { let result = INTERVAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INTERVAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INTO_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INTO") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INTO_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INTO_SYMBOL > { global . tracer . print_trace_start (& state , "INTO_SYMBOL") ; let result = (|| { let result = INTO_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INTO_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INT_SYMBOL > { global . tracer . print_trace_start (& state , "INT_SYMBOL") ; let result = (|| { let result = INT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INVOKER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INVOKER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INVOKER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INVOKER_SYMBOL > { global . tracer . print_trace_start (& state , "INVOKER_SYMBOL") ; let result = (|| { let result = INVOKER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INVOKER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IN_SYMBOL > { global . tracer . print_trace_start (& state , "IN_SYMBOL") ; let result = (|| { let result = IN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IO_AFTER_GTIDS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IO_AFTER_GTIDS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IO_AFTER_GTIDS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IO_AFTER_GTIDS_SYMBOL > { global . tracer . print_trace_start (& state , "IO_AFTER_GTIDS_SYMBOL") ; let result = (|| { let result = IO_AFTER_GTIDS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IO_AFTER_GTIDS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IO_BEFORE_GTIDS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IO_BEFORE_GTIDS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IO_BEFORE_GTIDS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IO_BEFORE_GTIDS_SYMBOL > { global . tracer . print_trace_start (& state , "IO_BEFORE_GTIDS_SYMBOL") ; let result = (|| { let result = IO_BEFORE_GTIDS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IO_BEFORE_GTIDS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IO_THREAD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IO_THREAD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IO_THREAD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IO_THREAD_SYMBOL > { global . tracer . print_trace_start (& state , "IO_THREAD_SYMBOL") ; let result = (|| { let result = IO_THREAD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IO_THREAD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IO_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IO") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IO_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IO_SYMBOL > { global . tracer . print_trace_start (& state , "IO_SYMBOL") ; let result = (|| { let result = IO_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IO_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IPC_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IPC") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IPC_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IPC_SYMBOL > { global . tracer . print_trace_start (& state , "IPC_SYMBOL") ; let result = (|| { let result = IPC_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IPC_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "IS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_IS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IS_SYMBOL > { global . tracer . print_trace_start (& state , "IS_SYMBOL") ; let result = (|| { let result = IS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: IS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ISOLATION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ISOLATION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ISOLATION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ISOLATION_SYMBOL > { global . tracer . print_trace_start (& state , "ISOLATION_SYMBOL") ; let result = (|| { let result = ISOLATION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ISOLATION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ISSUER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ISSUER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ISSUER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ISSUER_SYMBOL > { global . tracer . print_trace_start (& state , "ISSUER_SYMBOL") ; let result = (|| { let result = ISSUER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ISSUER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ITERATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ITERATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ITERATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ITERATE_SYMBOL > { global . tracer . print_trace_start (& state , "ITERATE_SYMBOL") ; let result = (|| { let result = ITERATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ITERATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod JOIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "JOIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_JOIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , JOIN_SYMBOL > { global . tracer . print_trace_start (& state , "JOIN_SYMBOL") ; let result = (|| { let result = JOIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: JOIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod JSON_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "JSON") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_JSON_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , JSON_SYMBOL > { global . tracer . print_trace_start (& state , "JSON_SYMBOL") ; let result = (|| { let result = JSON_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: JSON_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KEYS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "KEYS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KEYS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KEYS_SYMBOL > { global . tracer . print_trace_start (& state , "KEYS_SYMBOL") ; let result = (|| { let result = KEYS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: KEYS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KEY_BLOCK_SIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "KEY_BLOCK_SIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KEY_BLOCK_SIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KEY_BLOCK_SIZE_SYMBOL > { global . tracer . print_trace_start (& state , "KEY_BLOCK_SIZE_SYMBOL") ; let result = (|| { let result = KEY_BLOCK_SIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: KEY_BLOCK_SIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KEY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "KEY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KEY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KEY_SYMBOL > { global . tracer . print_trace_start (& state , "KEY_SYMBOL") ; let result = (|| { let result = KEY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: KEY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KILL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "KILL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KILL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KILL_SYMBOL > { global . tracer . print_trace_start (& state , "KILL_SYMBOL") ; let result = (|| { let result = KILL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: KILL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LANGUAGE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LANGUAGE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LANGUAGE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LANGUAGE_SYMBOL > { global . tracer . print_trace_start (& state , "LANGUAGE_SYMBOL") ; let result = (|| { let result = LANGUAGE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LANGUAGE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LAST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LAST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LAST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LAST_SYMBOL > { global . tracer . print_trace_start (& state , "LAST_SYMBOL") ; let result = (|| { let result = LAST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LAST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LEADING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LEADING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LEADING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LEADING_SYMBOL > { global . tracer . print_trace_start (& state , "LEADING_SYMBOL") ; let result = (|| { let result = LEADING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LEADING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LEAVES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LEAVES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LEAVES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LEAVES_SYMBOL > { global . tracer . print_trace_start (& state , "LEAVES_SYMBOL") ; let result = (|| { let result = LEAVES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LEAVES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LEAVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LEAVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LEAVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LEAVE_SYMBOL > { global . tracer . print_trace_start (& state , "LEAVE_SYMBOL") ; let result = (|| { let result = LEAVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LEAVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LEFT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LEFT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LEFT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LEFT_SYMBOL > { global . tracer . print_trace_start (& state , "LEFT_SYMBOL") ; let result = (|| { let result = LEFT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LEFT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LESS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LESS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LESS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LESS_SYMBOL > { global . tracer . print_trace_start (& state , "LESS_SYMBOL") ; let result = (|| { let result = LESS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LESS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LEVEL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LEVEL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LEVEL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LEVEL_SYMBOL > { global . tracer . print_trace_start (& state , "LEVEL_SYMBOL") ; let result = (|| { let result = LEVEL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LEVEL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LIKE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LIKE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LIKE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LIKE_SYMBOL > { global . tracer . print_trace_start (& state , "LIKE_SYMBOL") ; let result = (|| { let result = LIKE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LIKE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LIMIT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LIMIT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LIMIT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LIMIT_SYMBOL > { global . tracer . print_trace_start (& state , "LIMIT_SYMBOL") ; let result = (|| { let result = LIMIT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LIMIT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LINEAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LINEAR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LINEAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LINEAR_SYMBOL > { global . tracer . print_trace_start (& state , "LINEAR_SYMBOL") ; let result = (|| { let result = LINEAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LINEAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LINES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LINES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LINES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LINES_SYMBOL > { global . tracer . print_trace_start (& state , "LINES_SYMBOL") ; let result = (|| { let result = LINES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LINES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LINESTRING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LINESTRING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LINESTRING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LINESTRING_SYMBOL > { global . tracer . print_trace_start (& state , "LINESTRING_SYMBOL") ; let result = (|| { let result = LINESTRING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LINESTRING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LIST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LIST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LIST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LIST_SYMBOL > { global . tracer . print_trace_start (& state , "LIST_SYMBOL") ; let result = (|| { let result = LIST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LIST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOAD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOAD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOAD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOAD_SYMBOL > { global . tracer . print_trace_start (& state , "LOAD_SYMBOL") ; let result = (|| { let result = LOAD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOAD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOCALTIME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOCALTIME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOCALTIME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOCALTIME_SYMBOL > { global . tracer . print_trace_start (& state , "LOCALTIME_SYMBOL") ; let result = (|| { let result = LOCALTIME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOCALTIME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOCALTIMESTAMP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOCALTIMESTAMP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOCALTIMESTAMP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOCALTIMESTAMP_SYMBOL > { global . tracer . print_trace_start (& state , "LOCALTIMESTAMP_SYMBOL") ; let result = (|| { let result = LOCALTIMESTAMP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOCALTIMESTAMP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOCAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOCAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOCAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOCAL_SYMBOL > { global . tracer . print_trace_start (& state , "LOCAL_SYMBOL") ; let result = (|| { let result = LOCAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOCAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOCATOR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOCATOR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOCATOR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOCATOR_SYMBOL > { global . tracer . print_trace_start (& state , "LOCATOR_SYMBOL") ; let result = (|| { let result = LOCATOR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOCATOR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOCKS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOCKS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOCKS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOCKS_SYMBOL > { global . tracer . print_trace_start (& state , "LOCKS_SYMBOL") ; let result = (|| { let result = LOCKS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOCKS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOCK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOCK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOCK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOCK_SYMBOL > { global . tracer . print_trace_start (& state , "LOCK_SYMBOL") ; let result = (|| { let result = LOCK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOCK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOGFILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOGFILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOGFILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOGFILE_SYMBOL > { global . tracer . print_trace_start (& state , "LOGFILE_SYMBOL") ; let result = (|| { let result = LOGFILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOGFILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOGS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOGS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOGS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOGS_SYMBOL > { global . tracer . print_trace_start (& state , "LOGS_SYMBOL") ; let result = (|| { let result = LOGS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOGS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LONGBLOB_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LONGBLOB") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LONGBLOB_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LONGBLOB_SYMBOL > { global . tracer . print_trace_start (& state , "LONGBLOB_SYMBOL") ; let result = (|| { let result = LONGBLOB_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LONGBLOB_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LONGTEXT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LONGTEXT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LONGTEXT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LONGTEXT_SYMBOL > { global . tracer . print_trace_start (& state , "LONGTEXT_SYMBOL") ; let result = (|| { let result = LONGTEXT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LONGTEXT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LONG_NUM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LONG_NUM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LONG_NUM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LONG_NUM_SYMBOL > { global . tracer . print_trace_start (& state , "LONG_NUM_SYMBOL") ; let result = (|| { let result = LONG_NUM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LONG_NUM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LONG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LONG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LONG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LONG_SYMBOL > { global . tracer . print_trace_start (& state , "LONG_SYMBOL") ; let result = (|| { let result = LONG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LONG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOOP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOOP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOOP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOOP_SYMBOL > { global . tracer . print_trace_start (& state , "LOOP_SYMBOL") ; let result = (|| { let result = LOOP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOOP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOW_PRIORITY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOW_PRIORITY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOW_PRIORITY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOW_PRIORITY_SYMBOL > { global . tracer . print_trace_start (& state , "LOW_PRIORITY_SYMBOL") ; let result = (|| { let result = LOW_PRIORITY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOW_PRIORITY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_AUTO_POSITION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_AUTO_POSITION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_AUTO_POSITION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_AUTO_POSITION_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_AUTO_POSITION_SYMBOL") ; let result = (|| { let result = MASTER_AUTO_POSITION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_AUTO_POSITION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_BIND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_BIND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_BIND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_BIND_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_BIND_SYMBOL") ; let result = (|| { let result = MASTER_BIND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_BIND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_CONNECT_RETRY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_CONNECT_RETRY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_CONNECT_RETRY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_CONNECT_RETRY_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_CONNECT_RETRY_SYMBOL") ; let result = (|| { let result = MASTER_CONNECT_RETRY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_CONNECT_RETRY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_DELAY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_DELAY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_DELAY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_DELAY_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_DELAY_SYMBOL") ; let result = (|| { let result = MASTER_DELAY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_DELAY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_HOST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_HOST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_HOST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_HOST_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_HOST_SYMBOL") ; let result = (|| { let result = MASTER_HOST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_HOST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_LOG_FILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_LOG_FILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_LOG_FILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_LOG_FILE_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_LOG_FILE_SYMBOL") ; let result = (|| { let result = MASTER_LOG_FILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_LOG_FILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_LOG_POS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_LOG_POS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_LOG_POS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_LOG_POS_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_LOG_POS_SYMBOL") ; let result = (|| { let result = MASTER_LOG_POS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_LOG_POS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_PASSWORD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_PASSWORD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_PASSWORD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_PASSWORD_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_PASSWORD_SYMBOL") ; let result = (|| { let result = MASTER_PASSWORD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_PASSWORD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_PORT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_PORT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_PORT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_PORT_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_PORT_SYMBOL") ; let result = (|| { let result = MASTER_PORT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_PORT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_RETRY_COUNT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_RETRY_COUNT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_RETRY_COUNT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_RETRY_COUNT_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_RETRY_COUNT_SYMBOL") ; let result = (|| { let result = MASTER_RETRY_COUNT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_RETRY_COUNT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SERVER_ID_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SERVER_ID") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SERVER_ID_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SERVER_ID_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SERVER_ID_SYMBOL") ; let result = (|| { let result = MASTER_SERVER_ID_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SERVER_ID_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SSL_CAPATH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SSL_CAPATH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SSL_CAPATH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SSL_CAPATH_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SSL_CAPATH_SYMBOL") ; let result = (|| { let result = MASTER_SSL_CAPATH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SSL_CAPATH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SSL_CA_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SSL_CA") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SSL_CA_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SSL_CA_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SSL_CA_SYMBOL") ; let result = (|| { let result = MASTER_SSL_CA_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SSL_CA_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SSL_CERT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SSL_CERT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SSL_CERT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SSL_CERT_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SSL_CERT_SYMBOL") ; let result = (|| { let result = MASTER_SSL_CERT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SSL_CERT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SSL_CIPHER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SSL_CIPHER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SSL_CIPHER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SSL_CIPHER_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SSL_CIPHER_SYMBOL") ; let result = (|| { let result = MASTER_SSL_CIPHER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SSL_CIPHER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SSL_CRL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SSL_CRL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SSL_CRL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SSL_CRL_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SSL_CRL_SYMBOL") ; let result = (|| { let result = MASTER_SSL_CRL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SSL_CRL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SSL_CRLPATH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SSL_CRLPATH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SSL_CRLPATH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SSL_CRLPATH_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SSL_CRLPATH_SYMBOL") ; let result = (|| { let result = MASTER_SSL_CRLPATH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SSL_CRLPATH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SSL_KEY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SSL_KEY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SSL_KEY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SSL_KEY_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SSL_KEY_SYMBOL") ; let result = (|| { let result = MASTER_SSL_KEY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SSL_KEY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SSL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SSL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SSL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SSL_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SSL_SYMBOL") ; let result = (|| { let result = MASTER_SSL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SSL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_SSL_VERIFY_SERVER_CERT") }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL") ; let result = (|| { let result = MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_SYMBOL") ; let result = (|| { let result = MASTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_TLS_VERSION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_TLS_VERSION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_TLS_VERSION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_TLS_VERSION_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_TLS_VERSION_SYMBOL") ; let result = (|| { let result = MASTER_TLS_VERSION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_TLS_VERSION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_USER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_USER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_USER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_USER_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_USER_SYMBOL") ; let result = (|| { let result = MASTER_USER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_USER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_HEARTBEAT_PERIOD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_HEARTBEAT_PERIOD") }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_HEARTBEAT_PERIOD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_HEARTBEAT_PERIOD_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_HEARTBEAT_PERIOD_SYMBOL") ; let result = (|| { let result = MASTER_HEARTBEAT_PERIOD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_HEARTBEAT_PERIOD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MATCH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MATCH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MATCH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MATCH_SYMBOL > { global . tracer . print_trace_start (& state , "MATCH_SYMBOL") ; let result = (|| { let result = MATCH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MATCH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MAX_CONNECTIONS_PER_HOUR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MAX_CONNECTIONS_PER_HOUR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MAX_CONNECTIONS_PER_HOUR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MAX_CONNECTIONS_PER_HOUR_SYMBOL > { global . tracer . print_trace_start (& state , "MAX_CONNECTIONS_PER_HOUR_SYMBOL") ; let result = (|| { let result = MAX_CONNECTIONS_PER_HOUR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MAX_CONNECTIONS_PER_HOUR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MAX_QUERIES_PER_HOUR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MAX_QUERIES_PER_HOUR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MAX_QUERIES_PER_HOUR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MAX_QUERIES_PER_HOUR_SYMBOL > { global . tracer . print_trace_start (& state , "MAX_QUERIES_PER_HOUR_SYMBOL") ; let result = (|| { let result = MAX_QUERIES_PER_HOUR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MAX_QUERIES_PER_HOUR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MAX_ROWS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MAX_ROWS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MAX_ROWS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MAX_ROWS_SYMBOL > { global . tracer . print_trace_start (& state , "MAX_ROWS_SYMBOL") ; let result = (|| { let result = MAX_ROWS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MAX_ROWS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MAX_SIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MAX_SIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MAX_SIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MAX_SIZE_SYMBOL > { global . tracer . print_trace_start (& state , "MAX_SIZE_SYMBOL") ; let result = (|| { let result = MAX_SIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MAX_SIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MAX_STATEMENT_TIME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MAX_STATEMENT_TIME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MAX_STATEMENT_TIME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MAX_STATEMENT_TIME_SYMBOL > { global . tracer . print_trace_start (& state , "MAX_STATEMENT_TIME_SYMBOL") ; let result = (|| { let result = MAX_STATEMENT_TIME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MAX_STATEMENT_TIME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MAX_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MAX") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MAX_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MAX_SYMBOL > { global . tracer . print_trace_start (& state , "MAX_SYMBOL") ; let result = (|| { let result = MAX_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MAX_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MAX_UPDATES_PER_HOUR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MAX_UPDATES_PER_HOUR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MAX_UPDATES_PER_HOUR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MAX_UPDATES_PER_HOUR_SYMBOL > { global . tracer . print_trace_start (& state , "MAX_UPDATES_PER_HOUR_SYMBOL") ; let result = (|| { let result = MAX_UPDATES_PER_HOUR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MAX_UPDATES_PER_HOUR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MAX_USER_CONNECTIONS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MAX_USER_CONNECTIONS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MAX_USER_CONNECTIONS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MAX_USER_CONNECTIONS_SYMBOL > { global . tracer . print_trace_start (& state , "MAX_USER_CONNECTIONS_SYMBOL") ; let result = (|| { let result = MAX_USER_CONNECTIONS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MAX_USER_CONNECTIONS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MAXVALUE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MAXVALUE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MAXVALUE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MAXVALUE_SYMBOL > { global . tracer . print_trace_start (& state , "MAXVALUE_SYMBOL") ; let result = (|| { let result = MAXVALUE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MAXVALUE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MEDIUMBLOB_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MEDIUMBLOB") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MEDIUMBLOB_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MEDIUMBLOB_SYMBOL > { global . tracer . print_trace_start (& state , "MEDIUMBLOB_SYMBOL") ; let result = (|| { let result = MEDIUMBLOB_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MEDIUMBLOB_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MEDIUMINT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MEDIUMINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MEDIUMINT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MEDIUMINT_SYMBOL > { global . tracer . print_trace_start (& state , "MEDIUMINT_SYMBOL") ; let result = (|| { let result = MEDIUMINT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MEDIUMINT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MEDIUMTEXT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MEDIUMTEXT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MEDIUMTEXT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MEDIUMTEXT_SYMBOL > { global . tracer . print_trace_start (& state , "MEDIUMTEXT_SYMBOL") ; let result = (|| { let result = MEDIUMTEXT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MEDIUMTEXT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MEDIUM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MEDIUM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MEDIUM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MEDIUM_SYMBOL > { global . tracer . print_trace_start (& state , "MEDIUM_SYMBOL") ; let result = (|| { let result = MEDIUM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MEDIUM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MEMORY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MEMORY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MEMORY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MEMORY_SYMBOL > { global . tracer . print_trace_start (& state , "MEMORY_SYMBOL") ; let result = (|| { let result = MEMORY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MEMORY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MERGE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MERGE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MERGE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MERGE_SYMBOL > { global . tracer . print_trace_start (& state , "MERGE_SYMBOL") ; let result = (|| { let result = MERGE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MERGE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MESSAGE_TEXT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MESSAGE_TEXT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MESSAGE_TEXT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MESSAGE_TEXT_SYMBOL > { global . tracer . print_trace_start (& state , "MESSAGE_TEXT_SYMBOL") ; let result = (|| { let result = MESSAGE_TEXT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MESSAGE_TEXT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MICROSECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MICROSECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MICROSECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MICROSECOND_SYMBOL > { global . tracer . print_trace_start (& state , "MICROSECOND_SYMBOL") ; let result = (|| { let result = MICROSECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MICROSECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MID_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MID") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MID_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MID_SYMBOL > { global . tracer . print_trace_start (& state , "MID_SYMBOL") ; let result = (|| { let result = MID_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MID_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MIDDLEINT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MIDDLEINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MIDDLEINT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MIDDLEINT_SYMBOL > { global . tracer . print_trace_start (& state , "MIDDLEINT_SYMBOL") ; let result = (|| { let result = MIDDLEINT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MIDDLEINT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MIGRATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MIGRATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MIGRATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MIGRATE_SYMBOL > { global . tracer . print_trace_start (& state , "MIGRATE_SYMBOL") ; let result = (|| { let result = MIGRATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MIGRATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MINUTE_MICROSECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MINUTE_MICROSECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MINUTE_MICROSECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MINUTE_MICROSECOND_SYMBOL > { global . tracer . print_trace_start (& state , "MINUTE_MICROSECOND_SYMBOL") ; let result = (|| { let result = MINUTE_MICROSECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MINUTE_MICROSECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MINUTE_SECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MINUTE_SECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MINUTE_SECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MINUTE_SECOND_SYMBOL > { global . tracer . print_trace_start (& state , "MINUTE_SECOND_SYMBOL") ; let result = (|| { let result = MINUTE_SECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MINUTE_SECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MINUTE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MINUTE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MINUTE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MINUTE_SYMBOL > { global . tracer . print_trace_start (& state , "MINUTE_SYMBOL") ; let result = (|| { let result = MINUTE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MINUTE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MIN_ROWS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MIN_ROWS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MIN_ROWS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MIN_ROWS_SYMBOL > { global . tracer . print_trace_start (& state , "MIN_ROWS_SYMBOL") ; let result = (|| { let result = MIN_ROWS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MIN_ROWS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MIN_SYMBOL > { global . tracer . print_trace_start (& state , "MIN_SYMBOL") ; let result = (|| { let result = MIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MODE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MODE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MODE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MODE_SYMBOL > { global . tracer . print_trace_start (& state , "MODE_SYMBOL") ; let result = (|| { let result = MODE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MODE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MODIFIES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MODIFIES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MODIFIES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MODIFIES_SYMBOL > { global . tracer . print_trace_start (& state , "MODIFIES_SYMBOL") ; let result = (|| { let result = MODIFIES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MODIFIES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MODIFY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MODIFY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MODIFY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MODIFY_SYMBOL > { global . tracer . print_trace_start (& state , "MODIFY_SYMBOL") ; let result = (|| { let result = MODIFY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MODIFY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MOD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MOD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MOD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MOD_SYMBOL > { global . tracer . print_trace_start (& state , "MOD_SYMBOL") ; let result = (|| { let result = MOD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MOD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MONTH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MONTH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MONTH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MONTH_SYMBOL > { global . tracer . print_trace_start (& state , "MONTH_SYMBOL") ; let result = (|| { let result = MONTH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MONTH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MULTILINESTRING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MULTILINESTRING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MULTILINESTRING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MULTILINESTRING_SYMBOL > { global . tracer . print_trace_start (& state , "MULTILINESTRING_SYMBOL") ; let result = (|| { let result = MULTILINESTRING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MULTILINESTRING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MULTIPOINT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MULTIPOINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MULTIPOINT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MULTIPOINT_SYMBOL > { global . tracer . print_trace_start (& state , "MULTIPOINT_SYMBOL") ; let result = (|| { let result = MULTIPOINT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MULTIPOINT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MULTIPOLYGON_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MULTIPOLYGON") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MULTIPOLYGON_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MULTIPOLYGON_SYMBOL > { global . tracer . print_trace_start (& state , "MULTIPOLYGON_SYMBOL") ; let result = (|| { let result = MULTIPOLYGON_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MULTIPOLYGON_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MUTEX_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MUTEX") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MUTEX_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MUTEX_SYMBOL > { global . tracer . print_trace_start (& state , "MUTEX_SYMBOL") ; let result = (|| { let result = MUTEX_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MUTEX_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MYSQL_ERRNO_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MYSQL_ERRNO") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MYSQL_ERRNO_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MYSQL_ERRNO_SYMBOL > { global . tracer . print_trace_start (& state , "MYSQL_ERRNO_SYMBOL") ; let result = (|| { let result = MYSQL_ERRNO_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MYSQL_ERRNO_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NAMES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NAMES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NAMES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NAMES_SYMBOL > { global . tracer . print_trace_start (& state , "NAMES_SYMBOL") ; let result = (|| { let result = NAMES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NAMES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NAME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NAME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NAME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NAME_SYMBOL > { global . tracer . print_trace_start (& state , "NAME_SYMBOL") ; let result = (|| { let result = NAME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NAME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NATIONAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NATIONAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NATIONAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NATIONAL_SYMBOL > { global . tracer . print_trace_start (& state , "NATIONAL_SYMBOL") ; let result = (|| { let result = NATIONAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NATIONAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NATURAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NATURAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NATURAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NATURAL_SYMBOL > { global . tracer . print_trace_start (& state , "NATURAL_SYMBOL") ; let result = (|| { let result = NATURAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NATURAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NCHAR_STRING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NCHAR_STRING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NCHAR_STRING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NCHAR_STRING_SYMBOL > { global . tracer . print_trace_start (& state , "NCHAR_STRING_SYMBOL") ; let result = (|| { let result = NCHAR_STRING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NCHAR_STRING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NCHAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NCHAR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NCHAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NCHAR_SYMBOL > { global . tracer . print_trace_start (& state , "NCHAR_SYMBOL") ; let result = (|| { let result = NCHAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NCHAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NDB_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NDB") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NDB_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NDB_SYMBOL > { global . tracer . print_trace_start (& state , "NDB_SYMBOL") ; let result = (|| { let result = NDB_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NDB_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NDBCLUSTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NDBCLUSTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NDBCLUSTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NDBCLUSTER_SYMBOL > { global . tracer . print_trace_start (& state , "NDBCLUSTER_SYMBOL") ; let result = (|| { let result = NDBCLUSTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NDBCLUSTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NEG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NEG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NEG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NEG_SYMBOL > { global . tracer . print_trace_start (& state , "NEG_SYMBOL") ; let result = (|| { let result = NEG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NEG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NEVER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NEVER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NEVER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NEVER_SYMBOL > { global . tracer . print_trace_start (& state , "NEVER_SYMBOL") ; let result = (|| { let result = NEVER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NEVER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NEW_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NEW") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NEW_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NEW_SYMBOL > { global . tracer . print_trace_start (& state , "NEW_SYMBOL") ; let result = (|| { let result = NEW_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NEW_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NEXT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NEXT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NEXT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NEXT_SYMBOL > { global . tracer . print_trace_start (& state , "NEXT_SYMBOL") ; let result = (|| { let result = NEXT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NEXT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NODEGROUP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NODEGROUP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NODEGROUP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NODEGROUP_SYMBOL > { global . tracer . print_trace_start (& state , "NODEGROUP_SYMBOL") ; let result = (|| { let result = NODEGROUP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NODEGROUP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NONE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NONE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NONE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NONE_SYMBOL > { global . tracer . print_trace_start (& state , "NONE_SYMBOL") ; let result = (|| { let result = NONE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NONE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NONBLOCKING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NONBLOCKING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NONBLOCKING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NONBLOCKING_SYMBOL > { global . tracer . print_trace_start (& state , "NONBLOCKING_SYMBOL") ; let result = (|| { let result = NONBLOCKING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NONBLOCKING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NOT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NOT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NOT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NOT_SYMBOL > { global . tracer . print_trace_start (& state , "NOT_SYMBOL") ; let result = (|| { let result = NOT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NOT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NOT2_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NOT_SYMBOL (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NOT2_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NOT2_SYMBOL > { global . tracer . print_trace_start (& state , "NOT2_SYMBOL") ; let result = (|| { let result = NOT2_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NOT2_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CONCAT_PIPES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_LOGICAL_OR_OPERATOR (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CONCAT_PIPES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CONCAT_PIPES_SYMBOL > { global . tracer . print_trace_start (& state , "CONCAT_PIPES_SYMBOL") ; let result = (|| { let result = CONCAT_PIPES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CONCAT_PIPES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NOW_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NOW") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NOW_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NOW_SYMBOL > { global . tracer . print_trace_start (& state , "NOW_SYMBOL") ; let result = (|| { let result = NOW_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NOW_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NO_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NO") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NO_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NO_SYMBOL > { global . tracer . print_trace_start (& state , "NO_SYMBOL") ; let result = (|| { let result = NO_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NO_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NO_WAIT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NO_WAIT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NO_WAIT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NO_WAIT_SYMBOL > { global . tracer . print_trace_start (& state , "NO_WAIT_SYMBOL") ; let result = (|| { let result = NO_WAIT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NO_WAIT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NO_WRITE_TO_BINLOG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NO_WRITE_TO_BINLOG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NO_WRITE_TO_BINLOG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NO_WRITE_TO_BINLOG_SYMBOL > { global . tracer . print_trace_start (& state , "NO_WRITE_TO_BINLOG_SYMBOL") ; let result = (|| { let result = NO_WRITE_TO_BINLOG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NO_WRITE_TO_BINLOG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NULL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NULL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NULL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NULL_SYMBOL > { global . tracer . print_trace_start (& state , "NULL_SYMBOL") ; let result = (|| { let result = NULL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NULL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NUMBER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NUMBER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NUMBER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NUMBER_SYMBOL > { global . tracer . print_trace_start (& state , "NUMBER_SYMBOL") ; let result = (|| { let result = NUMBER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NUMBER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NUMERIC_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NUMERIC") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NUMERIC_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NUMERIC_SYMBOL > { global . tracer . print_trace_start (& state , "NUMERIC_SYMBOL") ; let result = (|| { let result = NUMERIC_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NUMERIC_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NVARCHAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NVARCHAR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NVARCHAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NVARCHAR_SYMBOL > { global . tracer . print_trace_start (& state , "NVARCHAR_SYMBOL") ; let result = (|| { let result = NVARCHAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NVARCHAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OFFLINE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OFFLINE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OFFLINE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OFFLINE_SYMBOL > { global . tracer . print_trace_start (& state , "OFFLINE_SYMBOL") ; let result = (|| { let result = OFFLINE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OFFLINE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OFFSET_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OFFSET") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OFFSET_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OFFSET_SYMBOL > { global . tracer . print_trace_start (& state , "OFFSET_SYMBOL") ; let result = (|| { let result = OFFSET_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OFFSET_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OLD_PASSWORD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OLD_PASSWORD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OLD_PASSWORD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OLD_PASSWORD_SYMBOL > { global . tracer . print_trace_start (& state , "OLD_PASSWORD_SYMBOL") ; let result = (|| { let result = OLD_PASSWORD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OLD_PASSWORD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ON_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ON") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ON_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ON_SYMBOL > { global . tracer . print_trace_start (& state , "ON_SYMBOL") ; let result = (|| { let result = ON_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ON_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ONE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ONE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ONE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ONE_SYMBOL > { global . tracer . print_trace_start (& state , "ONE_SYMBOL") ; let result = (|| { let result = ONE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ONE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ONLINE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ONLINE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ONLINE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ONLINE_SYMBOL > { global . tracer . print_trace_start (& state , "ONLINE_SYMBOL") ; let result = (|| { let result = ONLINE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ONLINE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ONLY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ONLY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ONLY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ONLY_SYMBOL > { global . tracer . print_trace_start (& state , "ONLY_SYMBOL") ; let result = (|| { let result = ONLY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ONLY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OPEN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OPEN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OPEN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OPEN_SYMBOL > { global . tracer . print_trace_start (& state , "OPEN_SYMBOL") ; let result = (|| { let result = OPEN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OPEN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OPTIMIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OPTIMIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OPTIMIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OPTIMIZE_SYMBOL > { global . tracer . print_trace_start (& state , "OPTIMIZE_SYMBOL") ; let result = (|| { let result = OPTIMIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OPTIMIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OPTIMIZER_COSTS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OPTIMIZER_COSTS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OPTIMIZER_COSTS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OPTIMIZER_COSTS_SYMBOL > { global . tracer . print_trace_start (& state , "OPTIMIZER_COSTS_SYMBOL") ; let result = (|| { let result = OPTIMIZER_COSTS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OPTIMIZER_COSTS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OPTIONS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OPTIONS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OPTIONS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OPTIONS_SYMBOL > { global . tracer . print_trace_start (& state , "OPTIONS_SYMBOL") ; let result = (|| { let result = OPTIONS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OPTIONS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OPTION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OPTION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OPTION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OPTION_SYMBOL > { global . tracer . print_trace_start (& state , "OPTION_SYMBOL") ; let result = (|| { let result = OPTION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OPTION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OPTIONALLY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OPTIONALLY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OPTIONALLY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OPTIONALLY_SYMBOL > { global . tracer . print_trace_start (& state , "OPTIONALLY_SYMBOL") ; let result = (|| { let result = OPTIONALLY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OPTIONALLY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ORDER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ORDER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ORDER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ORDER_SYMBOL > { global . tracer . print_trace_start (& state , "ORDER_SYMBOL") ; let result = (|| { let result = ORDER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ORDER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OR_SYMBOL > { global . tracer . print_trace_start (& state , "OR_SYMBOL") ; let result = (|| { let result = OR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OUTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OUTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OUTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OUTER_SYMBOL > { global . tracer . print_trace_start (& state , "OUTER_SYMBOL") ; let result = (|| { let result = OUTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OUTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OUTFILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OUTFILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OUTFILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OUTFILE_SYMBOL > { global . tracer . print_trace_start (& state , "OUTFILE_SYMBOL") ; let result = (|| { let result = OUTFILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OUTFILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OUT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OUT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OUT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OUT_SYMBOL > { global . tracer . print_trace_start (& state , "OUT_SYMBOL") ; let result = (|| { let result = OUT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OUT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OWNER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OWNER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OWNER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OWNER_SYMBOL > { global . tracer . print_trace_start (& state , "OWNER_SYMBOL") ; let result = (|| { let result = OWNER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OWNER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PACK_KEYS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PACK_KEYS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PACK_KEYS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PACK_KEYS_SYMBOL > { global . tracer . print_trace_start (& state , "PACK_KEYS_SYMBOL") ; let result = (|| { let result = PACK_KEYS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PACK_KEYS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PAGE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PAGE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PAGE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PAGE_SYMBOL > { global . tracer . print_trace_start (& state , "PAGE_SYMBOL") ; let result = (|| { let result = PAGE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PAGE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PARSER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PARSER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PARSER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PARSER_SYMBOL > { global . tracer . print_trace_start (& state , "PARSER_SYMBOL") ; let result = (|| { let result = PARSER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PARSER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PARTIAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PARTIAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PARTIAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PARTIAL_SYMBOL > { global . tracer . print_trace_start (& state , "PARTIAL_SYMBOL") ; let result = (|| { let result = PARTIAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PARTIAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PARTITIONING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PARTITIONING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PARTITIONING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PARTITIONING_SYMBOL > { global . tracer . print_trace_start (& state , "PARTITIONING_SYMBOL") ; let result = (|| { let result = PARTITIONING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PARTITIONING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PARTITIONS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PARTITIONS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PARTITIONS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PARTITIONS_SYMBOL > { global . tracer . print_trace_start (& state , "PARTITIONS_SYMBOL") ; let result = (|| { let result = PARTITIONS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PARTITIONS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PARTITION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PARTITION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PARTITION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PARTITION_SYMBOL > { global . tracer . print_trace_start (& state , "PARTITION_SYMBOL") ; let result = (|| { let result = PARTITION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PARTITION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PASSWORD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PASSWORD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PASSWORD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PASSWORD_SYMBOL > { global . tracer . print_trace_start (& state , "PASSWORD_SYMBOL") ; let result = (|| { let result = PASSWORD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PASSWORD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PHASE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PHASE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PHASE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PHASE_SYMBOL > { global . tracer . print_trace_start (& state , "PHASE_SYMBOL") ; let result = (|| { let result = PHASE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PHASE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PLUGINS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PLUGINS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PLUGINS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PLUGINS_SYMBOL > { global . tracer . print_trace_start (& state , "PLUGINS_SYMBOL") ; let result = (|| { let result = PLUGINS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PLUGINS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PLUGIN_DIR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PLUGIN_DIR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PLUGIN_DIR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PLUGIN_DIR_SYMBOL > { global . tracer . print_trace_start (& state , "PLUGIN_DIR_SYMBOL") ; let result = (|| { let result = PLUGIN_DIR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PLUGIN_DIR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PLUGIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PLUGIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PLUGIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PLUGIN_SYMBOL > { global . tracer . print_trace_start (& state , "PLUGIN_SYMBOL") ; let result = (|| { let result = PLUGIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PLUGIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod POINT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "POINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_POINT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , POINT_SYMBOL > { global . tracer . print_trace_start (& state , "POINT_SYMBOL") ; let result = (|| { let result = POINT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: POINT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod POLYGON_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "POLYGON") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_POLYGON_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , POLYGON_SYMBOL > { global . tracer . print_trace_start (& state , "POLYGON_SYMBOL") ; let result = (|| { let result = POLYGON_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: POLYGON_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PORT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PORT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PORT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PORT_SYMBOL > { global . tracer . print_trace_start (& state , "PORT_SYMBOL") ; let result = (|| { let result = PORT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PORT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod POSITION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "POSITION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_POSITION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , POSITION_SYMBOL > { global . tracer . print_trace_start (& state , "POSITION_SYMBOL") ; let result = (|| { let result = POSITION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: POSITION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PRECEDES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PRECEDES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PRECEDES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PRECEDES_SYMBOL > { global . tracer . print_trace_start (& state , "PRECEDES_SYMBOL") ; let result = (|| { let result = PRECEDES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PRECEDES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PRECISION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PRECISION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PRECISION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PRECISION_SYMBOL > { global . tracer . print_trace_start (& state , "PRECISION_SYMBOL") ; let result = (|| { let result = PRECISION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PRECISION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PREPARE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PREPARE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PREPARE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PREPARE_SYMBOL > { global . tracer . print_trace_start (& state , "PREPARE_SYMBOL") ; let result = (|| { let result = PREPARE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PREPARE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PRESERVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PRESERVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PRESERVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PRESERVE_SYMBOL > { global . tracer . print_trace_start (& state , "PRESERVE_SYMBOL") ; let result = (|| { let result = PRESERVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PRESERVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PREV_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PREV") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PREV_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PREV_SYMBOL > { global . tracer . print_trace_start (& state , "PREV_SYMBOL") ; let result = (|| { let result = PREV_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PREV_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PRIMARY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PRIMARY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PRIMARY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PRIMARY_SYMBOL > { global . tracer . print_trace_start (& state , "PRIMARY_SYMBOL") ; let result = (|| { let result = PRIMARY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PRIMARY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PRIVILEGES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PRIVILEGES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PRIVILEGES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PRIVILEGES_SYMBOL > { global . tracer . print_trace_start (& state , "PRIVILEGES_SYMBOL") ; let result = (|| { let result = PRIVILEGES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PRIVILEGES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PROCEDURE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PROCEDURE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PROCEDURE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PROCEDURE_SYMBOL > { global . tracer . print_trace_start (& state , "PROCEDURE_SYMBOL") ; let result = (|| { let result = PROCEDURE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PROCEDURE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PROCESS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PROCESS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PROCESS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PROCESS_SYMBOL > { global . tracer . print_trace_start (& state , "PROCESS_SYMBOL") ; let result = (|| { let result = PROCESS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PROCESS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PROCESSLIST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PROCESSLIST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PROCESSLIST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PROCESSLIST_SYMBOL > { global . tracer . print_trace_start (& state , "PROCESSLIST_SYMBOL") ; let result = (|| { let result = PROCESSLIST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PROCESSLIST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PROFILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PROFILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PROFILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PROFILE_SYMBOL > { global . tracer . print_trace_start (& state , "PROFILE_SYMBOL") ; let result = (|| { let result = PROFILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PROFILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PROFILES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PROFILES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PROFILES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PROFILES_SYMBOL > { global . tracer . print_trace_start (& state , "PROFILES_SYMBOL") ; let result = (|| { let result = PROFILES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PROFILES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PROXY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PROXY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PROXY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PROXY_SYMBOL > { global . tracer . print_trace_start (& state , "PROXY_SYMBOL") ; let result = (|| { let result = PROXY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PROXY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PURGE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PURGE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PURGE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PURGE_SYMBOL > { global . tracer . print_trace_start (& state , "PURGE_SYMBOL") ; let result = (|| { let result = PURGE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PURGE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod QUARTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "QUARTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_QUARTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , QUARTER_SYMBOL > { global . tracer . print_trace_start (& state , "QUARTER_SYMBOL") ; let result = (|| { let result = QUARTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: QUARTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod QUERY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "QUERY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_QUERY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , QUERY_SYMBOL > { global . tracer . print_trace_start (& state , "QUERY_SYMBOL") ; let result = (|| { let result = QUERY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: QUERY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod QUICK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "QUICK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_QUICK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , QUICK_SYMBOL > { global . tracer . print_trace_start (& state , "QUICK_SYMBOL") ; let result = (|| { let result = QUICK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: QUICK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RANGE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RANGE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RANGE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RANGE_SYMBOL > { global . tracer . print_trace_start (& state , "RANGE_SYMBOL") ; let result = (|| { let result = RANGE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RANGE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod READS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "READS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_READS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , READS_SYMBOL > { global . tracer . print_trace_start (& state , "READS_SYMBOL") ; let result = (|| { let result = READS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: READS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod READ_ONLY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "READ_ONLY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_READ_ONLY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , READ_ONLY_SYMBOL > { global . tracer . print_trace_start (& state , "READ_ONLY_SYMBOL") ; let result = (|| { let result = READ_ONLY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: READ_ONLY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod READ_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "READ") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_READ_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , READ_SYMBOL > { global . tracer . print_trace_start (& state , "READ_SYMBOL") ; let result = (|| { let result = READ_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: READ_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod READ_WRITE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "READ_WRITE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_READ_WRITE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , READ_WRITE_SYMBOL > { global . tracer . print_trace_start (& state , "READ_WRITE_SYMBOL") ; let result = (|| { let result = READ_WRITE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: READ_WRITE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REAL_SYMBOL > { global . tracer . print_trace_start (& state , "REAL_SYMBOL") ; let result = (|| { let result = REAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REBUILD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REBUILD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REBUILD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REBUILD_SYMBOL > { global . tracer . print_trace_start (& state , "REBUILD_SYMBOL") ; let result = (|| { let result = REBUILD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REBUILD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RECOVER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RECOVER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RECOVER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RECOVER_SYMBOL > { global . tracer . print_trace_start (& state , "RECOVER_SYMBOL") ; let result = (|| { let result = RECOVER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RECOVER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REDOFILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REDOFILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REDOFILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REDOFILE_SYMBOL > { global . tracer . print_trace_start (& state , "REDOFILE_SYMBOL") ; let result = (|| { let result = REDOFILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REDOFILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REDO_BUFFER_SIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REDO_BUFFER_SIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REDO_BUFFER_SIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REDO_BUFFER_SIZE_SYMBOL > { global . tracer . print_trace_start (& state , "REDO_BUFFER_SIZE_SYMBOL") ; let result = (|| { let result = REDO_BUFFER_SIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REDO_BUFFER_SIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REDUNDANT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REDUNDANT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REDUNDANT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REDUNDANT_SYMBOL > { global . tracer . print_trace_start (& state , "REDUNDANT_SYMBOL") ; let result = (|| { let result = REDUNDANT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REDUNDANT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REFERENCES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REFERENCES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REFERENCES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REFERENCES_SYMBOL > { global . tracer . print_trace_start (& state , "REFERENCES_SYMBOL") ; let result = (|| { let result = REFERENCES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REFERENCES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REGEXP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REGEXP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REGEXP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REGEXP_SYMBOL > { global . tracer . print_trace_start (& state , "REGEXP_SYMBOL") ; let result = (|| { let result = REGEXP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REGEXP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RELAY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RELAY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RELAY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RELAY_SYMBOL > { global . tracer . print_trace_start (& state , "RELAY_SYMBOL") ; let result = (|| { let result = RELAY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RELAY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RELAYLOG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RELAYLOG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RELAYLOG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RELAYLOG_SYMBOL > { global . tracer . print_trace_start (& state , "RELAYLOG_SYMBOL") ; let result = (|| { let result = RELAYLOG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RELAYLOG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RELAY_LOG_FILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RELAY_LOG_FILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RELAY_LOG_FILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RELAY_LOG_FILE_SYMBOL > { global . tracer . print_trace_start (& state , "RELAY_LOG_FILE_SYMBOL") ; let result = (|| { let result = RELAY_LOG_FILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RELAY_LOG_FILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RELAY_LOG_POS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RELAY_LOG_POS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RELAY_LOG_POS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RELAY_LOG_POS_SYMBOL > { global . tracer . print_trace_start (& state , "RELAY_LOG_POS_SYMBOL") ; let result = (|| { let result = RELAY_LOG_POS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RELAY_LOG_POS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RELAY_THREAD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RELAY_THREAD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RELAY_THREAD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RELAY_THREAD_SYMBOL > { global . tracer . print_trace_start (& state , "RELAY_THREAD_SYMBOL") ; let result = (|| { let result = RELAY_THREAD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RELAY_THREAD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RELEASE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RELEASE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RELEASE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RELEASE_SYMBOL > { global . tracer . print_trace_start (& state , "RELEASE_SYMBOL") ; let result = (|| { let result = RELEASE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RELEASE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RELOAD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RELOAD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RELOAD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RELOAD_SYMBOL > { global . tracer . print_trace_start (& state , "RELOAD_SYMBOL") ; let result = (|| { let result = RELOAD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RELOAD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REMOVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REMOVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REMOVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REMOVE_SYMBOL > { global . tracer . print_trace_start (& state , "REMOVE_SYMBOL") ; let result = (|| { let result = REMOVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REMOVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RENAME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RENAME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RENAME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RENAME_SYMBOL > { global . tracer . print_trace_start (& state , "RENAME_SYMBOL") ; let result = (|| { let result = RENAME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RENAME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REORGANIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REORGANIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REORGANIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REORGANIZE_SYMBOL > { global . tracer . print_trace_start (& state , "REORGANIZE_SYMBOL") ; let result = (|| { let result = REORGANIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REORGANIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPAIR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPAIR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPAIR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPAIR_SYMBOL > { global . tracer . print_trace_start (& state , "REPAIR_SYMBOL") ; let result = (|| { let result = REPAIR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPAIR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPEATABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPEATABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPEATABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPEATABLE_SYMBOL > { global . tracer . print_trace_start (& state , "REPEATABLE_SYMBOL") ; let result = (|| { let result = REPEATABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPEATABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPEAT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPEAT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPEAT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPEAT_SYMBOL > { global . tracer . print_trace_start (& state , "REPEAT_SYMBOL") ; let result = (|| { let result = REPEAT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPEAT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPLACE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPLACE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPLACE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPLACE_SYMBOL > { global . tracer . print_trace_start (& state , "REPLACE_SYMBOL") ; let result = (|| { let result = REPLACE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPLACE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPLICATION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPLICATION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPLICATION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPLICATION_SYMBOL > { global . tracer . print_trace_start (& state , "REPLICATION_SYMBOL") ; let result = (|| { let result = REPLICATION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPLICATION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPLICATE_DO_DB_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPLICATE_DO_DB") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPLICATE_DO_DB_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPLICATE_DO_DB_SYMBOL > { global . tracer . print_trace_start (& state , "REPLICATE_DO_DB_SYMBOL") ; let result = (|| { let result = REPLICATE_DO_DB_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPLICATE_DO_DB_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPLICATE_IGNORE_DB_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPLICATE_IGNORE_DB") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPLICATE_IGNORE_DB_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPLICATE_IGNORE_DB_SYMBOL > { global . tracer . print_trace_start (& state , "REPLICATE_IGNORE_DB_SYMBOL") ; let result = (|| { let result = REPLICATE_IGNORE_DB_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPLICATE_IGNORE_DB_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPLICATE_DO_TABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPLICATE_DO_TABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPLICATE_DO_TABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPLICATE_DO_TABLE_SYMBOL > { global . tracer . print_trace_start (& state , "REPLICATE_DO_TABLE_SYMBOL") ; let result = (|| { let result = REPLICATE_DO_TABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPLICATE_DO_TABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPLICATE_IGNORE_TABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPLICATE_IGNORE_TABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPLICATE_IGNORE_TABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPLICATE_IGNORE_TABLE_SYMBOL > { global . tracer . print_trace_start (& state , "REPLICATE_IGNORE_TABLE_SYMBOL") ; let result = (|| { let result = REPLICATE_IGNORE_TABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPLICATE_IGNORE_TABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPLICATE_WILD_DO_TABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPLICATE_WILD_DO_TABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPLICATE_WILD_DO_TABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPLICATE_WILD_DO_TABLE_SYMBOL > { global . tracer . print_trace_start (& state , "REPLICATE_WILD_DO_TABLE_SYMBOL") ; let result = (|| { let result = REPLICATE_WILD_DO_TABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPLICATE_WILD_DO_TABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPLICATE_WILD_IGNORE_TABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPLICATE_WILD_IGNORE_TABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPLICATE_WILD_IGNORE_TABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPLICATE_WILD_IGNORE_TABLE_SYMBOL > { global . tracer . print_trace_start (& state , "REPLICATE_WILD_IGNORE_TABLE_SYMBOL") ; let result = (|| { let result = REPLICATE_WILD_IGNORE_TABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPLICATE_WILD_IGNORE_TABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REPLICATE_REWRITE_DB_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REPLICATE_REWRITE_DB") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REPLICATE_REWRITE_DB_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REPLICATE_REWRITE_DB_SYMBOL > { global . tracer . print_trace_start (& state , "REPLICATE_REWRITE_DB_SYMBOL") ; let result = (|| { let result = REPLICATE_REWRITE_DB_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REPLICATE_REWRITE_DB_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REQUIRE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REQUIRE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REQUIRE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REQUIRE_SYMBOL > { global . tracer . print_trace_start (& state , "REQUIRE_SYMBOL") ; let result = (|| { let result = REQUIRE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REQUIRE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RESET_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RESET") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RESET_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RESET_SYMBOL > { global . tracer . print_trace_start (& state , "RESET_SYMBOL") ; let result = (|| { let result = RESET_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RESET_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RESIGNAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RESIGNAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RESIGNAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RESIGNAL_SYMBOL > { global . tracer . print_trace_start (& state , "RESIGNAL_SYMBOL") ; let result = (|| { let result = RESIGNAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RESIGNAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RESTORE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RESTORE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RESTORE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RESTORE_SYMBOL > { global . tracer . print_trace_start (& state , "RESTORE_SYMBOL") ; let result = (|| { let result = RESTORE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RESTORE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RESTRICT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RESTRICT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RESTRICT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RESTRICT_SYMBOL > { global . tracer . print_trace_start (& state , "RESTRICT_SYMBOL") ; let result = (|| { let result = RESTRICT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RESTRICT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RESUME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RESUME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RESUME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RESUME_SYMBOL > { global . tracer . print_trace_start (& state , "RESUME_SYMBOL") ; let result = (|| { let result = RESUME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RESUME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RETURNED_SQLSTATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RETURNED_SQLSTATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RETURNED_SQLSTATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RETURNED_SQLSTATE_SYMBOL > { global . tracer . print_trace_start (& state , "RETURNED_SQLSTATE_SYMBOL") ; let result = (|| { let result = RETURNED_SQLSTATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RETURNED_SQLSTATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RETURNS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RETURNS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RETURNS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RETURNS_SYMBOL > { global . tracer . print_trace_start (& state , "RETURNS_SYMBOL") ; let result = (|| { let result = RETURNS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RETURNS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RETURN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RETURN") }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline] pub (super) fn parse_RETURN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RETURN_SYMBOL > { global . tracer . print_trace_start (& state , "RETURN_SYMBOL") ; let result = (|| { let result = RETURN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RETURN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REVERSE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REVERSE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REVERSE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REVERSE_SYMBOL > { global . tracer . print_trace_start (& state , "REVERSE_SYMBOL") ; let result = (|| { let result = REVERSE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REVERSE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REVOKE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REVOKE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REVOKE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REVOKE_SYMBOL > { global . tracer . print_trace_start (& state , "REVOKE_SYMBOL") ; let result = (|| { let result = REVOKE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REVOKE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RIGHT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RIGHT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RIGHT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RIGHT_SYMBOL > { global . tracer . print_trace_start (& state , "RIGHT_SYMBOL") ; let result = (|| { let result = RIGHT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RIGHT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RLIKE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RLIKE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RLIKE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RLIKE_SYMBOL > { global . tracer . print_trace_start (& state , "RLIKE_SYMBOL") ; let result = (|| { let result = RLIKE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RLIKE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROLLBACK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROLLBACK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROLLBACK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROLLBACK_SYMBOL > { global . tracer . print_trace_start (& state , "ROLLBACK_SYMBOL") ; let result = (|| { let result = ROLLBACK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROLLBACK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROLLUP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROLLUP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROLLUP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROLLUP_SYMBOL > { global . tracer . print_trace_start (& state , "ROLLUP_SYMBOL") ; let result = (|| { let result = ROLLUP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROLLUP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROTATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROTATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROTATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROTATE_SYMBOL > { global . tracer . print_trace_start (& state , "ROTATE_SYMBOL") ; let result = (|| { let result = ROTATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROTATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROUTINE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROUTINE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROUTINE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROUTINE_SYMBOL > { global . tracer . print_trace_start (& state , "ROUTINE_SYMBOL") ; let result = (|| { let result = ROUTINE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROUTINE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROWS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROWS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROWS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROWS_SYMBOL > { global . tracer . print_trace_start (& state , "ROWS_SYMBOL") ; let result = (|| { let result = ROWS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROWS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROW_COUNT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROW_COUNT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROW_COUNT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROW_COUNT_SYMBOL > { global . tracer . print_trace_start (& state , "ROW_COUNT_SYMBOL") ; let result = (|| { let result = ROW_COUNT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROW_COUNT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROW_FORMAT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROW_FORMAT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROW_FORMAT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROW_FORMAT_SYMBOL > { global . tracer . print_trace_start (& state , "ROW_FORMAT_SYMBOL") ; let result = (|| { let result = ROW_FORMAT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROW_FORMAT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROW_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROW") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROW_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROW_SYMBOL > { global . tracer . print_trace_start (& state , "ROW_SYMBOL") ; let result = (|| { let result = ROW_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROW_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RTREE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RTREE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RTREE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RTREE_SYMBOL > { global . tracer . print_trace_start (& state , "RTREE_SYMBOL") ; let result = (|| { let result = RTREE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RTREE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SAVEPOINT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SAVEPOINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SAVEPOINT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SAVEPOINT_SYMBOL > { global . tracer . print_trace_start (& state , "SAVEPOINT_SYMBOL") ; let result = (|| { let result = SAVEPOINT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SAVEPOINT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SCHEDULE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SCHEDULE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SCHEDULE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SCHEDULE_SYMBOL > { global . tracer . print_trace_start (& state , "SCHEDULE_SYMBOL") ; let result = (|| { let result = SCHEDULE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SCHEDULE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SCHEMA_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SCHEMA") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SCHEMA_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SCHEMA_SYMBOL > { global . tracer . print_trace_start (& state , "SCHEMA_SYMBOL") ; let result = (|| { let result = SCHEMA_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SCHEMA_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SCHEMA_NAME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SCHEMA_NAME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SCHEMA_NAME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SCHEMA_NAME_SYMBOL > { global . tracer . print_trace_start (& state , "SCHEMA_NAME_SYMBOL") ; let result = (|| { let result = SCHEMA_NAME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SCHEMA_NAME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SCHEMAS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SCHEMAS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SCHEMAS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SCHEMAS_SYMBOL > { global . tracer . print_trace_start (& state , "SCHEMAS_SYMBOL") ; let result = (|| { let result = SCHEMAS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SCHEMAS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SECOND_MICROSECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SECOND_MICROSECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SECOND_MICROSECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SECOND_MICROSECOND_SYMBOL > { global . tracer . print_trace_start (& state , "SECOND_MICROSECOND_SYMBOL") ; let result = (|| { let result = SECOND_MICROSECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SECOND_MICROSECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SECOND_SYMBOL > { global . tracer . print_trace_start (& state , "SECOND_SYMBOL") ; let result = (|| { let result = SECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SECURITY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SECURITY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SECURITY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SECURITY_SYMBOL > { global . tracer . print_trace_start (& state , "SECURITY_SYMBOL") ; let result = (|| { let result = SECURITY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SECURITY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SELECT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SELECT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SELECT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SELECT_SYMBOL > { global . tracer . print_trace_start (& state , "SELECT_SYMBOL") ; let result = (|| { let result = SELECT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SELECT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SENSITIVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SENSITIVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SENSITIVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SENSITIVE_SYMBOL > { global . tracer . print_trace_start (& state , "SENSITIVE_SYMBOL") ; let result = (|| { let result = SENSITIVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SENSITIVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SEPARATOR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SEPARATOR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SEPARATOR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SEPARATOR_SYMBOL > { global . tracer . print_trace_start (& state , "SEPARATOR_SYMBOL") ; let result = (|| { let result = SEPARATOR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SEPARATOR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SERIALIZABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SERIALIZABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SERIALIZABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SERIALIZABLE_SYMBOL > { global . tracer . print_trace_start (& state , "SERIALIZABLE_SYMBOL") ; let result = (|| { let result = SERIALIZABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SERIALIZABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SERIAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SERIAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SERIAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SERIAL_SYMBOL > { global . tracer . print_trace_start (& state , "SERIAL_SYMBOL") ; let result = (|| { let result = SERIAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SERIAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SESSION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SESSION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SESSION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SESSION_SYMBOL > { global . tracer . print_trace_start (& state , "SESSION_SYMBOL") ; let result = (|| { let result = SESSION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SESSION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SERVER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SERVER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SERVER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SERVER_SYMBOL > { global . tracer . print_trace_start (& state , "SERVER_SYMBOL") ; let result = (|| { let result = SERVER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SERVER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SERVER_OPTIONS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SERVER_OPTIONS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SERVER_OPTIONS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SERVER_OPTIONS_SYMBOL > { global . tracer . print_trace_start (& state , "SERVER_OPTIONS_SYMBOL") ; let result = (|| { let result = SERVER_OPTIONS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SERVER_OPTIONS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SESSION_USER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SESSION_USER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SESSION_USER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SESSION_USER_SYMBOL > { global . tracer . print_trace_start (& state , "SESSION_USER_SYMBOL") ; let result = (|| { let result = SESSION_USER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SESSION_USER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SET_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SET") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SET_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SET_SYMBOL > { global . tracer . print_trace_start (& state , "SET_SYMBOL") ; let result = (|| { let result = SET_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SET_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SET_VAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SET_VAR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SET_VAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SET_VAR_SYMBOL > { global . tracer . print_trace_start (& state , "SET_VAR_SYMBOL") ; let result = (|| { let result = SET_VAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SET_VAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SHARE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SHARE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SHARE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SHARE_SYMBOL > { global . tracer . print_trace_start (& state , "SHARE_SYMBOL") ; let result = (|| { let result = SHARE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SHARE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SHOW_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SHOW") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SHOW_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SHOW_SYMBOL > { global . tracer . print_trace_start (& state , "SHOW_SYMBOL") ; let result = (|| { let result = SHOW_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SHOW_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SHUTDOWN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SHUTDOWN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SHUTDOWN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SHUTDOWN_SYMBOL > { global . tracer . print_trace_start (& state , "SHUTDOWN_SYMBOL") ; let result = (|| { let result = SHUTDOWN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SHUTDOWN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SIGNAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SIGNAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SIGNAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SIGNAL_SYMBOL > { global . tracer . print_trace_start (& state , "SIGNAL_SYMBOL") ; let result = (|| { let result = SIGNAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SIGNAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SIGNED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SIGNED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SIGNED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SIGNED_SYMBOL > { global . tracer . print_trace_start (& state , "SIGNED_SYMBOL") ; let result = (|| { let result = SIGNED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SIGNED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SIMPLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SIMPLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SIMPLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SIMPLE_SYMBOL > { global . tracer . print_trace_start (& state , "SIMPLE_SYMBOL") ; let result = (|| { let result = SIMPLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SIMPLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SLAVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SLAVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SLAVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SLAVE_SYMBOL > { global . tracer . print_trace_start (& state , "SLAVE_SYMBOL") ; let result = (|| { let result = SLAVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SLAVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SLOW_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SLOW") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SLOW_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SLOW_SYMBOL > { global . tracer . print_trace_start (& state , "SLOW_SYMBOL") ; let result = (|| { let result = SLOW_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SLOW_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SMALLINT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SMALLINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SMALLINT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SMALLINT_SYMBOL > { global . tracer . print_trace_start (& state , "SMALLINT_SYMBOL") ; let result = (|| { let result = SMALLINT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SMALLINT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SNAPSHOT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SNAPSHOT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SNAPSHOT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SNAPSHOT_SYMBOL > { global . tracer . print_trace_start (& state , "SNAPSHOT_SYMBOL") ; let result = (|| { let result = SNAPSHOT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SNAPSHOT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SOME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SOME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SOME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SOME_SYMBOL > { global . tracer . print_trace_start (& state , "SOME_SYMBOL") ; let result = (|| { let result = SOME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SOME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SOCKET_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SOCKET") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SOCKET_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SOCKET_SYMBOL > { global . tracer . print_trace_start (& state , "SOCKET_SYMBOL") ; let result = (|| { let result = SOCKET_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SOCKET_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SONAME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SONAME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SONAME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SONAME_SYMBOL > { global . tracer . print_trace_start (& state , "SONAME_SYMBOL") ; let result = (|| { let result = SONAME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SONAME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SOUNDS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SOUNDS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SOUNDS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SOUNDS_SYMBOL > { global . tracer . print_trace_start (& state , "SOUNDS_SYMBOL") ; let result = (|| { let result = SOUNDS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SOUNDS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SOURCE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SOURCE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SOURCE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SOURCE_SYMBOL > { global . tracer . print_trace_start (& state , "SOURCE_SYMBOL") ; let result = (|| { let result = SOURCE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SOURCE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SPATIAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SPATIAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SPATIAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SPATIAL_SYMBOL > { global . tracer . print_trace_start (& state , "SPATIAL_SYMBOL") ; let result = (|| { let result = SPATIAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SPATIAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SPECIFIC_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SPECIFIC") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SPECIFIC_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SPECIFIC_SYMBOL > { global . tracer . print_trace_start (& state , "SPECIFIC_SYMBOL") ; let result = (|| { let result = SPECIFIC_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SPECIFIC_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQLEXCEPTION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQLEXCEPTION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQLEXCEPTION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQLEXCEPTION_SYMBOL > { global . tracer . print_trace_start (& state , "SQLEXCEPTION_SYMBOL") ; let result = (|| { let result = SQLEXCEPTION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQLEXCEPTION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQLSTATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQLSTATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQLSTATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQLSTATE_SYMBOL > { global . tracer . print_trace_start (& state , "SQLSTATE_SYMBOL") ; let result = (|| { let result = SQLSTATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQLSTATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQLWARNING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQLWARNING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQLWARNING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQLWARNING_SYMBOL > { global . tracer . print_trace_start (& state , "SQLWARNING_SYMBOL") ; let result = (|| { let result = SQLWARNING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQLWARNING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_AFTER_GTIDS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_AFTER_GTIDS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_AFTER_GTIDS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_AFTER_GTIDS_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_AFTER_GTIDS_SYMBOL") ; let result = (|| { let result = SQL_AFTER_GTIDS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_AFTER_GTIDS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_AFTER_MTS_GAPS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_AFTER_MTS_GAPS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_AFTER_MTS_GAPS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_AFTER_MTS_GAPS_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_AFTER_MTS_GAPS_SYMBOL") ; let result = (|| { let result = SQL_AFTER_MTS_GAPS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_AFTER_MTS_GAPS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_BEFORE_GTIDS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_BEFORE_GTIDS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_BEFORE_GTIDS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_BEFORE_GTIDS_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_BEFORE_GTIDS_SYMBOL") ; let result = (|| { let result = SQL_BEFORE_GTIDS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_BEFORE_GTIDS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_BIG_RESULT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_BIG_RESULT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_BIG_RESULT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_BIG_RESULT_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_BIG_RESULT_SYMBOL") ; let result = (|| { let result = SQL_BIG_RESULT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_BIG_RESULT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_BUFFER_RESULT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_BUFFER_RESULT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_BUFFER_RESULT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_BUFFER_RESULT_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_BUFFER_RESULT_SYMBOL") ; let result = (|| { let result = SQL_BUFFER_RESULT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_BUFFER_RESULT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_CACHE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_CACHE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_CACHE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_CACHE_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_CACHE_SYMBOL") ; let result = (|| { let result = SQL_CACHE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_CACHE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_CALC_FOUND_ROWS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_CALC_FOUND_ROWS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_CALC_FOUND_ROWS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_CALC_FOUND_ROWS_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_CALC_FOUND_ROWS_SYMBOL") ; let result = (|| { let result = SQL_CALC_FOUND_ROWS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_CALC_FOUND_ROWS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_NO_CACHE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_NO_CACHE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_NO_CACHE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_NO_CACHE_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_NO_CACHE_SYMBOL") ; let result = (|| { let result = SQL_NO_CACHE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_NO_CACHE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_SMALL_RESULT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_SMALL_RESULT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_SMALL_RESULT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_SMALL_RESULT_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_SMALL_RESULT_SYMBOL") ; let result = (|| { let result = SQL_SMALL_RESULT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_SMALL_RESULT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_SYMBOL") ; let result = (|| { let result = SQL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_THREAD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_THREAD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_THREAD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_THREAD_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_THREAD_SYMBOL") ; let result = (|| { let result = SQL_THREAD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_THREAD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SSL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SSL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SSL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SSL_SYMBOL > { global . tracer . print_trace_start (& state , "SSL_SYMBOL") ; let result = (|| { let result = SSL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SSL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STACKED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STACKED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STACKED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STACKED_SYMBOL > { global . tracer . print_trace_start (& state , "STACKED_SYMBOL") ; let result = (|| { let result = STACKED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STACKED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STARTING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STARTING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STARTING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STARTING_SYMBOL > { global . tracer . print_trace_start (& state , "STARTING_SYMBOL") ; let result = (|| { let result = STARTING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STARTING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STARTS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STARTS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STARTS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STARTS_SYMBOL > { global . tracer . print_trace_start (& state , "STARTS_SYMBOL") ; let result = (|| { let result = STARTS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STARTS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod START_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "START") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_START_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , START_SYMBOL > { global . tracer . print_trace_start (& state , "START_SYMBOL") ; let result = (|| { let result = START_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: START_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STATS_AUTO_RECALC_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STATS_AUTO_RECALC") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STATS_AUTO_RECALC_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STATS_AUTO_RECALC_SYMBOL > { global . tracer . print_trace_start (& state , "STATS_AUTO_RECALC_SYMBOL") ; let result = (|| { let result = STATS_AUTO_RECALC_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STATS_AUTO_RECALC_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STATS_PERSISTENT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STATS_PERSISTENT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STATS_PERSISTENT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STATS_PERSISTENT_SYMBOL > { global . tracer . print_trace_start (& state , "STATS_PERSISTENT_SYMBOL") ; let result = (|| { let result = STATS_PERSISTENT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STATS_PERSISTENT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STATS_SAMPLE_PAGES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STATS_SAMPLE_PAGES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STATS_SAMPLE_PAGES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STATS_SAMPLE_PAGES_SYMBOL > { global . tracer . print_trace_start (& state , "STATS_SAMPLE_PAGES_SYMBOL") ; let result = (|| { let result = STATS_SAMPLE_PAGES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STATS_SAMPLE_PAGES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STATUS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STATUS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STATUS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STATUS_SYMBOL > { global . tracer . print_trace_start (& state , "STATUS_SYMBOL") ; let result = (|| { let result = STATUS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STATUS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STDDEV_SAMP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STDDEV_SAMP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STDDEV_SAMP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STDDEV_SAMP_SYMBOL > { global . tracer . print_trace_start (& state , "STDDEV_SAMP_SYMBOL") ; let result = (|| { let result = STDDEV_SAMP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STDDEV_SAMP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STDDEV_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STDDEV") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STDDEV_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STDDEV_SYMBOL > { global . tracer . print_trace_start (& state , "STDDEV_SYMBOL") ; let result = (|| { let result = STDDEV_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STDDEV_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STDDEV_POP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STDDEV_POP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STDDEV_POP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STDDEV_POP_SYMBOL > { global . tracer . print_trace_start (& state , "STDDEV_POP_SYMBOL") ; let result = (|| { let result = STDDEV_POP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STDDEV_POP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STD_SYMBOL > { global . tracer . print_trace_start (& state , "STD_SYMBOL") ; let result = (|| { let result = STD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STOP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STOP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STOP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STOP_SYMBOL > { global . tracer . print_trace_start (& state , "STOP_SYMBOL") ; let result = (|| { let result = STOP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STOP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STORAGE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STORAGE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STORAGE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STORAGE_SYMBOL > { global . tracer . print_trace_start (& state , "STORAGE_SYMBOL") ; let result = (|| { let result = STORAGE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STORAGE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STORED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STORED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STORED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STORED_SYMBOL > { global . tracer . print_trace_start (& state , "STORED_SYMBOL") ; let result = (|| { let result = STORED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STORED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STRAIGHT_JOIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STRAIGHT_JOIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STRAIGHT_JOIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STRAIGHT_JOIN_SYMBOL > { global . tracer . print_trace_start (& state , "STRAIGHT_JOIN_SYMBOL") ; let result = (|| { let result = STRAIGHT_JOIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STRAIGHT_JOIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STRING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STRING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STRING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STRING_SYMBOL > { global . tracer . print_trace_start (& state , "STRING_SYMBOL") ; let result = (|| { let result = STRING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STRING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUBCLASS_ORIGIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUBCLASS_ORIGIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUBCLASS_ORIGIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUBCLASS_ORIGIN_SYMBOL > { global . tracer . print_trace_start (& state , "SUBCLASS_ORIGIN_SYMBOL") ; let result = (|| { let result = SUBCLASS_ORIGIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUBCLASS_ORIGIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUBDATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUBDATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUBDATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUBDATE_SYMBOL > { global . tracer . print_trace_start (& state , "SUBDATE_SYMBOL") ; let result = (|| { let result = SUBDATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUBDATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUBJECT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUBJECT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUBJECT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUBJECT_SYMBOL > { global . tracer . print_trace_start (& state , "SUBJECT_SYMBOL") ; let result = (|| { let result = SUBJECT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUBJECT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUBPARTITIONS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUBPARTITIONS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUBPARTITIONS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUBPARTITIONS_SYMBOL > { global . tracer . print_trace_start (& state , "SUBPARTITIONS_SYMBOL") ; let result = (|| { let result = SUBPARTITIONS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUBPARTITIONS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUBPARTITION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUBPARTITION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUBPARTITION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUBPARTITION_SYMBOL > { global . tracer . print_trace_start (& state , "SUBPARTITION_SYMBOL") ; let result = (|| { let result = SUBPARTITION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUBPARTITION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUBSTR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUBSTR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUBSTR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUBSTR_SYMBOL > { global . tracer . print_trace_start (& state , "SUBSTR_SYMBOL") ; let result = (|| { let result = SUBSTR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUBSTR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUBSTRING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUBSTRING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUBSTRING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUBSTRING_SYMBOL > { global . tracer . print_trace_start (& state , "SUBSTRING_SYMBOL") ; let result = (|| { let result = SUBSTRING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUBSTRING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUM_SYMBOL > { global . tracer . print_trace_start (& state , "SUM_SYMBOL") ; let result = (|| { let result = SUM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUPER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUPER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUPER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUPER_SYMBOL > { global . tracer . print_trace_start (& state , "SUPER_SYMBOL") ; let result = (|| { let result = SUPER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUPER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SUSPEND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SUSPEND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SUSPEND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SUSPEND_SYMBOL > { global . tracer . print_trace_start (& state , "SUSPEND_SYMBOL") ; let result = (|| { let result = SUSPEND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SUSPEND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SWAPS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SWAPS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SWAPS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SWAPS_SYMBOL > { global . tracer . print_trace_start (& state , "SWAPS_SYMBOL") ; let result = (|| { let result = SWAPS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SWAPS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SWITCHES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SWITCHES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SWITCHES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SWITCHES_SYMBOL > { global . tracer . print_trace_start (& state , "SWITCHES_SYMBOL") ; let result = (|| { let result = SWITCHES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SWITCHES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SYSDATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SYSDATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SYSDATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SYSDATE_SYMBOL > { global . tracer . print_trace_start (& state , "SYSDATE_SYMBOL") ; let result = (|| { let result = SYSDATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SYSDATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SYSTEM_USER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SYSTEM_USER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SYSTEM_USER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SYSTEM_USER_SYMBOL > { global . tracer . print_trace_start (& state , "SYSTEM_USER_SYMBOL") ; let result = (|| { let result = SYSTEM_USER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SYSTEM_USER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TABLES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TABLES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TABLES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TABLES_SYMBOL > { global . tracer . print_trace_start (& state , "TABLES_SYMBOL") ; let result = (|| { let result = TABLES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TABLES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TABLESPACE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TABLESPACE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TABLESPACE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TABLESPACE_SYMBOL > { global . tracer . print_trace_start (& state , "TABLESPACE_SYMBOL") ; let result = (|| { let result = TABLESPACE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TABLESPACE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TABLE_REF_PRIORITY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TABLE_REF_PRIORITY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TABLE_REF_PRIORITY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TABLE_REF_PRIORITY_SYMBOL > { global . tracer . print_trace_start (& state , "TABLE_REF_PRIORITY_SYMBOL") ; let result = (|| { let result = TABLE_REF_PRIORITY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TABLE_REF_PRIORITY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TABLE_SYMBOL > { global . tracer . print_trace_start (& state , "TABLE_SYMBOL") ; let result = (|| { let result = TABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TABLE_CHECKSUM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TABLE_CHECKSUM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TABLE_CHECKSUM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TABLE_CHECKSUM_SYMBOL > { global . tracer . print_trace_start (& state , "TABLE_CHECKSUM_SYMBOL") ; let result = (|| { let result = TABLE_CHECKSUM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TABLE_CHECKSUM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TABLE_NAME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TABLE_NAME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TABLE_NAME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TABLE_NAME_SYMBOL > { global . tracer . print_trace_start (& state , "TABLE_NAME_SYMBOL") ; let result = (|| { let result = TABLE_NAME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TABLE_NAME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TEMPORARY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TEMPORARY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TEMPORARY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TEMPORARY_SYMBOL > { global . tracer . print_trace_start (& state , "TEMPORARY_SYMBOL") ; let result = (|| { let result = TEMPORARY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TEMPORARY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TEMPTABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TEMPTABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TEMPTABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TEMPTABLE_SYMBOL > { global . tracer . print_trace_start (& state , "TEMPTABLE_SYMBOL") ; let result = (|| { let result = TEMPTABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TEMPTABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TERMINATED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TERMINATED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TERMINATED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TERMINATED_SYMBOL > { global . tracer . print_trace_start (& state , "TERMINATED_SYMBOL") ; let result = (|| { let result = TERMINATED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TERMINATED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TEXT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TEXT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TEXT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TEXT_SYMBOL > { global . tracer . print_trace_start (& state , "TEXT_SYMBOL") ; let result = (|| { let result = TEXT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TEXT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod THAN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "THAN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_THAN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , THAN_SYMBOL > { global . tracer . print_trace_start (& state , "THAN_SYMBOL") ; let result = (|| { let result = THAN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: THAN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod THEN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "THEN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_THEN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , THEN_SYMBOL > { global . tracer . print_trace_start (& state , "THEN_SYMBOL") ; let result = (|| { let result = THEN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: THEN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TIMESTAMP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TIMESTAMP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TIMESTAMP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TIMESTAMP_SYMBOL > { global . tracer . print_trace_start (& state , "TIMESTAMP_SYMBOL") ; let result = (|| { let result = TIMESTAMP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TIMESTAMP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TIMESTAMP_ADD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TIMESTAMP_ADD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TIMESTAMP_ADD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TIMESTAMP_ADD_SYMBOL > { global . tracer . print_trace_start (& state , "TIMESTAMP_ADD_SYMBOL") ; let result = (|| { let result = TIMESTAMP_ADD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TIMESTAMP_ADD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TIMESTAMP_DIFF_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TIMESTAMP_DIFF") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TIMESTAMP_DIFF_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TIMESTAMP_DIFF_SYMBOL > { global . tracer . print_trace_start (& state , "TIMESTAMP_DIFF_SYMBOL") ; let result = (|| { let result = TIMESTAMP_DIFF_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TIMESTAMP_DIFF_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TIME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TIME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TIME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TIME_SYMBOL > { global . tracer . print_trace_start (& state , "TIME_SYMBOL") ; let result = (|| { let result = TIME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TIME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TINYBLOB_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TINYBLOB") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TINYBLOB_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TINYBLOB_SYMBOL > { global . tracer . print_trace_start (& state , "TINYBLOB_SYMBOL") ; let result = (|| { let result = TINYBLOB_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TINYBLOB_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TINYINT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TINYINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TINYINT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TINYINT_SYMBOL > { global . tracer . print_trace_start (& state , "TINYINT_SYMBOL") ; let result = (|| { let result = TINYINT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TINYINT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TINYTEXT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TINYTEXT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TINYTEXT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TINYTEXT_SYMBOL > { global . tracer . print_trace_start (& state , "TINYTEXT_SYMBOL") ; let result = (|| { let result = TINYTEXT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TINYTEXT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TO_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TO") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TO_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TO_SYMBOL > { global . tracer . print_trace_start (& state , "TO_SYMBOL") ; let result = (|| { let result = TO_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TO_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TRAILING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TRAILING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TRAILING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TRAILING_SYMBOL > { global . tracer . print_trace_start (& state , "TRAILING_SYMBOL") ; let result = (|| { let result = TRAILING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TRAILING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TRANSACTION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TRANSACTION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TRANSACTION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TRANSACTION_SYMBOL > { global . tracer . print_trace_start (& state , "TRANSACTION_SYMBOL") ; let result = (|| { let result = TRANSACTION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TRANSACTION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TRIGGERS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TRIGGERS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TRIGGERS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TRIGGERS_SYMBOL > { global . tracer . print_trace_start (& state , "TRIGGERS_SYMBOL") ; let result = (|| { let result = TRIGGERS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TRIGGERS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TRIGGER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TRIGGER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TRIGGER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TRIGGER_SYMBOL > { global . tracer . print_trace_start (& state , "TRIGGER_SYMBOL") ; let result = (|| { let result = TRIGGER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TRIGGER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TRIM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TRIM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TRIM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TRIM_SYMBOL > { global . tracer . print_trace_start (& state , "TRIM_SYMBOL") ; let result = (|| { let result = TRIM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TRIM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TRUE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TRUE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TRUE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TRUE_SYMBOL > { global . tracer . print_trace_start (& state , "TRUE_SYMBOL") ; let result = (|| { let result = TRUE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TRUE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TRUNCATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TRUNCATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TRUNCATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TRUNCATE_SYMBOL > { global . tracer . print_trace_start (& state , "TRUNCATE_SYMBOL") ; let result = (|| { let result = TRUNCATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TRUNCATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TYPES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TYPES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TYPES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TYPES_SYMBOL > { global . tracer . print_trace_start (& state , "TYPES_SYMBOL") ; let result = (|| { let result = TYPES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TYPES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TYPE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TYPE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TYPE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TYPE_SYMBOL > { global . tracer . print_trace_start (& state , "TYPE_SYMBOL") ; let result = (|| { let result = TYPE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TYPE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UDF_RETURNS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UDF_RETURNS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UDF_RETURNS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UDF_RETURNS_SYMBOL > { global . tracer . print_trace_start (& state , "UDF_RETURNS_SYMBOL") ; let result = (|| { let result = UDF_RETURNS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UDF_RETURNS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNCOMMITTED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNCOMMITTED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNCOMMITTED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNCOMMITTED_SYMBOL > { global . tracer . print_trace_start (& state , "UNCOMMITTED_SYMBOL") ; let result = (|| { let result = UNCOMMITTED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNCOMMITTED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNDEFINED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNDEFINED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNDEFINED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNDEFINED_SYMBOL > { global . tracer . print_trace_start (& state , "UNDEFINED_SYMBOL") ; let result = (|| { let result = UNDEFINED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNDEFINED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNDOFILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNDOFILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNDOFILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNDOFILE_SYMBOL > { global . tracer . print_trace_start (& state , "UNDOFILE_SYMBOL") ; let result = (|| { let result = UNDOFILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNDOFILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNDO_BUFFER_SIZE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNDO_BUFFER_SIZE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNDO_BUFFER_SIZE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNDO_BUFFER_SIZE_SYMBOL > { global . tracer . print_trace_start (& state , "UNDO_BUFFER_SIZE_SYMBOL") ; let result = (|| { let result = UNDO_BUFFER_SIZE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNDO_BUFFER_SIZE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNDO_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNDO") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNDO_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNDO_SYMBOL > { global . tracer . print_trace_start (& state , "UNDO_SYMBOL") ; let result = (|| { let result = UNDO_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNDO_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNICODE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNICODE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNICODE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNICODE_SYMBOL > { global . tracer . print_trace_start (& state , "UNICODE_SYMBOL") ; let result = (|| { let result = UNICODE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNICODE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNINSTALL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNINSTALL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNINSTALL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNINSTALL_SYMBOL > { global . tracer . print_trace_start (& state , "UNINSTALL_SYMBOL") ; let result = (|| { let result = UNINSTALL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNINSTALL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNION_SYMBOL > { global . tracer . print_trace_start (& state , "UNION_SYMBOL") ; let result = (|| { let result = UNION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNIQUE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNIQUE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNIQUE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNIQUE_SYMBOL > { global . tracer . print_trace_start (& state , "UNIQUE_SYMBOL") ; let result = (|| { let result = UNIQUE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNIQUE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNKNOWN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNKNOWN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNKNOWN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNKNOWN_SYMBOL > { global . tracer . print_trace_start (& state , "UNKNOWN_SYMBOL") ; let result = (|| { let result = UNKNOWN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNKNOWN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNLOCK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNLOCK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNLOCK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNLOCK_SYMBOL > { global . tracer . print_trace_start (& state , "UNLOCK_SYMBOL") ; let result = (|| { let result = UNLOCK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNLOCK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNSIGNED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNSIGNED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNSIGNED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNSIGNED_SYMBOL > { global . tracer . print_trace_start (& state , "UNSIGNED_SYMBOL") ; let result = (|| { let result = UNSIGNED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNSIGNED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNTIL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNTIL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNTIL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNTIL_SYMBOL > { global . tracer . print_trace_start (& state , "UNTIL_SYMBOL") ; let result = (|| { let result = UNTIL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNTIL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UPDATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UPDATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UPDATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UPDATE_SYMBOL > { global . tracer . print_trace_start (& state , "UPDATE_SYMBOL") ; let result = (|| { let result = UPDATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UPDATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UPGRADE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UPGRADE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UPGRADE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UPGRADE_SYMBOL > { global . tracer . print_trace_start (& state , "UPGRADE_SYMBOL") ; let result = (|| { let result = UPGRADE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UPGRADE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod USAGE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "USAGE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_USAGE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , USAGE_SYMBOL > { global . tracer . print_trace_start (& state , "USAGE_SYMBOL") ; let result = (|| { let result = USAGE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: USAGE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod USER_RESOURCES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "USER_RESOURCES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_USER_RESOURCES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , USER_RESOURCES_SYMBOL > { global . tracer . print_trace_start (& state , "USER_RESOURCES_SYMBOL") ; let result = (|| { let result = USER_RESOURCES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: USER_RESOURCES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod USER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "USER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_USER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , USER_SYMBOL > { global . tracer . print_trace_start (& state , "USER_SYMBOL") ; let result = (|| { let result = USER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: USER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod USE_FRM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "USE_FRM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_USE_FRM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , USE_FRM_SYMBOL > { global . tracer . print_trace_start (& state , "USE_FRM_SYMBOL") ; let result = (|| { let result = USE_FRM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: USE_FRM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod USE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "USE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_USE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , USE_SYMBOL > { global . tracer . print_trace_start (& state , "USE_SYMBOL") ; let result = (|| { let result = USE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: USE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod USING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "USING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_USING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , USING_SYMBOL > { global . tracer . print_trace_start (& state , "USING_SYMBOL") ; let result = (|| { let result = USING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: USING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UTC_DATE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UTC_DATE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UTC_DATE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UTC_DATE_SYMBOL > { global . tracer . print_trace_start (& state , "UTC_DATE_SYMBOL") ; let result = (|| { let result = UTC_DATE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UTC_DATE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UTC_TIMESTAMP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UTC_TIMESTAMP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UTC_TIMESTAMP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UTC_TIMESTAMP_SYMBOL > { global . tracer . print_trace_start (& state , "UTC_TIMESTAMP_SYMBOL") ; let result = (|| { let result = UTC_TIMESTAMP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UTC_TIMESTAMP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UTC_TIME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UTC_TIME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UTC_TIME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UTC_TIME_SYMBOL > { global . tracer . print_trace_start (& state , "UTC_TIME_SYMBOL") ; let result = (|| { let result = UTC_TIME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UTC_TIME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VALIDATION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VALIDATION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VALIDATION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VALIDATION_SYMBOL > { global . tracer . print_trace_start (& state , "VALIDATION_SYMBOL") ; let result = (|| { let result = VALIDATION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VALIDATION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VALUES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VALUES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VALUES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VALUES_SYMBOL > { global . tracer . print_trace_start (& state , "VALUES_SYMBOL") ; let result = (|| { let result = VALUES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VALUES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VALUE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VALUE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VALUE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VALUE_SYMBOL > { global . tracer . print_trace_start (& state , "VALUE_SYMBOL") ; let result = (|| { let result = VALUE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VALUE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VARBINARY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VARBINARY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VARBINARY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VARBINARY_SYMBOL > { global . tracer . print_trace_start (& state , "VARBINARY_SYMBOL") ; let result = (|| { let result = VARBINARY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VARBINARY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VARCHAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VARCHAR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VARCHAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VARCHAR_SYMBOL > { global . tracer . print_trace_start (& state , "VARCHAR_SYMBOL") ; let result = (|| { let result = VARCHAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VARCHAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VARCHARACTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VARCHARACTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VARCHARACTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VARCHARACTER_SYMBOL > { global . tracer . print_trace_start (& state , "VARCHARACTER_SYMBOL") ; let result = (|| { let result = VARCHARACTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VARCHARACTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VARIABLES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VARIABLES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VARIABLES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VARIABLES_SYMBOL > { global . tracer . print_trace_start (& state , "VARIABLES_SYMBOL") ; let result = (|| { let result = VARIABLES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VARIABLES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VARIANCE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VARIANCE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VARIANCE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VARIANCE_SYMBOL > { global . tracer . print_trace_start (& state , "VARIANCE_SYMBOL") ; let result = (|| { let result = VARIANCE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VARIANCE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VARYING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VARYING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VARYING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VARYING_SYMBOL > { global . tracer . print_trace_start (& state , "VARYING_SYMBOL") ; let result = (|| { let result = VARYING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VARYING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VAR_POP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VAR_POP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VAR_POP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VAR_POP_SYMBOL > { global . tracer . print_trace_start (& state , "VAR_POP_SYMBOL") ; let result = (|| { let result = VAR_POP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VAR_POP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VAR_SAMP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VAR_SAMP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VAR_SAMP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VAR_SAMP_SYMBOL > { global . tracer . print_trace_start (& state , "VAR_SAMP_SYMBOL") ; let result = (|| { let result = VAR_SAMP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VAR_SAMP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VIEW_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VIEW") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VIEW_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VIEW_SYMBOL > { global . tracer . print_trace_start (& state , "VIEW_SYMBOL") ; let result = (|| { let result = VIEW_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VIEW_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VIRTUAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VIRTUAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VIRTUAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VIRTUAL_SYMBOL > { global . tracer . print_trace_start (& state , "VIRTUAL_SYMBOL") ; let result = (|| { let result = VIRTUAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VIRTUAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WAIT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WAIT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WAIT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WAIT_SYMBOL > { global . tracer . print_trace_start (& state , "WAIT_SYMBOL") ; let result = (|| { let result = WAIT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WAIT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WARNINGS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WARNINGS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WARNINGS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WARNINGS_SYMBOL > { global . tracer . print_trace_start (& state , "WARNINGS_SYMBOL") ; let result = (|| { let result = WARNINGS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WARNINGS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WEEK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WEEK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WEEK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WEEK_SYMBOL > { global . tracer . print_trace_start (& state , "WEEK_SYMBOL") ; let result = (|| { let result = WEEK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WEEK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WEIGHT_STRING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WEIGHT_STRING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WEIGHT_STRING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WEIGHT_STRING_SYMBOL > { global . tracer . print_trace_start (& state , "WEIGHT_STRING_SYMBOL") ; let result = (|| { let result = WEIGHT_STRING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WEIGHT_STRING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WHEN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WHEN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WHEN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WHEN_SYMBOL > { global . tracer . print_trace_start (& state , "WHEN_SYMBOL") ; let result = (|| { let result = WHEN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WHEN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WHERE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WHERE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WHERE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WHERE_SYMBOL > { global . tracer . print_trace_start (& state , "WHERE_SYMBOL") ; let result = (|| { let result = WHERE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WHERE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WHILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WHILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WHILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WHILE_SYMBOL > { global . tracer . print_trace_start (& state , "WHILE_SYMBOL") ; let result = (|| { let result = WHILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WHILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WITH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WITH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WITH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WITH_SYMBOL > { global . tracer . print_trace_start (& state , "WITH_SYMBOL") ; let result = (|| { let result = WITH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WITH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WITHOUT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WITHOUT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WITHOUT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WITHOUT_SYMBOL > { global . tracer . print_trace_start (& state , "WITHOUT_SYMBOL") ; let result = (|| { let result = WITHOUT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WITHOUT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WORK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WORK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WORK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WORK_SYMBOL > { global . tracer . print_trace_start (& state , "WORK_SYMBOL") ; let result = (|| { let result = WORK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WORK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WRAPPER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WRAPPER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WRAPPER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WRAPPER_SYMBOL > { global . tracer . print_trace_start (& state , "WRAPPER_SYMBOL") ; let result = (|| { let result = WRAPPER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WRAPPER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WRITE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WRITE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WRITE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WRITE_SYMBOL > { global . tracer . print_trace_start (& state , "WRITE_SYMBOL") ; let result = (|| { let result = WRITE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WRITE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod X509_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "X509") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_X509_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , X509_SYMBOL > { global . tracer . print_trace_start (& state , "X509_SYMBOL") ; let result = (|| { let result = X509_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: X509_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod XA_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "XA") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_XA_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , XA_SYMBOL > { global . tracer . print_trace_start (& state , "XA_SYMBOL") ; let result = (|| { let result = XA_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: XA_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod XID_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "XID") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_XID_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , XID_SYMBOL > { global . tracer . print_trace_start (& state , "XID_SYMBOL") ; let result = (|| { let result = XID_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: XID_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod XML_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "XML") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_XML_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , XML_SYMBOL > { global . tracer . print_trace_start (& state , "XML_SYMBOL") ; let result = (|| { let result = XML_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: XML_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod XOR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "XOR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_XOR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , XOR_SYMBOL > { global . tracer . print_trace_start (& state , "XOR_SYMBOL") ; let result = (|| { let result = XOR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: XOR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod YEAR_MONTH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "YEAR_MONTH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_YEAR_MONTH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , YEAR_MONTH_SYMBOL > { global . tracer . print_trace_start (& state , "YEAR_MONTH_SYMBOL") ; let result = (|| { let result = YEAR_MONTH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: YEAR_MONTH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod YEAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "YEAR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_YEAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , YEAR_SYMBOL > { global . tracer . print_trace_start (& state , "YEAR_SYMBOL") ; let result = (|| { let result = YEAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: YEAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ZEROFILL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ZEROFILL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ZEROFILL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ZEROFILL_SYMBOL > { global . tracer . print_trace_start (& state , "ZEROFILL_SYMBOL") ; let result = (|| { let result = ZEROFILL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ZEROFILL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PERSIST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PERSIST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PERSIST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PERSIST_SYMBOL > { global . tracer . print_trace_start (& state , "PERSIST_SYMBOL") ; let result = (|| { let result = PERSIST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PERSIST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROLE_SYMBOL > { global . tracer . print_trace_start (& state , "ROLE_SYMBOL") ; let result = (|| { let result = ROLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ADMIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ADMIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ADMIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ADMIN_SYMBOL > { global . tracer . print_trace_start (& state , "ADMIN_SYMBOL") ; let result = (|| { let result = ADMIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ADMIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INVISIBLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INVISIBLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INVISIBLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INVISIBLE_SYMBOL > { global . tracer . print_trace_start (& state , "INVISIBLE_SYMBOL") ; let result = (|| { let result = INVISIBLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INVISIBLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VISIBLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VISIBLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VISIBLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VISIBLE_SYMBOL > { global . tracer . print_trace_start (& state , "VISIBLE_SYMBOL") ; let result = (|| { let result = VISIBLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VISIBLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXCEPT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXCEPT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXCEPT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXCEPT_SYMBOL > { global . tracer . print_trace_start (& state , "EXCEPT_SYMBOL") ; let result = (|| { let result = EXCEPT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXCEPT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod COMPONENT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "COMPONENT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_COMPONENT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , COMPONENT_SYMBOL > { global . tracer . print_trace_start (& state , "COMPONENT_SYMBOL") ; let result = (|| { let result = COMPONENT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: COMPONENT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RECURSIVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RECURSIVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RECURSIVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RECURSIVE_SYMBOL > { global . tracer . print_trace_start (& state , "RECURSIVE_SYMBOL") ; let result = (|| { let result = RECURSIVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RECURSIVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod JSON_OBJECTAGG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "JSON_OBJECTAGG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_JSON_OBJECTAGG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , JSON_OBJECTAGG_SYMBOL > { global . tracer . print_trace_start (& state , "JSON_OBJECTAGG_SYMBOL") ; let result = (|| { let result = JSON_OBJECTAGG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: JSON_OBJECTAGG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod JSON_ARRAYAGG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "JSON_ARRAYAGG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_JSON_ARRAYAGG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , JSON_ARRAYAGG_SYMBOL > { global . tracer . print_trace_start (& state , "JSON_ARRAYAGG_SYMBOL") ; let result = (|| { let result = JSON_ARRAYAGG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: JSON_ARRAYAGG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OF_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OF") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OF_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OF_SYMBOL > { global . tracer . print_trace_start (& state , "OF_SYMBOL") ; let result = (|| { let result = OF_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OF_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SKIP_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SKIP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SKIP_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SKIP_SYMBOL > { global . tracer . print_trace_start (& state , "SKIP_SYMBOL") ; let result = (|| { let result = SKIP_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SKIP_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LOCKED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LOCKED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LOCKED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LOCKED_SYMBOL > { global . tracer . print_trace_start (& state , "LOCKED_SYMBOL") ; let result = (|| { let result = LOCKED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LOCKED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NOWAIT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NOWAIT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NOWAIT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NOWAIT_SYMBOL > { global . tracer . print_trace_start (& state , "NOWAIT_SYMBOL") ; let result = (|| { let result = NOWAIT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NOWAIT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GROUPING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GROUPING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GROUPING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GROUPING_SYMBOL > { global . tracer . print_trace_start (& state , "GROUPING_SYMBOL") ; let result = (|| { let result = GROUPING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GROUPING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PERSIST_ONLY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PERSIST_ONLY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PERSIST_ONLY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PERSIST_ONLY_SYMBOL > { global . tracer . print_trace_start (& state , "PERSIST_ONLY_SYMBOL") ; let result = (|| { let result = PERSIST_ONLY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PERSIST_ONLY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HISTOGRAM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HISTOGRAM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HISTOGRAM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HISTOGRAM_SYMBOL > { global . tracer . print_trace_start (& state , "HISTOGRAM_SYMBOL") ; let result = (|| { let result = HISTOGRAM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HISTOGRAM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod BUCKETS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "BUCKETS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_BUCKETS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , BUCKETS_SYMBOL > { global . tracer . print_trace_start (& state , "BUCKETS_SYMBOL") ; let result = (|| { let result = BUCKETS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: BUCKETS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REMOTE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REMOTE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REMOTE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REMOTE_SYMBOL > { global . tracer . print_trace_start (& state , "REMOTE_SYMBOL") ; let result = (|| { let result = REMOTE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REMOTE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CLONE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CLONE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CLONE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CLONE_SYMBOL > { global . tracer . print_trace_start (& state , "CLONE_SYMBOL") ; let result = (|| { let result = CLONE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CLONE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod CUME_DIST_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "CUME_DIST") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_CUME_DIST_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , CUME_DIST_SYMBOL > { global . tracer . print_trace_start (& state , "CUME_DIST_SYMBOL") ; let result = (|| { let result = CUME_DIST_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: CUME_DIST_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DENSE_RANK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DENSE_RANK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DENSE_RANK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DENSE_RANK_SYMBOL > { global . tracer . print_trace_start (& state , "DENSE_RANK_SYMBOL") ; let result = (|| { let result = DENSE_RANK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DENSE_RANK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EXCLUDE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EXCLUDE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EXCLUDE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EXCLUDE_SYMBOL > { global . tracer . print_trace_start (& state , "EXCLUDE_SYMBOL") ; let result = (|| { let result = EXCLUDE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EXCLUDE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FIRST_VALUE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FIRST_VALUE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FIRST_VALUE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FIRST_VALUE_SYMBOL > { global . tracer . print_trace_start (& state , "FIRST_VALUE_SYMBOL") ; let result = (|| { let result = FIRST_VALUE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FIRST_VALUE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FOLLOWING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FOLLOWING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FOLLOWING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FOLLOWING_SYMBOL > { global . tracer . print_trace_start (& state , "FOLLOWING_SYMBOL") ; let result = (|| { let result = FOLLOWING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FOLLOWING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GROUPS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GROUPS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GROUPS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GROUPS_SYMBOL > { global . tracer . print_trace_start (& state , "GROUPS_SYMBOL") ; let result = (|| { let result = GROUPS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GROUPS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LAG_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LAG") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LAG_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LAG_SYMBOL > { global . tracer . print_trace_start (& state , "LAG_SYMBOL") ; let result = (|| { let result = LAG_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LAG_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LAST_VALUE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LAST_VALUE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LAST_VALUE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LAST_VALUE_SYMBOL > { global . tracer . print_trace_start (& state , "LAST_VALUE_SYMBOL") ; let result = (|| { let result = LAST_VALUE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LAST_VALUE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LEAD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LEAD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LEAD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LEAD_SYMBOL > { global . tracer . print_trace_start (& state , "LEAD_SYMBOL") ; let result = (|| { let result = LEAD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LEAD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NTH_VALUE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NTH_VALUE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NTH_VALUE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NTH_VALUE_SYMBOL > { global . tracer . print_trace_start (& state , "NTH_VALUE_SYMBOL") ; let result = (|| { let result = NTH_VALUE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NTH_VALUE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NTILE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NTILE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NTILE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NTILE_SYMBOL > { global . tracer . print_trace_start (& state , "NTILE_SYMBOL") ; let result = (|| { let result = NTILE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NTILE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NULLS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NULLS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NULLS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NULLS_SYMBOL > { global . tracer . print_trace_start (& state , "NULLS_SYMBOL") ; let result = (|| { let result = NULLS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NULLS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OTHERS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OTHERS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OTHERS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OTHERS_SYMBOL > { global . tracer . print_trace_start (& state , "OTHERS_SYMBOL") ; let result = (|| { let result = OTHERS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OTHERS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OVER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OVER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OVER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OVER_SYMBOL > { global . tracer . print_trace_start (& state , "OVER_SYMBOL") ; let result = (|| { let result = OVER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OVER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PERCENT_RANK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PERCENT_RANK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PERCENT_RANK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PERCENT_RANK_SYMBOL > { global . tracer . print_trace_start (& state , "PERCENT_RANK_SYMBOL") ; let result = (|| { let result = PERCENT_RANK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PERCENT_RANK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PRECEDING_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PRECEDING") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PRECEDING_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PRECEDING_SYMBOL > { global . tracer . print_trace_start (& state , "PRECEDING_SYMBOL") ; let result = (|| { let result = PRECEDING_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PRECEDING_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RANK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RANK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RANK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RANK_SYMBOL > { global . tracer . print_trace_start (& state , "RANK_SYMBOL") ; let result = (|| { let result = RANK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RANK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RESPECT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RESPECT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RESPECT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RESPECT_SYMBOL > { global . tracer . print_trace_start (& state , "RESPECT_SYMBOL") ; let result = (|| { let result = RESPECT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RESPECT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ROW_NUMBER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ROW_NUMBER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ROW_NUMBER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ROW_NUMBER_SYMBOL > { global . tracer . print_trace_start (& state , "ROW_NUMBER_SYMBOL") ; let result = (|| { let result = ROW_NUMBER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ROW_NUMBER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod TIES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TIES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_TIES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , TIES_SYMBOL > { global . tracer . print_trace_start (& state , "TIES_SYMBOL") ; let result = (|| { let result = TIES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: TIES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod UNBOUNDED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "UNBOUNDED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_UNBOUNDED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , UNBOUNDED_SYMBOL > { global . tracer . print_trace_start (& state , "UNBOUNDED_SYMBOL") ; let result = (|| { let result = UNBOUNDED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: UNBOUNDED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WINDOW_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "WINDOW") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_WINDOW_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WINDOW_SYMBOL > { global . tracer . print_trace_start (& state , "WINDOW_SYMBOL") ; let result = (|| { let result = WINDOW_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: WINDOW_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EMPTY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "EMPTY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EMPTY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EMPTY_SYMBOL > { global . tracer . print_trace_start (& state , "EMPTY_SYMBOL") ; let result = (|| { let result = EMPTY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: EMPTY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod JSON_TABLE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "JSON_TABLE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_JSON_TABLE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , JSON_TABLE_SYMBOL > { global . tracer . print_trace_start (& state , "JSON_TABLE_SYMBOL") ; let result = (|| { let result = JSON_TABLE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: JSON_TABLE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NESTED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NESTED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NESTED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NESTED_SYMBOL > { global . tracer . print_trace_start (& state , "NESTED_SYMBOL") ; let result = (|| { let result = NESTED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NESTED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ORDINALITY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ORDINALITY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ORDINALITY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ORDINALITY_SYMBOL > { global . tracer . print_trace_start (& state , "ORDINALITY_SYMBOL") ; let result = (|| { let result = ORDINALITY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ORDINALITY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PATH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PATH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PATH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PATH_SYMBOL > { global . tracer . print_trace_start (& state , "PATH_SYMBOL") ; let result = (|| { let result = PATH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PATH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod HISTORY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "HISTORY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_HISTORY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , HISTORY_SYMBOL > { global . tracer . print_trace_start (& state , "HISTORY_SYMBOL") ; let result = (|| { let result = HISTORY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: HISTORY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REUSE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REUSE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REUSE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REUSE_SYMBOL > { global . tracer . print_trace_start (& state , "REUSE_SYMBOL") ; let result = (|| { let result = REUSE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REUSE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SRID_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SRID") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SRID_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SRID_SYMBOL > { global . tracer . print_trace_start (& state , "SRID_SYMBOL") ; let result = (|| { let result = SRID_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SRID_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod THREAD_PRIORITY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "THREAD_PRIORITY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_THREAD_PRIORITY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , THREAD_PRIORITY_SYMBOL > { global . tracer . print_trace_start (& state , "THREAD_PRIORITY_SYMBOL") ; let result = (|| { let result = THREAD_PRIORITY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: THREAD_PRIORITY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RESOURCE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RESOURCE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RESOURCE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RESOURCE_SYMBOL > { global . tracer . print_trace_start (& state , "RESOURCE_SYMBOL") ; let result = (|| { let result = RESOURCE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RESOURCE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SYSTEM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SYSTEM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SYSTEM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SYSTEM_SYMBOL > { global . tracer . print_trace_start (& state , "SYSTEM_SYMBOL") ; let result = (|| { let result = SYSTEM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SYSTEM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VCPU_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "VCPU") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_VCPU_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VCPU_SYMBOL > { global . tracer . print_trace_start (& state , "VCPU_SYMBOL") ; let result = (|| { let result = VCPU_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: VCPU_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_PUBLIC_KEY_PATH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_PUBLIC_KEY_PATH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_PUBLIC_KEY_PATH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_PUBLIC_KEY_PATH_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_PUBLIC_KEY_PATH_SYMBOL") ; let result = (|| { let result = MASTER_PUBLIC_KEY_PATH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_PUBLIC_KEY_PATH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod GET_MASTER_PUBLIC_KEY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "GET_MASTER_PUBLIC_KEY_SYM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_GET_MASTER_PUBLIC_KEY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , GET_MASTER_PUBLIC_KEY_SYMBOL > { global . tracer . print_trace_start (& state , "GET_MASTER_PUBLIC_KEY_SYMBOL") ; let result = (|| { let result = GET_MASTER_PUBLIC_KEY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: GET_MASTER_PUBLIC_KEY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RESTART_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RESTART") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RESTART_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RESTART_SYMBOL > { global . tracer . print_trace_start (& state , "RESTART_SYMBOL") ; let result = (|| { let result = RESTART_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RESTART_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DEFINITION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DEFINITION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DEFINITION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DEFINITION_SYMBOL > { global . tracer . print_trace_start (& state , "DEFINITION_SYMBOL") ; let result = (|| { let result = DEFINITION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DEFINITION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DESCRIPTION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "DESCRIPTION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DESCRIPTION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DESCRIPTION_SYMBOL > { global . tracer . print_trace_start (& state , "DESCRIPTION_SYMBOL") ; let result = (|| { let result = DESCRIPTION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: DESCRIPTION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ORGANIZATION_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ORGANIZATION") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ORGANIZATION_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ORGANIZATION_SYMBOL > { global . tracer . print_trace_start (& state , "ORGANIZATION_SYMBOL") ; let result = (|| { let result = ORGANIZATION_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ORGANIZATION_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REFERENCE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REFERENCE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REFERENCE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REFERENCE_SYMBOL > { global . tracer . print_trace_start (& state , "REFERENCE_SYMBOL") ; let result = (|| { let result = REFERENCE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REFERENCE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OPTIONAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OPTIONAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OPTIONAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OPTIONAL_SYMBOL > { global . tracer . print_trace_start (& state , "OPTIONAL_SYMBOL") ; let result = (|| { let result = OPTIONAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OPTIONAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SECONDARY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SECONDARY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SECONDARY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SECONDARY_SYMBOL > { global . tracer . print_trace_start (& state , "SECONDARY_SYMBOL") ; let result = (|| { let result = SECONDARY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SECONDARY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SECONDARY_ENGINE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SECONDARY_ENGINE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SECONDARY_ENGINE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SECONDARY_ENGINE_SYMBOL > { global . tracer . print_trace_start (& state , "SECONDARY_ENGINE_SYMBOL") ; let result = (|| { let result = SECONDARY_ENGINE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SECONDARY_ENGINE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SECONDARY_LOAD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SECONDARY_LOAD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SECONDARY_LOAD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SECONDARY_LOAD_SYMBOL > { global . tracer . print_trace_start (& state , "SECONDARY_LOAD_SYMBOL") ; let result = (|| { let result = SECONDARY_LOAD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SECONDARY_LOAD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SECONDARY_UNLOAD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SECONDARY_UNLOAD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SECONDARY_UNLOAD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SECONDARY_UNLOAD_SYMBOL > { global . tracer . print_trace_start (& state , "SECONDARY_UNLOAD_SYMBOL") ; let result = (|| { let result = SECONDARY_UNLOAD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SECONDARY_UNLOAD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ACTIVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ACTIVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ACTIVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ACTIVE_SYMBOL > { global . tracer . print_trace_start (& state , "ACTIVE_SYMBOL") ; let result = (|| { let result = ACTIVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ACTIVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INACTIVE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INACTIVE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INACTIVE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INACTIVE_SYMBOL > { global . tracer . print_trace_start (& state , "INACTIVE_SYMBOL") ; let result = (|| { let result = INACTIVE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INACTIVE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod LATERAL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "LATERAL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_LATERAL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , LATERAL_SYMBOL > { global . tracer . print_trace_start (& state , "LATERAL_SYMBOL") ; let result = (|| { let result = LATERAL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: LATERAL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RETAIN_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RETAIN") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RETAIN_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RETAIN_SYMBOL > { global . tracer . print_trace_start (& state , "RETAIN_SYMBOL") ; let result = (|| { let result = RETAIN_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RETAIN_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OLD_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OLD") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OLD_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OLD_SYMBOL > { global . tracer . print_trace_start (& state , "OLD_SYMBOL") ; let result = (|| { let result = OLD_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OLD_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NETWORK_NAMESPACE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NETWORK_NAMESPACE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NETWORK_NAMESPACE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NETWORK_NAMESPACE_SYMBOL > { global . tracer . print_trace_start (& state , "NETWORK_NAMESPACE_SYMBOL") ; let result = (|| { let result = NETWORK_NAMESPACE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: NETWORK_NAMESPACE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ENFORCED_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ENFORCED") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ENFORCED_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ENFORCED_SYMBOL > { global . tracer . print_trace_start (& state , "ENFORCED_SYMBOL") ; let result = (|| { let result = ENFORCED_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ENFORCED_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ARRAY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "ARRAY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ARRAY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ARRAY_SYMBOL > { global . tracer . print_trace_start (& state , "ARRAY_SYMBOL") ; let result = (|| { let result = ARRAY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: ARRAY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OJ_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OJ") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OJ_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OJ_SYMBOL > { global . tracer . print_trace_start (& state , "OJ_SYMBOL") ; let result = (|| { let result = OJ_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OJ_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MEMBER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MEMBER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MEMBER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MEMBER_SYMBOL > { global . tracer . print_trace_start (& state , "MEMBER_SYMBOL") ; let result = (|| { let result = MEMBER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MEMBER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod RANDOM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "RANDOM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_RANDOM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , RANDOM_SYMBOL > { global . tracer . print_trace_start (& state , "RANDOM_SYMBOL") ; let result = (|| { let result = RANDOM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: RANDOM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_COMPRESSION_ALGORITHM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_COMPRESSION_ALGORITHM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_COMPRESSION_ALGORITHM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_COMPRESSION_ALGORITHM_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_COMPRESSION_ALGORITHM_SYMBOL") ; let result = (|| { let result = MASTER_COMPRESSION_ALGORITHM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_COMPRESSION_ALGORITHM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_ZSTD_COMPRESSION_LEVEL") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL") ; let result = (|| { let result = MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PRIVILEGE_CHECKS_USER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PRIVILEGE_CHECKS_USER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PRIVILEGE_CHECKS_USER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PRIVILEGE_CHECKS_USER_SYMBOL > { global . tracer . print_trace_start (& state , "PRIVILEGE_CHECKS_USER_SYMBOL") ; let result = (|| { let result = PRIVILEGE_CHECKS_USER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PRIVILEGE_CHECKS_USER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MASTER_TLS_CIPHERSUITES_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "MASTER_TLS_CIPHERSUITES") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_MASTER_TLS_CIPHERSUITES_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MASTER_TLS_CIPHERSUITES_SYMBOL > { global . tracer . print_trace_start (& state , "MASTER_TLS_CIPHERSUITES_SYMBOL") ; let result = (|| { let result = MASTER_TLS_CIPHERSUITES_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: MASTER_TLS_CIPHERSUITES_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REQUIRE_ROW_FORMAT_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REQUIRE_ROW_FORMAT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REQUIRE_ROW_FORMAT_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REQUIRE_ROW_FORMAT_SYMBOL > { global . tracer . print_trace_start (& state , "REQUIRE_ROW_FORMAT_SYMBOL") ; let result = (|| { let result = REQUIRE_ROW_FORMAT_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REQUIRE_ROW_FORMAT_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PASSWORD_LOCK_TIME_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PASSWORD_LOCK_TIME") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PASSWORD_LOCK_TIME_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PASSWORD_LOCK_TIME_SYMBOL > { global . tracer . print_trace_start (& state , "PASSWORD_LOCK_TIME_SYMBOL") ; let result = (|| { let result = PASSWORD_LOCK_TIME_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: PASSWORD_LOCK_TIME_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FAILED_LOGIN_ATTEMPTS_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FAILED_LOGIN_ATTEMPTS") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_FAILED_LOGIN_ATTEMPTS_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FAILED_LOGIN_ATTEMPTS_SYMBOL > { global . tracer . print_trace_start (& state , "FAILED_LOGIN_ATTEMPTS_SYMBOL") ; let result = (|| { let result = FAILED_LOGIN_ATTEMPTS_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: FAILED_LOGIN_ATTEMPTS_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "REQUIRE_TABLE_PRIMARY_KEY_CHECK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL > { global . tracer . print_trace_start (& state , "REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL") ; let result = (|| { let result = REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod STREAM_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STREAM") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_STREAM_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , STREAM_SYMBOL > { global . tracer . print_trace_start (& state , "STREAM_SYMBOL") ; let result = (|| { let result = STREAM_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: STREAM_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod OFF_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "OFF") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_OFF_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , OFF_SYMBOL > { global . tracer . print_trace_start (& state , "OFF_SYMBOL") ; let result = (|| { let result = OFF_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: OFF_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INT1_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INT1") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INT1_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INT1_SYMBOL > { global . tracer . print_trace_start (& state , "INT1_SYMBOL") ; let result = (|| { let result = INT1_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INT1_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INT2_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INT2") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INT2_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INT2_SYMBOL > { global . tracer . print_trace_start (& state , "INT2_SYMBOL") ; let result = (|| { let result = INT2_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INT2_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INT3_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INT3") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INT3_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INT3_SYMBOL > { global . tracer . print_trace_start (& state , "INT3_SYMBOL") ; let result = (|| { let result = INT3_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INT3_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INT4_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INT4") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INT4_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INT4_SYMBOL > { global . tracer . print_trace_start (& state , "INT4_SYMBOL") ; let result = (|| { let result = INT4_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INT4_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod INT8_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "INT8") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_INT8_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INT8_SYMBOL > { global . tracer . print_trace_start (& state , "INT8_SYMBOL") ; let result = (|| { let result = INT8_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: INT8_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_TSI_SECOND_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_TSI_SECOND") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_TSI_SECOND_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_TSI_SECOND_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_TSI_SECOND_SYMBOL") ; let result = (|| { let result = SQL_TSI_SECOND_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_TSI_SECOND_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_TSI_MINUTE_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_TSI_MINUTE") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_TSI_MINUTE_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_TSI_MINUTE_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_TSI_MINUTE_SYMBOL") ; let result = (|| { let result = SQL_TSI_MINUTE_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_TSI_MINUTE_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_TSI_HOUR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_TSI_HOUR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_TSI_HOUR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_TSI_HOUR_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_TSI_HOUR_SYMBOL") ; let result = (|| { let result = SQL_TSI_HOUR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_TSI_HOUR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_TSI_DAY_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_TSI_DAY") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_TSI_DAY_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_TSI_DAY_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_TSI_DAY_SYMBOL") ; let result = (|| { let result = SQL_TSI_DAY_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_TSI_DAY_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_TSI_WEEK_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_TSI_WEEK") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_TSI_WEEK_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_TSI_WEEK_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_TSI_WEEK_SYMBOL") ; let result = (|| { let result = SQL_TSI_WEEK_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_TSI_WEEK_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_TSI_MONTH_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_TSI_MONTH") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_TSI_MONTH_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_TSI_MONTH_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_TSI_MONTH_SYMBOL") ; let result = (|| { let result = SQL_TSI_MONTH_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_TSI_MONTH_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_TSI_QUARTER_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_TSI_QUARTER") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_TSI_QUARTER_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_TSI_QUARTER_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_TSI_QUARTER_SYMBOL") ; let result = (|| { let result = SQL_TSI_QUARTER_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_TSI_QUARTER_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SQL_TSI_YEAR_SYMBOL_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "SQL_TSI_YEAR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_SQL_TSI_YEAR_SYMBOL < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SQL_TSI_YEAR_SYMBOL > { global . tracer . print_trace_start (& state , "SQL_TSI_YEAR_SYMBOL") ; let result = (|| { let result = SQL_TSI_YEAR_SYMBOL_impl :: parse (state , global) ? . map (| r | super :: SQL_TSI_YEAR_SYMBOL { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod WHITESPACE_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match ChoiceHelper :: new (state . clone ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ' ') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\t') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\r') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\n') }) . discard_result ()) . end () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_WHITESPACE < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , WHITESPACE > { global . tracer . print_trace_start (& state , "WHITESPACE") ; let result = (|| { let result = WHITESPACE_impl :: parse (state , global) ? . map (| r | super :: WHITESPACE { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } # [inline] pub (super) fn parse_INVALID_INPUT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , INVALID_INPUT > { if let Ok (result) = parse_character_range (state . clone () , '\u{1}' , '\u{8}') { return Ok (result) } if let Ok (result) = parse_character_literal (state . clone () , '\u{b}') { return Ok (result) } if let Ok (result) = parse_character_literal (state . clone () , '\u{c}') { return Ok (result) } if let Ok (result) = parse_character_range (state . clone () , '\u{e}' , '\u{1f}') { return Ok (result) } if let Ok (result) = parse_character_literal (state . clone () , '[') { return Ok (result) } if let Ok (result) = parse_character_literal (state . clone () , ']') { return Ok (result) } Err (state . report_error (ParseErrorSpecifics :: ExpectedCharacterClass { name : "INVALID_INPUT" })) } mod EOF_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_end_of_input (state ,) }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_EOF < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EOF > { global . tracer . print_trace_start (& state , "EOF") ; let result = (|| { let result = EOF_impl :: parse (state , global) ? . map (| r | super :: EOF { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }
