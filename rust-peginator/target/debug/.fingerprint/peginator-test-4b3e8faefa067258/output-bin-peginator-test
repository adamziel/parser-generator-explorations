{"$message_type":"diagnostic","message":"cannot find type `Ident` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/test_parser.rs","byte_start":232,"byte_end":237,"line_start":5,"line_end":5,"column_start":66,"column_end":71,"is_primary":true,"text":[{"text":"# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"->\") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"fn\") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , \"FunctionDef\") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , \"ParamList\") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , \"Param\") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"self\") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , \"SelfParam\") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , \"Type\") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , \"ReferenceMarker\") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , \"ImmutableReference\") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"mut\") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , \"MutableReference\") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }","highlight_start":66,"highlight_end":71}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `Ident` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/test_parser.rs:5:66\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Opt\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Ident` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/test_parser.rs","byte_start":490,"byte_end":495,"line_start":5,"line_end":5,"column_start":324,"column_end":329,"is_primary":true,"text":[{"text":"# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"->\") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"fn\") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , \"FunctionDef\") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , \"ParamList\") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , \"Param\") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"self\") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , \"SelfParam\") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , \"Type\") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , \"ReferenceMarker\") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , \"ImmutableReference\") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"mut\") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , \"MutableReference\") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }","highlight_start":324,"highlight_end":329}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `Ident` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/test_parser.rs:5:324\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mbug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfPara\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Ident` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/test_parser.rs","byte_start":721,"byte_end":726,"line_start":5,"line_end":5,"column_start":555,"column_end":560,"is_primary":true,"text":[{"text":"# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"->\") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"fn\") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , \"FunctionDef\") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , \"ParamList\") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , \"Param\") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"self\") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , \"SelfParam\") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , \"Type\") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , \"ReferenceMarker\") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , \"ImmutableReference\") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"mut\") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , \"MutableReference\") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }","highlight_start":555,"highlight_end":560}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `Ident` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/test_parser.rs:5:555\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m: Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Ident` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/test_parser.rs","byte_start":4366,"byte_end":4371,"line_start":5,"line_end":5,"column_start":4200,"column_end":4205,"is_primary":true,"text":[{"text":"# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"->\") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"fn\") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , \"FunctionDef\") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , \"ParamList\") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , \"Param\") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"self\") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , \"SelfParam\") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , \"Type\") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , \"ReferenceMarker\") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , \"ImmutableReference\") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"mut\") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , \"MutableReference\") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }","highlight_start":4200,"highlight_end":4205}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `Ident` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/test_parser.rs:5:4200\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m} , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , }\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Ident` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/test_parser.rs","byte_start":11030,"byte_end":11035,"line_start":5,"line_end":5,"column_start":10864,"column_end":10869,"is_primary":true,"text":[{"text":"# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"->\") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"fn\") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , \"FunctionDef\") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , \"ParamList\") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , \"Param\") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"self\") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , \"SelfParam\") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , \"Type\") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , \"ReferenceMarker\") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , \"ImmutableReference\") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"mut\") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , \"MutableReference\") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }","highlight_start":10864,"highlight_end":10869}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `Ident` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/test_parser.rs:5:10864\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m} , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , T\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `Ident` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/test_parser.rs","byte_start":13651,"byte_end":13656,"line_start":5,"line_end":5,"column_start":13485,"column_end":13490,"is_primary":true,"text":[{"text":"# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"->\") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"fn\") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , \"FunctionDef\") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , \"ParamList\") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , \"Param\") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"self\") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , \"SelfParam\") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , \"Type\") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , \"ReferenceMarker\") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , \"ImmutableReference\") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"mut\") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , \"MutableReference\") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }","highlight_start":13485,"highlight_end":13490}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `Ident` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/test_parser.rs:5:13485\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m: Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `parse_Ident` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/test_parser.rs","byte_start":3593,"byte_end":3604,"line_start":5,"line_end":5,"column_start":3427,"column_end":3438,"is_primary":true,"text":[{"text":"# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"->\") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"fn\") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , \"FunctionDef\") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , \"ParamList\") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , \"Param\") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"self\") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , \"SelfParam\") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , \"Type\") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , \"ReferenceMarker\") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , \"ImmutableReference\") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"mut\") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , \"MutableReference\") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }","highlight_start":3427,"highlight_end":3438}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find function `parse_Ident` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/test_parser.rs:5:3427\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `parse_Ident` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/test_parser.rs","byte_start":10553,"byte_end":10564,"line_start":5,"line_end":5,"column_start":10387,"column_end":10398,"is_primary":true,"text":[{"text":"# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"->\") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"fn\") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , \"FunctionDef\") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , \"ParamList\") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , \"Param\") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"self\") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , \"SelfParam\") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , \"Type\") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , \"ReferenceMarker\") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , \"ImmutableReference\") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"mut\") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , \"MutableReference\") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }","highlight_start":10387,"highlight_end":10398}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find function `parse_Ident` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/test_parser.rs:5:10387\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `parse_Ident` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/test_parser.rs","byte_start":13459,"byte_end":13470,"line_start":5,"line_end":5,"column_start":13293,"column_end":13304,"is_primary":true,"text":[{"text":"# [derive (Debug , Clone ,)] pub struct FunctionDef { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } # [derive (Debug , Clone ,)] pub struct ParamList { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } # [derive (Debug , Clone ,)] pub struct Param { pub name : Ident , pub typ : Type , } # [derive (Debug , Clone ,)] pub struct SelfParam { pub ref_type : Option < ReferenceMarker > , } # [derive (Debug , Clone ,)] pub struct Type { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum ReferenceMarker { ImmutableReference (ImmutableReference) , MutableReference (MutableReference) , } # [derive (Debug , Clone ,)] pub struct ImmutableReference ; # [derive (Debug , Clone ,)] pub struct MutableReference ; impl peginator_generated :: PegParserAdvanced < () > for FunctionDef { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_FunctionDef (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod FunctionDef_impl { use super :: * ; mod part_5 { use super :: * ; mod optional { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"->\") }) . discard_result () ? ; let ParseOk { result : return_value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) . map_inner (Some) ? ; Ok (ParseOk { result : return_value , state }) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) } pub type Parsed = Option < Type > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"fn\") }) . discard_result () ? ; let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : param_list , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ParamList (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; let ParseOk { result : return_value , state } = part_5 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { name , param_list , return_value , } , state }) } pub struct Parsed { pub name : Ident , pub param_list : ParamList , pub return_value : Option < Type > , } } # [inline] pub (super) fn parse_FunctionDef < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FunctionDef > { global . tracer . print_trace_start (& state , \"FunctionDef\") ; let result = (|| { let result = FunctionDef_impl :: parse (state , global) ? . map (| r | super :: FunctionDef { name : r . name , param_list : r . param_list , return_value : r . return_value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ParamList_impl { use super :: * ; mod choice_0 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : self_param , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_SelfParam (state , & mut * global) }) . map_inner (Some) ? ; let ParseOk { result : mut params , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : Parsed { self_param , params , } , state }) } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } mod choice_1 { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ',') }) . discard_result () ? ; let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut params : Vec < Param > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { params . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut params , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Param (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { result : extend_params_with , state } = part_1 :: parse (state , global) ? ; params . extend (extend_params_with) ; Ok (ParseOk { result : params , state }) } pub type Parsed = Vec < Param > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global) . map_inner (| r | Parsed { self_param : r . self_param , params : r . params , })) . choice (| state | choice_1 :: parse (state , global) . map_inner (| r | Parsed { self_param : None , params : r , })) . choice (| state | Ok (ParseOk { result : () , state }) . map_inner (| r | Parsed { self_param : None , params : Vec :: new () , })) . end () } pub struct Parsed { pub self_param : Option < SelfParam > , pub params : Vec < Param > , } } # [inline] pub (super) fn parse_ParamList < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ParamList > { global . tracer . print_trace_start (& state , \"ParamList\") ; let result = (|| { let result = ParamList_impl :: parse (state , global) ? . map (| r | super :: ParamList { self_param : r . self_param , params : r . params , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Param_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : name , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ':') }) . discard_result () ? ; let ParseOk { result : typ , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Type (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { name , typ , } , state }) } pub struct Parsed { pub name : Ident , pub typ : Type , } } # [inline] pub (super) fn parse_Param < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Param > { global . tracer . print_trace_start (& state , \"Param\") ; let result = (|| { let result = Param_impl :: parse (state , global) ? . map (| r | super :: Param { name : r . name , typ : r . typ , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod SelfParam_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"self\") }) . discard_result () ? ; Ok (ParseOk { result : ref_type , state }) } pub type Parsed = Option < ReferenceMarker > ; } # [inline] pub (super) fn parse_SelfParam < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , SelfParam > { global . tracer . print_trace_start (& state , \"SelfParam\") ; let result = (|| { let result = SelfParam_impl :: parse (state , global) ? . map (| r | super :: SelfParam { ref_type : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Type_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : ref_type , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ReferenceMarker (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { result : typename , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { ref_type , typename , } , state }) } pub struct Parsed { pub ref_type : Option < ReferenceMarker > , pub typename : Ident , } } # [inline] pub (super) fn parse_Type < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Type > { global . tracer . print_trace_start (& state , \"Type\") ; let result = (|| { let result = Type_impl :: parse (state , global) ? . map (| r | super :: Type { ref_type : r . ref_type , typename : r . typename , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ReferenceMarker_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_MutableReference (state , & mut * global) }) . map_inner (Parsed__override :: MutableReference)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ImmutableReference (state , & mut * global) }) . map_inner (Parsed__override :: ImmutableReference)) . end () } pub type Parsed = Parsed__override ; use super :: ReferenceMarker as Parsed__override ; } # [inline] pub (super) fn parse_ReferenceMarker < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ReferenceMarker > { global . tracer . print_trace_start (& state , \"ReferenceMarker\") ; let result = (|| { let result = ReferenceMarker_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ImmutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ImmutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ImmutableReference > { global . tracer . print_trace_start (& state , \"ImmutableReference\") ; let result = (|| { let result = ImmutableReference_impl :: parse (state , global) ? . map (| r | super :: ImmutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod MutableReference_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '&') }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , \"mut\") }) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_MutableReference < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , MutableReference > { global . tracer . print_trace_start (& state , \"MutableReference\") ; let result = (|| { let result = MutableReference_impl :: parse (state , global) ? . map (| r | super :: MutableReference { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }","highlight_start":13293,"highlight_end":13304}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find function `parse_Ident` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/test_parser.rs:5:13293\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m) . and_then (| ParseOk { state , .. } | { parse_Ident (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { re\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 9 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 9 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0412, E0425.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0412, E0425.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0412`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0412`.\u001b[0m\n"}
